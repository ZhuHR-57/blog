/**
 * Generated by "@vuepress/internal-site-data"
 */
export const siteData = {
  "title": "Blog",
  "description": "Hello Bugs!",
  "base": "/blog/",
  "headTags": [
    [
      "link",
      {
        "rel": "icon",
        "href": "/blog/favicon.ico"
      }
    ],
    [
      "meta",
      {
        "name": "viewport",
        "content": "width=device-width,initial-scale=1,user-scalable=no"
      }
    ]
  ],
  "pages": [
    {
      "title": "脚手架",
      "frontmatter": {
        "title": "脚手架",
        "date": "2023-02-03T20:38:02.000Z",
        "permalink": "/pages/3e14ca/",
        "categories": [
          "Go",
          "框架",
          "Gin"
        ],
        "tags": [
          "go"
        ]
      },
      "regularPath": "/01.Go/01.%E6%A1%86%E6%9E%B6/01.Gin/01.%E8%84%9A%E6%89%8B%E6%9E%B6.html",
      "relativePath": "01.Go/01.框架/01.Gin/01.脚手架.md",
      "key": "v-7be915d8",
      "path": "/pages/3e14ca/",
      "headers": [
        {
          "level": 2,
          "title": "2",
          "slug": "_2",
          "normalizedTitle": "2",
          "charIndex": 58
        }
      ],
      "excerpt": "<div class=\"custom-block tip\"><p class=\"custom-block-title\">提示</p>\n<p>Gin+Mysql+Redis+Viper+Zap+sals</p>\n</div>\n<p>Gin 项目的脚手架</p>\n",
      "lastUpdated": "2/4/2023, 9:33:04 AM",
      "lastUpdatedTimestamp": 1675474384000,
      "headersStr": "2",
      "content": "提示\n\nGin+Mysql+Redis+Viper+Zap+sals\n\nGin 项目的脚手架\n\n\n\n# 1\n\n\n# 2",
      "normalizedContent": "提示\n\ngin+mysql+redis+viper+zap+sals\n\ngin 项目的脚手架\n\n\n\n# 1\n\n\n# 2",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "自动提交Github",
      "frontmatter": {
        "title": "自动提交Github",
        "date": "2023-05-22T20:41:38.000Z",
        "permalink": "/pages/27352f/",
        "categories": [
          "Go",
          "tools"
        ],
        "tags": [
          "go-tools"
        ]
      },
      "regularPath": "/01.Go/02.tools/02.%E8%87%AA%E5%8A%A8%E6%8F%90%E4%BA%A4Github.html",
      "relativePath": "01.Go/02.tools/02.自动提交Github.md",
      "key": "v-0a0e56be",
      "path": "/pages/27352f/",
      "headers": [
        {
          "level": 2,
          "title": "完整代码如下",
          "slug": "完整代码如下",
          "normalizedTitle": "完整代码如下",
          "charIndex": 30
        },
        {
          "level": 3,
          "title": "文件",
          "slug": "文件",
          "normalizedTitle": "文件",
          "charIndex": 41
        },
        {
          "level": 3,
          "title": "代码",
          "slug": "代码",
          "normalizedTitle": "代码",
          "charIndex": 32
        },
        {
          "level": 2,
          "title": "编译（Windos）",
          "slug": "编译-windos",
          "normalizedTitle": "编译（windos）",
          "charIndex": 1160
        },
        {
          "level": 2,
          "title": "任务计划",
          "slug": "任务计划",
          "normalizedTitle": "任务计划",
          "charIndex": 19
        }
      ],
      "excerpt": "<blockquote>\n<p>Go build + Git + 任务计划程序</p>\n</blockquote>\n",
      "lastUpdated": "5/22/2023, 8:42:57 PM",
      "lastUpdatedTimestamp": 1684759377000,
      "headersStr": "完整代码如下 文件 代码 编译（Windos） 任务计划",
      "content": "> Go build + Git + 任务计划程序\n\n\n# 完整代码如下\n\n\n# 文件\n\n * main.go\n\n\n# 代码\n\n/**\n  @Go version: 1.17.6\n  @project: Hello\n  @ide: GoLand\n  @file: main.go\n  @author: Lido\n  @time: 2023-05-22 20:08\n  @description: 提交Github\n*/\npackage main\n\nimport (\n\t\"log\"\n\t\"os\"\n\t\"os/exec\"\n)\n\n// 执行自动提交代码和推送到远程仓库\nfunc commitAndPush() error {\n\t// 切换到项目目录\n\tprojectPath := \"F:/Blog/Blog_Home_New/\"\n\tif err := os.Chdir(projectPath); err != nil {\n\t\treturn err\n\t}\n\n\t// 创建 git add 命令\n\taddCmd := exec.Command(\"git\", \"add\", \".\")\n\n\t// 执行 git add 命令\n\tif err := addCmd.Run(); err != nil {\n\t\treturn err\n\t}\n\n\t// 创建 git commit 命令\n\tcommitCmd := exec.Command(\"git\", \"commit\", \"-m\", \"Auto commit\")\n\n\t// 执行 git commit 命令\n\tif err := commitCmd.Run(); err != nil {\n\t\treturn err\n\t}\n\n\t// 创建 git push 命令\n\tpushCmd := exec.Command(\"git\", \"push\",\"-u\",\"origin\",\"master\")\n\n\t// 执行 git push 命令\n\tif err := pushCmd.Run(); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc main() {\n\tcommitAndPush()\n\n\tlog.Println(\"Code committed and pushed to GitHub.\")\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n\n\n# 编译（Windos）\n\n提示\n\n其他系统编译在上一篇文中有提\n\ngo build filename.go \n\n\n1\n\n\n\n# 任务计划\n\n 1. 打开任务计划程序。可以在开始菜单中搜索 \"任务计划程序\" 来找到它。\n 2. 在任务计划程序中，点击 \"创建基本任务\"。\n 3. 输入任务的名称和描述，然后点击 \"下一步\"。\n 4. 选择触发器类型为 \"每周\"，并选择每周的周一。\n 5. 选择操作类型为 \"启动程序\"。\n 6. 在程序 / 脚本字段中，输入 Go 程序的可执行文件路径。\n 7. 点击 \"完成\" 来创建计划任务。",
      "normalizedContent": "> go build + git + 任务计划程序\n\n\n# 完整代码如下\n\n\n# 文件\n\n * main.go\n\n\n# 代码\n\n/**\n  @go version: 1.17.6\n  @project: hello\n  @ide: goland\n  @file: main.go\n  @author: lido\n  @time: 2023-05-22 20:08\n  @description: 提交github\n*/\npackage main\n\nimport (\n\t\"log\"\n\t\"os\"\n\t\"os/exec\"\n)\n\n// 执行自动提交代码和推送到远程仓库\nfunc commitandpush() error {\n\t// 切换到项目目录\n\tprojectpath := \"f:/blog/blog_home_new/\"\n\tif err := os.chdir(projectpath); err != nil {\n\t\treturn err\n\t}\n\n\t// 创建 git add 命令\n\taddcmd := exec.command(\"git\", \"add\", \".\")\n\n\t// 执行 git add 命令\n\tif err := addcmd.run(); err != nil {\n\t\treturn err\n\t}\n\n\t// 创建 git commit 命令\n\tcommitcmd := exec.command(\"git\", \"commit\", \"-m\", \"auto commit\")\n\n\t// 执行 git commit 命令\n\tif err := commitcmd.run(); err != nil {\n\t\treturn err\n\t}\n\n\t// 创建 git push 命令\n\tpushcmd := exec.command(\"git\", \"push\",\"-u\",\"origin\",\"master\")\n\n\t// 执行 git push 命令\n\tif err := pushcmd.run(); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc main() {\n\tcommitandpush()\n\n\tlog.println(\"code committed and pushed to github.\")\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n\n\n# 编译（windos）\n\n提示\n\n其他系统编译在上一篇文中有提\n\ngo build filename.go \n\n\n1\n\n\n\n# 任务计划\n\n 1. 打开任务计划程序。可以在开始菜单中搜索 \"任务计划程序\" 来找到它。\n 2. 在任务计划程序中，点击 \"创建基本任务\"。\n 3. 输入任务的名称和描述，然后点击 \"下一步\"。\n 4. 选择触发器类型为 \"每周\"，并选择每周的周一。\n 5. 选择操作类型为 \"启动程序\"。\n 6. 在程序 / 脚本字段中，输入 go 程序的可执行文件路径。\n 7. 点击 \"完成\" 来创建计划任务。",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "文件传输（局域网）",
      "frontmatter": {
        "title": "文件传输（局域网）",
        "date": "2023-03-01T20:46:35.000Z",
        "permalink": "/pages/27351f/",
        "categories": [
          "Go",
          "tools"
        ],
        "tags": [
          "go-tools"
        ]
      },
      "regularPath": "/01.Go/02.tools/01.%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%EF%BC%88%E5%B1%80%E5%9F%9F%E7%BD%91%EF%BC%89.html",
      "relativePath": "01.Go/02.tools/01.文件传输（局域网）.md",
      "key": "v-8af7b2a4",
      "path": "/pages/27351f/",
      "headers": [
        {
          "level": 2,
          "title": "完整代码如下",
          "slug": "完整代码如下",
          "normalizedTitle": "完整代码如下",
          "charIndex": 30
        },
        {
          "level": 3,
          "title": "文件",
          "slug": "文件",
          "normalizedTitle": "文件",
          "charIndex": 13
        },
        {
          "level": 3,
          "title": "代码",
          "slug": "代码",
          "normalizedTitle": "代码",
          "charIndex": 32
        },
        {
          "level": 2,
          "title": "打包",
          "slug": "打包",
          "normalizedTitle": "打包",
          "charIndex": 2426
        },
        {
          "level": 2,
          "title": "编译(windows)",
          "slug": "编译-windows",
          "normalizedTitle": "编译 (windows)",
          "charIndex": 2533
        },
        {
          "level": 3,
          "title": "运行测试",
          "slug": "运行测试",
          "normalizedTitle": "运行测试",
          "charIndex": 2649
        },
        {
          "level": 2,
          "title": "交叉编译",
          "slug": "交叉编译",
          "normalizedTitle": "交叉编译",
          "charIndex": 3040
        },
        {
          "level": 3,
          "title": "Mac下编译Linux, Windows",
          "slug": "mac下编译linux-windows",
          "normalizedTitle": "mac 下编译 linux, windows",
          "charIndex": 3049
        },
        {
          "level": 3,
          "title": "Linux下编译Mac, Windows",
          "slug": "linux下编译mac-windows",
          "normalizedTitle": "linux 下编译 mac, windows",
          "charIndex": 3320
        },
        {
          "level": 3,
          "title": "Windows下编译Mac, Linux",
          "slug": "windows下编译mac-linux",
          "normalizedTitle": "windows 下编译 mac, linux",
          "charIndex": 3500
        },
        {
          "level": 2,
          "title": "说明",
          "slug": "说明",
          "normalizedTitle": "说明",
          "charIndex": 1036
        }
      ],
      "excerpt": "<blockquote>\n<p>Go build + 文件传输 + 命令行参数</p>\n</blockquote>\n",
      "lastUpdated": "5/22/2023, 8:42:57 PM",
      "lastUpdatedTimestamp": 1684759377000,
      "headersStr": "完整代码如下 文件 代码 打包 编译(windows) 运行测试 交叉编译 Mac下编译Linux, Windows Linux下编译Mac, Windows Windows下编译Mac, Linux 说明",
      "content": "> Go build + 文件传输 + 命令行参数\n\n\n# 完整代码如下\n\n\n# 文件\n\n * main.go\n * main.rc\n * mian.ico\n * mian.syso\n\n\n# 代码\n\n/**\n* @program: Hello\n* @filename: main.go\n* @author: Lido\n* @create: 2022-02-03 11:30\n* @description: 文件传输（局域网）\n**/\n\npackage main\n\nimport (\n\t\"errors\"\n\t\"flag\"\n\t\"log\"\n\t\"net\"\n\t\"net/http\"\n)\n\nvar isUsefunc bool = false\n\nfunc logRequest(handler http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tlog.Printf(\"%s %s %s\\n\", r.RemoteAddr, r.Method, r.URL)\n\t\thandler.ServeHTTP(w, r)\n\t})\n}\n\nfunc main() {\n\t//当前文件夹\n\tfs := http.FileServer(http.Dir(\"\"))\n\t/**\n\t解析命令行参数\n\t*/\n\t//默认值设置\n\tflag.Func(\"gip\", \"-gip ip/mac/im\", getIpAndMacAddress)\n\tip := flag.String(\"ip\", \"127.0.0.1\", \"ip\")\n\tport := flag.String(\"port\", \"8089\", \"port\")\n\t//解析\n\tflag.Parse()\n\n\tif isUsefunc {\n\t\treturn\n\t}\n\n\t//字符串拼接\n\turl := *ip+\":\"+*port\n\turl_full := \"http://\"+url\n\n\tlog.Println(\"running server at \"+url_full)\n\t//监听\n\tlog.Fatal(http.ListenAndServe(url, logRequest(fs)))\n}\n\nfunc getIpAndMacAddress(str string) error{\n\tlog.Println(\"说明：\")\n\tlog.Println(\"一般最后一个是本机的WIFI的本地IP\\n\")\n\n\tlog.Println(\"案例：\")\n\tlog.Println(\"file-web.exe -ip 192.168.xxx.xxx -port xxxx\\n\")\n\n\tifaces, err := net.Interfaces()\n\tif err != nil {\n\t\tlog.Println(err)\n\t}\n\n\tfor _, iface := range ifaces {\n\t\tif iface.Flags&net.FlagUp == 0 {\n\t\t\tcontinue // interface down\n\t\t}\n\t\tif iface.Flags&net.FlagLoopback != 0 {\n\t\t\tcontinue // loopback interface\n\t\t}\n\t\taddrs, err := iface.Addrs()\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t}\n\n\t\tfor _, addr := range addrs {\n\t\t\tvar ip net.IP\n\t\t\tswitch v := addr.(type) {\n\t\t\tcase *net.IPNet:\n\t\t\t\tip = v.IP\n\t\t\tcase *net.IPAddr:\n\t\t\t\tip = v.IP\n\t\t\t}\n\t\t\tif ip == nil || ip.IsLoopback() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tip = ip.To4()\n\t\t\tif ip == nil {\n\t\t\t\tcontinue // not an ipv4 address\n\t\t\t}\n\n\t\t\tif str == \"ip\" {\n\t\t\t\tlog.Println(\"ip: \", ip.String())\n\t\t\t}else if str == \"mac\"{\n\t\t\t\tlog.Println(\"mac: \", iface.HardwareAddr.String())\n\t\t\t}else if str  == \"im\"{\n\t\t\t\tlog.Println(\"ip: \", ip.String(), \"mac: \", iface.HardwareAddr.String())\n\t\t\t}else {\n\t\t\t\treturn errors.New(\"-1\")\n\t\t\t}\n\t\t}\n\t}\n\n\tisUsefunc = true\n\treturn nil\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n\n\n\n# 打包\n\n提示\n\n 1. 创建 main.rc 文件\n\nIDI_ICON1 ICON \"main.ico\"\n\n\n1\n\n\n提示\n\n 2. 找好 ioc 图标（128*128），将图形名称改为 main.ico\n\n\n# 编译 (windows)\n\n提示\n\n将上面两个文件和 go 源文件放在一起\n\n打开终端\n\nwindres -o main.syso main.rc\n\n\n1\n\n\ngo build  -ldflags \"-w -s\"\n\n\n1\n\n\n\n# 运行测试\n\nF:\\GOCODE\\Hello\\file-web>file-web.exe -gip ip\n2022/02/03 14:22:14 说明：\n2022/02/03 14:22:14 一般最后一个是本机的WIFI的本地IP\n\n2022/02/03 14:22:14 案例：\n2022/02/03 14:22:14 file-web.exe -ip 192.168.xxx.xxx -port xxxx\n\n2022/02/03 14:22:14 ip:  192.168.137.1\n2022/02/03 14:22:14 ip:  192.168.195.1\n2022/02/03 14:22:14 ip:  192.168.134.1\n2022/02/03 14:22:14 ip:  192.168.3.9\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 交叉编译\n\n\n# Mac 下编译 Linux, Windows\n\n# Linux\nCGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build filename.go\n \n# Windows\nCGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build filename.go\n如: CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build -o helloworld-windows helloworld.go\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# Linux 下编译 Mac, Windows\n\n# Mac\nCGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build filename.go\n \n# Windows\nCGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build filename.go\n\n\n1\n2\n3\n4\n5\n\n\n\n# Windows 下编译 Mac, Linux\n\n# Mac\nSET CGO_ENABLED=0\nSET GOOS=darwin\nSET GOARCH=amd64\ngo build filename.go\n \n# Linux\nSET CGO_ENABLED=0\nSET GOOS=linux\nSET GOARCH=amd64\ngo build filename.go -ldflags \"-w -s\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nchomd 777 xxx\n\n\n1\n\n\n\n# 说明\n\n 1. 以上两种解决方法只能临时修改 go 的环境变量，重启 Goland 或者重启 cmd 终端后失效。\n\n 2. 执行 go env -w GOOS=linux 可以修改 go 的环境变量 GOOS，且当重启 Goland 后或者打开其他项目后都有效。但是在 Git Bash 下执行 chmod 777 xx 赋予文件 xx 可执行权限失败。\n\n 3. 如果按上述方式永久修改了 GOOS，使用 Goland 的 run 命令直接运行程序会失败，即使临时设置 export GOOS=windows 也不起作用，只能通过 go env -w GOOS=windows 修改 GOOS 后才能在 Goland 中直接运行程序。\n\n终上所述，在 windows 系统的 Goland 中编译 Linux 的可执行程序时，建议临时修改 export GOOS=linux，而不是使用 go env -w GOOS=linux 永久修改。",
      "normalizedContent": "> go build + 文件传输 + 命令行参数\n\n\n# 完整代码如下\n\n\n# 文件\n\n * main.go\n * main.rc\n * mian.ico\n * mian.syso\n\n\n# 代码\n\n/**\n* @program: hello\n* @filename: main.go\n* @author: lido\n* @create: 2022-02-03 11:30\n* @description: 文件传输（局域网）\n**/\n\npackage main\n\nimport (\n\t\"errors\"\n\t\"flag\"\n\t\"log\"\n\t\"net\"\n\t\"net/http\"\n)\n\nvar isusefunc bool = false\n\nfunc logrequest(handler http.handler) http.handler {\n\treturn http.handlerfunc(func(w http.responsewriter, r *http.request) {\n\t\tlog.printf(\"%s %s %s\\n\", r.remoteaddr, r.method, r.url)\n\t\thandler.servehttp(w, r)\n\t})\n}\n\nfunc main() {\n\t//当前文件夹\n\tfs := http.fileserver(http.dir(\"\"))\n\t/**\n\t解析命令行参数\n\t*/\n\t//默认值设置\n\tflag.func(\"gip\", \"-gip ip/mac/im\", getipandmacaddress)\n\tip := flag.string(\"ip\", \"127.0.0.1\", \"ip\")\n\tport := flag.string(\"port\", \"8089\", \"port\")\n\t//解析\n\tflag.parse()\n\n\tif isusefunc {\n\t\treturn\n\t}\n\n\t//字符串拼接\n\turl := *ip+\":\"+*port\n\turl_full := \"http://\"+url\n\n\tlog.println(\"running server at \"+url_full)\n\t//监听\n\tlog.fatal(http.listenandserve(url, logrequest(fs)))\n}\n\nfunc getipandmacaddress(str string) error{\n\tlog.println(\"说明：\")\n\tlog.println(\"一般最后一个是本机的wifi的本地ip\\n\")\n\n\tlog.println(\"案例：\")\n\tlog.println(\"file-web.exe -ip 192.168.xxx.xxx -port xxxx\\n\")\n\n\tifaces, err := net.interfaces()\n\tif err != nil {\n\t\tlog.println(err)\n\t}\n\n\tfor _, iface := range ifaces {\n\t\tif iface.flags&net.flagup == 0 {\n\t\t\tcontinue // interface down\n\t\t}\n\t\tif iface.flags&net.flagloopback != 0 {\n\t\t\tcontinue // loopback interface\n\t\t}\n\t\taddrs, err := iface.addrs()\n\t\tif err != nil {\n\t\t\tlog.println(err)\n\t\t}\n\n\t\tfor _, addr := range addrs {\n\t\t\tvar ip net.ip\n\t\t\tswitch v := addr.(type) {\n\t\t\tcase *net.ipnet:\n\t\t\t\tip = v.ip\n\t\t\tcase *net.ipaddr:\n\t\t\t\tip = v.ip\n\t\t\t}\n\t\t\tif ip == nil || ip.isloopback() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tip = ip.to4()\n\t\t\tif ip == nil {\n\t\t\t\tcontinue // not an ipv4 address\n\t\t\t}\n\n\t\t\tif str == \"ip\" {\n\t\t\t\tlog.println(\"ip: \", ip.string())\n\t\t\t}else if str == \"mac\"{\n\t\t\t\tlog.println(\"mac: \", iface.hardwareaddr.string())\n\t\t\t}else if str  == \"im\"{\n\t\t\t\tlog.println(\"ip: \", ip.string(), \"mac: \", iface.hardwareaddr.string())\n\t\t\t}else {\n\t\t\t\treturn errors.new(\"-1\")\n\t\t\t}\n\t\t}\n\t}\n\n\tisusefunc = true\n\treturn nil\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n\n\n\n# 打包\n\n提示\n\n 1. 创建 main.rc 文件\n\nidi_icon1 icon \"main.ico\"\n\n\n1\n\n\n提示\n\n 2. 找好 ioc 图标（128*128），将图形名称改为 main.ico\n\n\n# 编译 (windows)\n\n提示\n\n将上面两个文件和 go 源文件放在一起\n\n打开终端\n\nwindres -o main.syso main.rc\n\n\n1\n\n\ngo build  -ldflags \"-w -s\"\n\n\n1\n\n\n\n# 运行测试\n\nf:\\gocode\\hello\\file-web>file-web.exe -gip ip\n2022/02/03 14:22:14 说明：\n2022/02/03 14:22:14 一般最后一个是本机的wifi的本地ip\n\n2022/02/03 14:22:14 案例：\n2022/02/03 14:22:14 file-web.exe -ip 192.168.xxx.xxx -port xxxx\n\n2022/02/03 14:22:14 ip:  192.168.137.1\n2022/02/03 14:22:14 ip:  192.168.195.1\n2022/02/03 14:22:14 ip:  192.168.134.1\n2022/02/03 14:22:14 ip:  192.168.3.9\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 交叉编译\n\n\n# mac 下编译 linux, windows\n\n# linux\ncgo_enabled=0 goos=linux goarch=amd64 go build filename.go\n \n# windows\ncgo_enabled=0 goos=windows goarch=amd64 go build filename.go\n如: cgo_enabled=0 goos=windows goarch=amd64 go build -o helloworld-windows helloworld.go\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# linux 下编译 mac, windows\n\n# mac\ncgo_enabled=0 goos=darwin goarch=amd64 go build filename.go\n \n# windows\ncgo_enabled=0 goos=windows goarch=amd64 go build filename.go\n\n\n1\n2\n3\n4\n5\n\n\n\n# windows 下编译 mac, linux\n\n# mac\nset cgo_enabled=0\nset goos=darwin\nset goarch=amd64\ngo build filename.go\n \n# linux\nset cgo_enabled=0\nset goos=linux\nset goarch=amd64\ngo build filename.go -ldflags \"-w -s\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nchomd 777 xxx\n\n\n1\n\n\n\n# 说明\n\n 1. 以上两种解决方法只能临时修改 go 的环境变量，重启 goland 或者重启 cmd 终端后失效。\n\n 2. 执行 go env -w goos=linux 可以修改 go 的环境变量 goos，且当重启 goland 后或者打开其他项目后都有效。但是在 git bash 下执行 chmod 777 xx 赋予文件 xx 可执行权限失败。\n\n 3. 如果按上述方式永久修改了 goos，使用 goland 的 run 命令直接运行程序会失败，即使临时设置 export goos=windows 也不起作用，只能通过 go env -w goos=windows 修改 goos 后才能在 goland 中直接运行程序。\n\n终上所述，在 windows 系统的 goland 中编译 linux 的可执行程序时，建议临时修改 export goos=linux，而不是使用 go env -w goos=linux 永久修改。",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "string类型",
      "frontmatter": {
        "title": "string类型",
        "date": "2023-05-31T14:28:36.000Z",
        "permalink": "/pages/b6ba67/",
        "categories": [
          "Go",
          "深入Go"
        ],
        "tags": [
          "探索-GO"
        ]
      },
      "regularPath": "/01.Go/03.%E6%B7%B1%E5%85%A5Go/01.string%E7%B1%BB%E5%9E%8B.html",
      "relativePath": "01.Go/03.深入Go/01.string类型.md",
      "key": "v-2658628c",
      "path": "/pages/b6ba67/",
      "headers": [
        {
          "level": 2,
          "title": "字符咋存❓",
          "slug": "字符咋存",
          "normalizedTitle": "字符咋存❓",
          "charIndex": 48
        },
        {
          "level": 2,
          "title": "utf8咋编码❓",
          "slug": "utf8咋编码",
          "normalizedTitle": "utf8 咋编码❓",
          "charIndex": 112
        },
        {
          "level": 3,
          "title": "定长编码",
          "slug": "定长编码",
          "normalizedTitle": "定长编码",
          "charIndex": 174
        },
        {
          "level": 3,
          "title": "变成编码",
          "slug": "变成编码",
          "normalizedTitle": "变成编码",
          "charIndex": 185
        },
        {
          "level": 3,
          "title": "总结",
          "slug": "总结",
          "normalizedTitle": "总结",
          "charIndex": 407
        },
        {
          "level": 2,
          "title": "string啥结构❓",
          "slug": "string啥结构",
          "normalizedTitle": "string 啥结构❓",
          "charIndex": 473
        },
        {
          "level": 3,
          "title": "长度和占用空间",
          "slug": "长度和占用空间",
          "normalizedTitle": "长度和占用空间",
          "charIndex": 960
        }
      ],
      "excerpt": "<blockquote>\n<p>字符咋存？utf8 咋编码？string 啥结构？</p>\n<p>form：<a href=\"https://space.bilibili.com/567195437\" target=\"_blank\" rel=\"noopener noreferrer\">幼麟实验室<OutboundLink/></a></p>\n</blockquote>\n",
      "lastUpdated": "6/2/2023, 6:34:00 PM",
      "lastUpdatedTimestamp": 1685702040000,
      "headersStr": "字符咋存❓ utf8咋编码❓ 定长编码 变成编码 总结 string啥结构❓ 长度和占用空间",
      "content": "> 字符咋存？utf8 咋编码？string 啥结构？\n> \n> form：幼麟实验室\n\n\n# 字符咋存❓\n\n同样是二进制存储，通过编码（指定特定 01 排列顺序为某一字符）如常见的 ASCII、GBK、UTF-8\n\n\n# utf8 咋编码❓\n\n由上面的的问题我们知道了，存储字符本质就是保存编码\n\n> 常见的两种保存编码的方式\n> \n>  1. 定长编码\n>  2. 变成编码\n\n\n# 定长编码\n\n不管长短都都按最长的编码，可以看出非常的浪费内存，如下图\n\n\n\n\n# 变成编码\n\n根据特定的前缀编号来存储，如下图\n\n\n\n小练习\n\n字符   十进制     二进制                最终存储\ne    101     1100101            01100101\n世    19990   0100111000010110   11100100 10111000 10010110\n\n\n# 总结\n\n * 在 Go 语言中默认采用的就是 UTF-8 的编解码方式。\n\n * 字符集 + 编码方式 => 正确存储字符\n\n\n# string 啥结构❓\n\n核心问题就是：“如何判断字符结束”？\n\n * C 语言是有 '\\0' 的特定标识符\n\n * Go 语言中采用的是：data + len （16 字节）\n   \n   type StringHeader struct {\n       Data uintptr\n       Len  int\n   }\n   \n   \n   1\n   2\n   3\n   4\n   \n\n注意\n\n 1. 在 Go 语言中，编译器会将字符串内容放入只读内存段，所以不允许修改\n\n 2. 字符串变量可以共用底层字符串内容\n\n\n\n 3. 非要修改\n    \n    1. 可以重新赋值\n    \n    s1 = \"hello\"\n    \n    \n    1\n    \n    2. 强制类型转换为 slice，原理是重新分配内存并拷贝原来字符串内容\n    \n    bs := ([]byte)(s1)\n    bs[2] = 'o'\n    fmt.Printf(\"%c\\n\",bs[2])\n    \n    \n    1\n    2\n    3\n    \n\n\n# 长度和占用空间\n\n在 Go 语言中，一个 UTF-8 编码的字符可能由 1 到 4 个字节组成，因此字符串的长度和占用的内存空间并不一定相同。",
      "normalizedContent": "> 字符咋存？utf8 咋编码？string 啥结构？\n> \n> form：幼麟实验室\n\n\n# 字符咋存❓\n\n同样是二进制存储，通过编码（指定特定 01 排列顺序为某一字符）如常见的 ascii、gbk、utf-8\n\n\n# utf8 咋编码❓\n\n由上面的的问题我们知道了，存储字符本质就是保存编码\n\n> 常见的两种保存编码的方式\n> \n>  1. 定长编码\n>  2. 变成编码\n\n\n# 定长编码\n\n不管长短都都按最长的编码，可以看出非常的浪费内存，如下图\n\n\n\n\n# 变成编码\n\n根据特定的前缀编号来存储，如下图\n\n\n\n小练习\n\n字符   十进制     二进制                最终存储\ne    101     1100101            01100101\n世    19990   0100111000010110   11100100 10111000 10010110\n\n\n# 总结\n\n * 在 go 语言中默认采用的就是 utf-8 的编解码方式。\n\n * 字符集 + 编码方式 => 正确存储字符\n\n\n# string 啥结构❓\n\n核心问题就是：“如何判断字符结束”？\n\n * c 语言是有 '\\0' 的特定标识符\n\n * go 语言中采用的是：data + len （16 字节）\n   \n   type stringheader struct {\n       data uintptr\n       len  int\n   }\n   \n   \n   1\n   2\n   3\n   4\n   \n\n注意\n\n 1. 在 go 语言中，编译器会将字符串内容放入只读内存段，所以不允许修改\n\n 2. 字符串变量可以共用底层字符串内容\n\n\n\n 3. 非要修改\n    \n    1. 可以重新赋值\n    \n    s1 = \"hello\"\n    \n    \n    1\n    \n    2. 强制类型转换为 slice，原理是重新分配内存并拷贝原来字符串内容\n    \n    bs := ([]byte)(s1)\n    bs[2] = 'o'\n    fmt.printf(\"%c\\n\",bs[2])\n    \n    \n    1\n    2\n    3\n    \n\n\n# 长度和占用空间\n\n在 go 语言中，一个 utf-8 编码的字符可能由 1 到 4 个字节组成，因此字符串的长度和占用的内存空间并不一定相同。",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "slice类型",
      "frontmatter": {
        "title": "slice类型",
        "date": "2023-06-02T16:46:03.000Z",
        "permalink": "/pages/5b42f7/",
        "categories": [
          "Go",
          "深入Go"
        ],
        "tags": [
          "探索-GO"
        ]
      },
      "regularPath": "/01.Go/03.%E6%B7%B1%E5%85%A5Go/02.slice%E7%B1%BB%E5%9E%8B.html",
      "relativePath": "01.Go/03.深入Go/02.slice类型.md",
      "key": "v-d54e0650",
      "path": "/pages/5b42f7/",
      "headers": [
        {
          "level": 2,
          "title": "slice类型存什么❓",
          "slug": "slice类型存什么",
          "normalizedTitle": "slice 类型存什么❓",
          "charIndex": 63
        },
        {
          "level": 2,
          "title": "make和new❓",
          "slug": "make和new",
          "normalizedTitle": "make 和 new❓",
          "charIndex": 238
        },
        {
          "level": 2,
          "title": "slice和数组❓",
          "slug": "slice和数组",
          "normalizedTitle": "slice 和数组❓",
          "charIndex": 854
        },
        {
          "level": 2,
          "title": "扩容规则❓",
          "slug": "扩容规则",
          "normalizedTitle": "扩容规则❓",
          "charIndex": 1169
        },
        {
          "level": 3,
          "title": "1. 预估拓容后容量（元素个数）",
          "slug": "_1-预估拓容后容量-元素个数",
          "normalizedTitle": "1. 预估拓容后容量（元素个数）",
          "charIndex": 1179
        },
        {
          "level": 3,
          "title": "2. 判断内存大小",
          "slug": "_2-判断内存大小",
          "normalizedTitle": "2. 判断内存大小",
          "charIndex": 2281
        },
        {
          "level": 3,
          "title": "3. 匹配到合适的内存规格",
          "slug": "_3-匹配到合适的内存规格",
          "normalizedTitle": "3. 匹配到合适的内存规格",
          "charIndex": 2343
        },
        {
          "level": 3,
          "title": "小练习",
          "slug": "小练习",
          "normalizedTitle": "小练习",
          "charIndex": 2557
        }
      ],
      "excerpt": "<blockquote>\n<p>slice 类型存什么？ make 和 new？ slice 和数组？扩容规则？</p>\n<p>form：<a href=\"https://www.bilibili.com/video/BV1CV411d7W8\" target=\"_blank\" rel=\"noopener noreferrer\">幼麟实验室<OutboundLink/></a></p>\n</blockquote>\n",
      "lastUpdated": "6/2/2023, 6:34:00 PM",
      "lastUpdatedTimestamp": 1685702040000,
      "headersStr": "slice类型存什么❓ make和new❓ slice和数组❓ 扩容规则❓ 1. 预估拓容后容量（元素个数） 2. 判断内存大小 3. 匹配到合适的内存规格 小练习",
      "content": "> slice 类型存什么？ make 和 new？ slice 和数组？扩容规则？\n> \n> form：幼麟实验室\n\n\n# slice 类型存什么❓\n\n 1. 切片是什么结构？\n    \n    slice 由三部分组成，分别是 data、len、cap\n\n * data：元素存哪里\n * len： 已存元素\n * cap： 可存元素\n\n// 申明切片\nvar ints []int // 此时变量ints中 [data=nil | 0 | 0 ]\n\n\n1\n2\n\n\n\n# make 和 new❓\n\n> make\n\n 1. 分配 cap 大小的底层数组空间\n 2. 全部初始化为 0\n\n// make初始化\nvar ints []int= make([]int,2,5); // 变量ints中 [data=(指针)[0,0,0,0,0] | 2 | 5 ]\n\n\n1\n2\n\n\n添加一个元素，由于已经使用了两个元素，所以从第三个元素开始添加\n\nints = append(ints,1)\t\t\t // 变量ints中 [data=(指针)[0,0,1,0,0] | 3 | 5 ]\n\n\n1\n\n\n在 len 范围内的元素可以安全读写，超出范围则会 panic\n\nints[0] = 1; // right\nints[3] = 1; // panic\n\n\n1\n2\n\n\n\n\n----------------------------------------\n\n> new\n\n 1. 不会分配底层数组的地址空间\n 2. 返回值为 slice 的起始指针\n\n// new初始化\nps := new([]string) // [data = nil | 0 | 0 ]\n\n\n1\n2\n\n\n由于没有底层数组，直接操作 ps 会 panic\n\n(*ps)[0] = \"eggo\" // panic\n\n\n1\n\n\n通过 append () 函数来分配底层数组\n\n*ps = append(*ps,\"eggo\")\n\n\n1\n\n\n\n\n\n# slice 和数组❓\n\n * slice 操作共同的底层数组\n\narr := [10]int{0,1,2,3,4,5,6,7,8,9}\n// 左闭右开\nvar s1 []int = arr[1:4] // [1 2 3] len = 3 cap = 9(直接到头)\nvar s2 []int = arr[7:]  // [7 8 9] len = 3 cap = 3\n\n\n1\n2\n3\n4\n\n\n\n\n * 再给 s2 添加元素\n   * 开辟新的底层数组\n   * 拷贝原来的底层数组（s2 所使用的部分）\n   * 再添加新的元素\n   * 修改 len 和 cap\n\ns2 = append(s2,10) \n\n\n1\n\n\n\n\n\n# 扩容规则❓\n\n\n# 1. 预估拓容后容量（元素个数）\n\n// go 1.9.5 src/runtime/slice.go:82\nfunc growslice(et *_type, old slice, cap int) slice {\n    // ……\n    newcap := old.cap\n    doublecap := newcap + newcap\n    if cap > doublecap {\n        newcap = cap\n    } else {\n        if old.len < 1024 {\n            newcap = doublecap\n        } else {\n            for newcap < cap {\n                newcap += newcap / 4\n            }\n        }\n    }\n    // ……\n\n    capmem = roundupsize(uintptr(newcap) * ptrSize)\n    newcap = int(capmem / ptrSize)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n如果只看前半部分，现在网上各种文章里说的 newcap 的规律是对的。现实是，后半部分还对 newcap 作了一个 内存对齐 ，这个和内存分配策略相关。进行内存对齐之后，新 slice 的容量是要 大于等于 老 slice 容量的 2倍 或者 1.25倍 。\n\n之后，向 Go 内存管理器申请内存，将老 slice 中的数据复制过去，并且将 append 的元素添加到新的底层数组中。\n\n最后，向 growslice 函数调用者返回一个新的 slice，这个 slice 的长度并没有变化，而容量却增大了。\n\n 1. 如果期望容量大于当前容量的两倍就会使用期望容量；\n 2. 如果当前切片的长度小于 1024 就会将容量翻倍；\n 3. 如果当前切片的长度大于 1024 ，由于有内存对齐，每次会大于原定的 1.25 一点；\n\n// 如果期望容量大于当前容量的两倍就会使用期望容量；\nints := []int{1,2}\nints = appned(ints[],3,4,5)\n// 此时ints len = 2，翻倍后 = 4，而期望容量是 2 + 3 = 5\n// 也就是望容量大于当前容量的两倍\n// 此时容量 = 期望容量 = 5\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 2. 判断内存大小\n\n第一步的预估容量仅是个数，实际的元素还要考虑大小，也就是容量 = 元素个数 * 元素类型大小\n\n\n# 3. 匹配到合适的内存规格\n\n * 流程：容量 <---> Go 语言内存管理模块 <---> 操作系统\n\n当然并不是直接分配计算出的容量就 ok 了，在多数编程语言中，申请分配内存并不是直接与操作系统交涉，而是与语言自身实现的内存管理模块，内存管理模块会提前向操作系统申请一块内存，一般是 2 的整数倍（8、16、32、64、80、96、112...）然后分成常用的规格管理起来，申请内存时会匹配到足够大且接近的内存\n\n\n# 小练习\n\n",
      "normalizedContent": "> slice 类型存什么？ make 和 new？ slice 和数组？扩容规则？\n> \n> form：幼麟实验室\n\n\n# slice 类型存什么❓\n\n 1. 切片是什么结构？\n    \n    slice 由三部分组成，分别是 data、len、cap\n\n * data：元素存哪里\n * len： 已存元素\n * cap： 可存元素\n\n// 申明切片\nvar ints []int // 此时变量ints中 [data=nil | 0 | 0 ]\n\n\n1\n2\n\n\n\n# make 和 new❓\n\n> make\n\n 1. 分配 cap 大小的底层数组空间\n 2. 全部初始化为 0\n\n// make初始化\nvar ints []int= make([]int,2,5); // 变量ints中 [data=(指针)[0,0,0,0,0] | 2 | 5 ]\n\n\n1\n2\n\n\n添加一个元素，由于已经使用了两个元素，所以从第三个元素开始添加\n\nints = append(ints,1)\t\t\t // 变量ints中 [data=(指针)[0,0,1,0,0] | 3 | 5 ]\n\n\n1\n\n\n在 len 范围内的元素可以安全读写，超出范围则会 panic\n\nints[0] = 1; // right\nints[3] = 1; // panic\n\n\n1\n2\n\n\n\n\n----------------------------------------\n\n> new\n\n 1. 不会分配底层数组的地址空间\n 2. 返回值为 slice 的起始指针\n\n// new初始化\nps := new([]string) // [data = nil | 0 | 0 ]\n\n\n1\n2\n\n\n由于没有底层数组，直接操作 ps 会 panic\n\n(*ps)[0] = \"eggo\" // panic\n\n\n1\n\n\n通过 append () 函数来分配底层数组\n\n*ps = append(*ps,\"eggo\")\n\n\n1\n\n\n\n\n\n# slice 和数组❓\n\n * slice 操作共同的底层数组\n\narr := [10]int{0,1,2,3,4,5,6,7,8,9}\n// 左闭右开\nvar s1 []int = arr[1:4] // [1 2 3] len = 3 cap = 9(直接到头)\nvar s2 []int = arr[7:]  // [7 8 9] len = 3 cap = 3\n\n\n1\n2\n3\n4\n\n\n\n\n * 再给 s2 添加元素\n   * 开辟新的底层数组\n   * 拷贝原来的底层数组（s2 所使用的部分）\n   * 再添加新的元素\n   * 修改 len 和 cap\n\ns2 = append(s2,10) \n\n\n1\n\n\n\n\n\n# 扩容规则❓\n\n\n# 1. 预估拓容后容量（元素个数）\n\n// go 1.9.5 src/runtime/slice.go:82\nfunc growslice(et *_type, old slice, cap int) slice {\n    // ……\n    newcap := old.cap\n    doublecap := newcap + newcap\n    if cap > doublecap {\n        newcap = cap\n    } else {\n        if old.len < 1024 {\n            newcap = doublecap\n        } else {\n            for newcap < cap {\n                newcap += newcap / 4\n            }\n        }\n    }\n    // ……\n\n    capmem = roundupsize(uintptr(newcap) * ptrsize)\n    newcap = int(capmem / ptrsize)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n如果只看前半部分，现在网上各种文章里说的 newcap 的规律是对的。现实是，后半部分还对 newcap 作了一个 内存对齐 ，这个和内存分配策略相关。进行内存对齐之后，新 slice 的容量是要 大于等于 老 slice 容量的 2倍 或者 1.25倍 。\n\n之后，向 go 内存管理器申请内存，将老 slice 中的数据复制过去，并且将 append 的元素添加到新的底层数组中。\n\n最后，向 growslice 函数调用者返回一个新的 slice，这个 slice 的长度并没有变化，而容量却增大了。\n\n 1. 如果期望容量大于当前容量的两倍就会使用期望容量；\n 2. 如果当前切片的长度小于 1024 就会将容量翻倍；\n 3. 如果当前切片的长度大于 1024 ，由于有内存对齐，每次会大于原定的 1.25 一点；\n\n// 如果期望容量大于当前容量的两倍就会使用期望容量；\nints := []int{1,2}\nints = appned(ints[],3,4,5)\n// 此时ints len = 2，翻倍后 = 4，而期望容量是 2 + 3 = 5\n// 也就是望容量大于当前容量的两倍\n// 此时容量 = 期望容量 = 5\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 2. 判断内存大小\n\n第一步的预估容量仅是个数，实际的元素还要考虑大小，也就是容量 = 元素个数 * 元素类型大小\n\n\n# 3. 匹配到合适的内存规格\n\n * 流程：容量 <---> go 语言内存管理模块 <---> 操作系统\n\n当然并不是直接分配计算出的容量就 ok 了，在多数编程语言中，申请分配内存并不是直接与操作系统交涉，而是与语言自身实现的内存管理模块，内存管理模块会提前向操作系统申请一块内存，一般是 2 的整数倍（8、16、32、64、80、96、112...）然后分成常用的规格管理起来，申请内存时会匹配到足够大且接近的内存\n\n\n# 小练习\n\n",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "G0",
      "frontmatter": {
        "pageComponent": {
          "name": "Catalogue",
          "data": {
            "key": "01.Go",
            "imgUrl": "/assets/img/go.png",
            "description": "Go Go Go"
          }
        },
        "title": "G0",
        "date": "2023-02-03 20:17",
        "permalink": "/go/",
        "sidebar": false,
        "article": false,
        "comment": false,
        "comments": false,
        "editLink": false
      },
      "regularPath": "/01.Go/",
      "relativePath": "01.Go/index.md",
      "key": "v-274e5b96",
      "path": "/go/",
      "lastUpdated": "2/4/2023, 9:33:04 AM",
      "lastUpdatedTimestamp": 1675474384000,
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {}
    },
    {
      "title": "Day00-准备",
      "frontmatter": {
        "title": "Day00-准备",
        "date": "2023-05-26T23:35:49.000Z",
        "permalink": "/pages/fc80dd/",
        "categories": [
          "算法",
          "算法打卡"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/02.%E7%AE%97%E6%B3%95/01.%E7%AE%97%E6%B3%95%E6%89%93%E5%8D%A1/00.Day00-%E5%87%86%E5%A4%87.html",
      "relativePath": "02.算法/01.算法打卡/00.Day00-准备.md",
      "key": "v-2ee9027a",
      "path": "/pages/fc80dd/",
      "headers": [
        {
          "level": 2,
          "title": "格式",
          "slug": "格式",
          "normalizedTitle": "格式",
          "charIndex": 11
        },
        {
          "level": 3,
          "title": "录前想法",
          "slug": "录前想法",
          "normalizedTitle": "录前想法",
          "charIndex": 60
        },
        {
          "level": 3,
          "title": "录后想法",
          "slug": "录后想法",
          "normalizedTitle": "录后想法",
          "charIndex": 69
        },
        {
          "level": 3,
          "title": "总结",
          "slug": "总结",
          "normalizedTitle": "总结",
          "charIndex": 78
        },
        {
          "level": 2,
          "title": "常用表情",
          "slug": "常用表情",
          "normalizedTitle": "常用表情",
          "charIndex": 85
        }
      ],
      "excerpt": "<blockquote>\n<p>前置准备</p>\n</blockquote>\n",
      "lastUpdated": "6/2/2023, 6:34:00 PM",
      "lastUpdatedTimestamp": 1685702040000,
      "headersStr": "格式 录前想法 录后想法 总结 常用表情",
      "content": "> 前置准备\n\n\n# 格式\n\n * 题目：704. 二分查找\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：\n\n\n# 录前想法\n\n\n# 录后想法\n\n\n# 总结\n\n\n# 常用表情\n\n❌\n\n✔️\n\n😂\n\n😰\n\n😓\n\n✌️\n\n❗️\n\n‼️",
      "normalizedContent": "> 前置准备\n\n\n# 格式\n\n * 题目：704. 二分查找\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：\n\n\n# 录前想法\n\n\n# 录后想法\n\n\n# 总结\n\n\n# 常用表情\n\n❌\n\n✔️\n\n😂\n\n😰\n\n😓\n\n✌️\n\n❗️\n\n‼️",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "Day01-数组",
      "frontmatter": {
        "title": "Day01-数组",
        "date": "2023-05-24T16:20:33.000Z",
        "permalink": "/pages/8aab7b/",
        "categories": [
          "算法",
          "算法打卡"
        ],
        "tags": [
          "打卡"
        ]
      },
      "regularPath": "/02.%E7%AE%97%E6%B3%95/01.%E7%AE%97%E6%B3%95%E6%89%93%E5%8D%A1/01.Day01-%E6%95%B0%E7%BB%84.html",
      "relativePath": "02.算法/01.算法打卡/01.Day01-数组.md",
      "key": "v-6f10ee50",
      "path": "/pages/8aab7b/",
      "headers": [
        {
          "level": 2,
          "title": "704.二分查找",
          "slug": "_704-二分查找",
          "normalizedTitle": "704. 二分查找",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "录前想法",
          "slug": "录前想法",
          "normalizedTitle": "录前想法",
          "charIndex": 92
        },
        {
          "level": 3,
          "title": "录后想法",
          "slug": "录后想法",
          "normalizedTitle": "录后想法",
          "charIndex": 1265
        },
        {
          "level": 3,
          "title": "困难点",
          "slug": "困难点",
          "normalizedTitle": "困难点",
          "charIndex": 1428
        },
        {
          "level": 2,
          "title": "27. 移除元素",
          "slug": "_27-移除元素",
          "normalizedTitle": "27. 移除元素",
          "charIndex": 12
        },
        {
          "level": 3,
          "title": "录前想法",
          "slug": "录前想法-2",
          "normalizedTitle": "录前想法",
          "charIndex": 92
        },
        {
          "level": 3,
          "title": "录后想法",
          "slug": "录后想法-2",
          "normalizedTitle": "录后想法",
          "charIndex": 1265
        },
        {
          "level": 3,
          "title": "困难点",
          "slug": "困难点-2",
          "normalizedTitle": "困难点",
          "charIndex": 1428
        },
        {
          "level": 2,
          "title": "拓展",
          "slug": "拓展",
          "normalizedTitle": "拓展",
          "charIndex": 4067
        },
        {
          "level": 3,
          "title": "35.搜索插入位置",
          "slug": "_35-搜索插入位置",
          "normalizedTitle": "35. 搜索插入位置",
          "charIndex": 4074
        },
        {
          "level": 3,
          "title": "34. 在排序数组中查找元素的第一个和最后一个位置",
          "slug": "_34-在排序数组中查找元素的第一个和最后一个位置",
          "normalizedTitle": "34. 在排序数组中查找元素的第一个和最后一个位置",
          "charIndex": 4089
        },
        {
          "level": 2,
          "title": "总结",
          "slug": "总结",
          "normalizedTitle": "总结",
          "charIndex": 4119
        }
      ],
      "excerpt": "<blockquote>\n<p>704. 二分查找、27. 移除元素</p>\n</blockquote>\n",
      "lastUpdated": "5/25/2023, 1:19:01 AM",
      "lastUpdatedTimestamp": 1684948741000,
      "headersStr": "704.二分查找 录前想法 录后想法 困难点 27. 移除元素 录前想法 录后想法 困难点 拓展 35.搜索插入位置 34. 在排序数组中查找元素的第一个和最后一个位置 总结",
      "content": "> 704. 二分查找、27. 移除元素\n\n\n# 704. 二分查找\n\n * 题目：704. 二分查找\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：熟悉左闭右开，左闭右闭\n\n\n# 录前想法\n\n * 首先二分查找的前置条件是已排序。\n\n * 其次为什么会有左闭右开与左开右闭的区分，我认为是奇数个数除 2 后偏左与偏右的问题\n\n * 😢不明白为什么 mid = l + (r - l) >> 1 会超时？\n   \n   * 因为少了括号【 ((r - l) >> 1) 】\n\n> 左闭右开\n\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int l = 0,r = nums.size(),mid = 0;\n\n        while( l < r){\n            mid = l + (r - l) / 2;\n            //mid = l + ((r - l) >> 1);\n            if (nums[mid] > target){\n                r = mid;\n            }else if(nums[mid] < target){\n                l = mid + 1;\n            }else{\n                return mid;\n            }\n        }\n        return -1;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n> 左闭右闭\n\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int l = 0,r = nums.size()-1,mid = 0;\n\n        while( l <= r ){\n            mid = l + (r - l) / 2;\n            //mid = l + ((r - l) >> 1);\n            if (nums[mid] > target){\n                r = mid - 1;\n            }else if(nums[mid] < target){\n                l = mid + 1;\n            }else{\n                return mid;\n            }\n        }\n        return -1;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 录后想法\n\n 1. 对右开和右闭理解的更深刻了，我是这么理解的\n    \n    1. 右闭说明取得到 right, 如果 mid 取不到，则 right = mid - 1\n    2. 右开说明取不到 right, 如果 mid 取不到，则 right = mid\n\n 2. 时间复杂度，写完一个算法要表明复杂度\n\n\n# 困难点\n\n> 为什么 mid = l + (r - l) >> 1 会超时，而 mid = l + (r - l) / 2 不会？\n\n因为，mid = l + (r - l) >> 1 需要加上括号： mid = l + ((r - l) >> 1)\n\n\n# 27. 移除元素\n\n * 题目：27. 移除元素\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：先暴力后双指针\n\n\n# 录前想法\n\n暴力解法，移动元素，问题卡在出现重复元素时，一直会留着一个元素，以下是我的代码（错误代码❌）\n\nclass Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        int size = nums.size();\n\n        for (int i = 0;i < size;++i){\n            if (nums[i] == val){\n                for (int j = i;j < size - 1;++j){\n                    nums[j] = nums[j+1];\n                }\n                --size;\n            }\n        }\n        return size;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 录后想法\n\n 1. 暴力解法\n\n看过讲解后发先是让 i 直接前进了，没有考虑到覆盖上来的元素可能是待删除的值，(正确代码✅)\n\nclass Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        int size = nums.size();\n\n        for (int i = 0;i < size;++i){\n            if (nums[i] == val){\n                for (int j = i;j < size - 1;++j){\n                    nums[j] = nums[j+1];\n                }\n                --size;\n                --i;\n            }\n        }\n\n        return size;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n * 时间复杂度：O (n^2)\n * 空间复杂度：O (1)\n\n 2. 双指针\n\n双指针法（快慢指针法）： 通过一个快指针和慢指针在一个 for 循环下完成两个 for 循环的工作。\n\n定义快慢指针\n\n * 快指针：用于更新\n * 慢指针：被更新\n\nclass Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        int size = nums.size();\n        int slow = 0;\n\n        for (int fast = 0; fast < size; ++fast){\n            // 这个 != 可以写的这么简洁！\n            if (nums[fast] != val){\n               nums[slow++] = nums[fast];\n            }\n        }\n\n        return slow;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n * 时间复杂度：O (n)\n * 空间复杂度：O (1)\n\n 3. 相向双指针方法\n\n基于元素顺序可以改变的题目描述改变了元素相对位置，确保了移动最少元素。\n\n操作如下：\n\n * 找左边等于 val 的元素\n * 找右边不等于 val 的元素\n * 将右边不等于 val 的元素覆盖左边等于 val 的元素\n\nclass Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        int size = nums.size();\n        int right = size - 1,left = 0;\n\n        while(left <= right){\n            // 找左边等于val的元素\n            while(left <= right && nums[left] != val){ \n                ++left; \n            }\n            // 找右边不等于val的元素\n            while(left <= right && nums[right] == val){\n                --right;\n            }\n            // 将右边不等于val的元素覆盖左边等于val的元素\n            if(left <= right){\n                nums[left++] = nums[right--];\n            }\n       }\n\n       return left; // nums[left++],刚好指向了下一个元素，下标 = 元素个数\n        \t\t\t// right指向上一个元素，需要+1\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 困难点\n\n 1. 暴力移动元素时考虑不完善，没有考虑到挨着的重复元素，直接 ++i 跳过了。\n 2. 双指针中！= 写法很简洁，没有想到\n\n\n# 拓展\n\n\n# 35. 搜索插入位置\n\n\n# 34. 在排序数组中查找元素的第一个和最后一个位置\n\n\n# 总结\n\n 1. 数组的元素是不能删的，只能覆盖。\n 2. 细节考虑不周。",
      "normalizedContent": "> 704. 二分查找、27. 移除元素\n\n\n# 704. 二分查找\n\n * 题目：704. 二分查找\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：熟悉左闭右开，左闭右闭\n\n\n# 录前想法\n\n * 首先二分查找的前置条件是已排序。\n\n * 其次为什么会有左闭右开与左开右闭的区分，我认为是奇数个数除 2 后偏左与偏右的问题\n\n * 😢不明白为什么 mid = l + (r - l) >> 1 会超时？\n   \n   * 因为少了括号【 ((r - l) >> 1) 】\n\n> 左闭右开\n\nclass solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int l = 0,r = nums.size(),mid = 0;\n\n        while( l < r){\n            mid = l + (r - l) / 2;\n            //mid = l + ((r - l) >> 1);\n            if (nums[mid] > target){\n                r = mid;\n            }else if(nums[mid] < target){\n                l = mid + 1;\n            }else{\n                return mid;\n            }\n        }\n        return -1;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n> 左闭右闭\n\nclass solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int l = 0,r = nums.size()-1,mid = 0;\n\n        while( l <= r ){\n            mid = l + (r - l) / 2;\n            //mid = l + ((r - l) >> 1);\n            if (nums[mid] > target){\n                r = mid - 1;\n            }else if(nums[mid] < target){\n                l = mid + 1;\n            }else{\n                return mid;\n            }\n        }\n        return -1;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 录后想法\n\n 1. 对右开和右闭理解的更深刻了，我是这么理解的\n    \n    1. 右闭说明取得到 right, 如果 mid 取不到，则 right = mid - 1\n    2. 右开说明取不到 right, 如果 mid 取不到，则 right = mid\n\n 2. 时间复杂度，写完一个算法要表明复杂度\n\n\n# 困难点\n\n> 为什么 mid = l + (r - l) >> 1 会超时，而 mid = l + (r - l) / 2 不会？\n\n因为，mid = l + (r - l) >> 1 需要加上括号： mid = l + ((r - l) >> 1)\n\n\n# 27. 移除元素\n\n * 题目：27. 移除元素\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：先暴力后双指针\n\n\n# 录前想法\n\n暴力解法，移动元素，问题卡在出现重复元素时，一直会留着一个元素，以下是我的代码（错误代码❌）\n\nclass solution {\npublic:\n    int removeelement(vector<int>& nums, int val) {\n        int size = nums.size();\n\n        for (int i = 0;i < size;++i){\n            if (nums[i] == val){\n                for (int j = i;j < size - 1;++j){\n                    nums[j] = nums[j+1];\n                }\n                --size;\n            }\n        }\n        return size;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 录后想法\n\n 1. 暴力解法\n\n看过讲解后发先是让 i 直接前进了，没有考虑到覆盖上来的元素可能是待删除的值，(正确代码✅)\n\nclass solution {\npublic:\n    int removeelement(vector<int>& nums, int val) {\n        int size = nums.size();\n\n        for (int i = 0;i < size;++i){\n            if (nums[i] == val){\n                for (int j = i;j < size - 1;++j){\n                    nums[j] = nums[j+1];\n                }\n                --size;\n                --i;\n            }\n        }\n\n        return size;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n * 时间复杂度：o (n^2)\n * 空间复杂度：o (1)\n\n 2. 双指针\n\n双指针法（快慢指针法）： 通过一个快指针和慢指针在一个 for 循环下完成两个 for 循环的工作。\n\n定义快慢指针\n\n * 快指针：用于更新\n * 慢指针：被更新\n\nclass solution {\npublic:\n    int removeelement(vector<int>& nums, int val) {\n        int size = nums.size();\n        int slow = 0;\n\n        for (int fast = 0; fast < size; ++fast){\n            // 这个 != 可以写的这么简洁！\n            if (nums[fast] != val){\n               nums[slow++] = nums[fast];\n            }\n        }\n\n        return slow;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n * 时间复杂度：o (n)\n * 空间复杂度：o (1)\n\n 3. 相向双指针方法\n\n基于元素顺序可以改变的题目描述改变了元素相对位置，确保了移动最少元素。\n\n操作如下：\n\n * 找左边等于 val 的元素\n * 找右边不等于 val 的元素\n * 将右边不等于 val 的元素覆盖左边等于 val 的元素\n\nclass solution {\npublic:\n    int removeelement(vector<int>& nums, int val) {\n        int size = nums.size();\n        int right = size - 1,left = 0;\n\n        while(left <= right){\n            // 找左边等于val的元素\n            while(left <= right && nums[left] != val){ \n                ++left; \n            }\n            // 找右边不等于val的元素\n            while(left <= right && nums[right] == val){\n                --right;\n            }\n            // 将右边不等于val的元素覆盖左边等于val的元素\n            if(left <= right){\n                nums[left++] = nums[right--];\n            }\n       }\n\n       return left; // nums[left++],刚好指向了下一个元素，下标 = 元素个数\n        \t\t\t// right指向上一个元素，需要+1\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 困难点\n\n 1. 暴力移动元素时考虑不完善，没有考虑到挨着的重复元素，直接 ++i 跳过了。\n 2. 双指针中！= 写法很简洁，没有想到\n\n\n# 拓展\n\n\n# 35. 搜索插入位置\n\n\n# 34. 在排序数组中查找元素的第一个和最后一个位置\n\n\n# 总结\n\n 1. 数组的元素是不能删的，只能覆盖。\n 2. 细节考虑不周。",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "Day02-数组",
      "frontmatter": {
        "title": "Day02-数组",
        "date": "2023-05-25T01:28:41.000Z",
        "permalink": "/pages/f2d3aa/",
        "categories": [
          "算法",
          "算法打卡"
        ],
        "tags": [
          "打卡"
        ]
      },
      "regularPath": "/02.%E7%AE%97%E6%B3%95/01.%E7%AE%97%E6%B3%95%E6%89%93%E5%8D%A1/02.Day02-%E6%95%B0%E7%BB%84.html",
      "relativePath": "02.算法/01.算法打卡/02.Day02-数组.md",
      "key": "v-21be97d0",
      "path": "/pages/f2d3aa/",
      "headers": [
        {
          "level": 2,
          "title": "977.有序数组的平方",
          "slug": "_977-有序数组的平方",
          "normalizedTitle": "977. 有序数组的平方",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "录前想法",
          "slug": "录前想法",
          "normalizedTitle": "录前想法",
          "charIndex": 120
        },
        {
          "level": 3,
          "title": "录后想法",
          "slug": "录后想法",
          "normalizedTitle": "录后想法",
          "charIndex": 1382
        },
        {
          "level": 3,
          "title": "困难点",
          "slug": "困难点",
          "normalizedTitle": "困难点",
          "charIndex": 2110
        },
        {
          "level": 2,
          "title": "209.长度最小的子数组",
          "slug": "_209-长度最小的子数组",
          "normalizedTitle": "209. 长度最小的子数组",
          "charIndex": 16
        },
        {
          "level": 3,
          "title": "录前想法",
          "slug": "录前想法-2",
          "normalizedTitle": "录前想法",
          "charIndex": 120
        },
        {
          "level": 3,
          "title": "录后想法",
          "slug": "录后想法-2",
          "normalizedTitle": "录后想法",
          "charIndex": 1382
        },
        {
          "level": 3,
          "title": "困难点",
          "slug": "困难点-2",
          "normalizedTitle": "困难点",
          "charIndex": 2110
        },
        {
          "level": 2,
          "title": "59.螺旋矩阵II",
          "slug": "_59-螺旋矩阵ii",
          "normalizedTitle": "59. 螺旋矩阵 ii",
          "charIndex": 31
        },
        {
          "level": 3,
          "title": "录前想法",
          "slug": "录前想法-3",
          "normalizedTitle": "录前想法",
          "charIndex": 120
        },
        {
          "level": 3,
          "title": "录后想法",
          "slug": "录后想法-3",
          "normalizedTitle": "录后想法",
          "charIndex": 1382
        },
        {
          "level": 3,
          "title": "困难点",
          "slug": "困难点-3",
          "normalizedTitle": "困难点",
          "charIndex": 2110
        },
        {
          "level": 2,
          "title": "总结",
          "slug": "总结",
          "normalizedTitle": "总结",
          "charIndex": 44
        }
      ],
      "excerpt": "<blockquote>\n<p>977. 有序数组的平方 、209. 长度最小的子数组 、59. 螺旋矩阵 II 、总结</p>\n</blockquote>\n",
      "lastUpdated": "6/2/2023, 6:34:00 PM",
      "lastUpdatedTimestamp": 1685702040000,
      "headersStr": "977.有序数组的平方 录前想法 录后想法 困难点 209.长度最小的子数组 录前想法 录后想法 困难点 59.螺旋矩阵II 录前想法 录后想法 困难点 总结",
      "content": "> 977. 有序数组的平方 、209. 长度最小的子数组 、59. 螺旋矩阵 II 、总结\n\n\n# 977. 有序数组的平方\n\n * 题目：977. 有序数组的平方\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：理解双指针思想\n\n\n# 录前想法\n\n我的思路是用双指针，找到负数的最大值，正数的最小值，然后交换，不额外申请新的空间【未实现❌】\n\n类似冒牌排序，将大的元素冒泡上去。\n\nclass Solution {\npublic:\n    vector<int> sortedSquares(vector<int>& nums) {\n        int fast = 0,slow = 0;\n        int size = nums.size();\n        int tmp = 0;\n\n        if (nums[fast] >= 0){\n            return plus(nums,size);\n        }else{\n            // 找到第一个正数，包括0\n            while(nums[fast] < 0){++fast;}\n        }\n\n        for(;fast < size,slow > 0;){\n            // -4 -1 0 3 10\n            // -4  0 1 3 10 \n            // 0   4 1 3 10\n            // 0   1 4 3 10\n            // 0   1 3 4 10\n            // 平方\n            if(nums[fast] < -nums[slow]){\n                tmp = nums[fast];\n                nums[fast] = -nums[slow];\n                nums[slow] = tmp;\n                --slow;\n            }else{\n                tmp = nums[fast];\n                nums[fast] = -nums[slow];\n                nums[slow] = tmp;\n            }\n        }\n\n        return plus(nums,size);\n    }\n\n    vector<int> plus(vector<int>& nums,int size){\n\n        for(int i = 0;i < size;++i){\n            nums[i] = nums[i]*nums[i];\n        }\n\n        return nums;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n# 录后想法\n\n看完卡哥的题解后发现自己写的有点画蛇添足，冒泡不如暴力自带的排序时间复杂度低😥\n\n发现随想录里的双指针是用了额外空间的，下次练习要先考虑 AC 再考虑优化。\n\n\n\nclass Solution {\npublic:\n    vector<int> sortedSquares(vector<int>& nums) {\n       \n       int size = nums.size();\n       // 额外空间\n       vector<int> ans(size,0);\n       // 指向最大元素\n       int p = size - 1;\n\n       for(int left = 0,right = p;left <= right;){\n           if(nums[left]*nums[left] < nums[right]*nums[right]){\n               ans[p--] = nums[right]*nums[right];\n               --right;\n           }else{\n                ans[p--] = nums[left]*nums[left];\n                ++left;\n           }\n       }\n\n       return ans;\n    }\n\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n * 时间复杂度：O (n)\n * 空间复杂度：O (n)\n\n\n# 困难点\n\n * 想不到双指针的移动\n\n\n# 209. 长度最小的子数组\n\n * 题目：209. 长度最小的子数组\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：理解滑动窗口\n\n\n# 录前想法\n\n我的思路：先排序然后从小到大不断缩小范围找到最小子数组\n\nclass Solution {\npublic:\n    int minSubArrayLen(int target, vector<int>& nums) {\n\n        int size = nums.size();\n        \n        // 排序\n        sort(nums.begin(), nums.end());\n\n        // 双指针\n        int ans = size + 1,sum = 0;\n\n        for (int left = 0,right = 0; right < nums.size(); ++right){\n            sum += nums[right]; \n            while(sum >= target){\n                ans = min(right - left + 1,ans);\n                sum -= nums[left++];\n            }\n        }\n\n        if (ans == size + 1){\n            return 0;\n        }else{\n            return ans;\n        }\n        \n    }\n\n    int min(int a,int b){\n        return a > b ? b : a;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n * 时间复杂度：O (n)\n * 空间复杂度：O (1)\n\n没有通过，卡在了第 17 个测试用例\n\n213\n[12,28,83,4,25,26,25,2,25,25,25,12]\n// 正确 8\n// 我的 7\n\n\n1\n2\n3\n4\n\n\n经过排查，发现是因为排序导致了顺序出错了，不能排序\n\n将 sort 注释即通过\n\n\n# 录后想法\n\n和卡哥的思路相同，在写法有不同，主要是在三目运算。\n\n修改后代码如下\n\nclass Solution {\npublic:\n    int minSubArrayLen(int target, vector<int>& nums) {\n\n        int size = nums.size();\n        int ans = size + 1,sum = 0,tmpSub = 0;\n\n        // 双指针\n        for (int left = 0,right = 0; right < nums.size(); ++right){\n            sum += nums[right]; \n            while(sum >= target){\n                // 窗口内元素\n                tmpSub = right - left + 1;\n                ans = tmpSub > ans ? ans : tmpSub;\n                sum -= nums[left++];\n            }\n        }\n\n        return ans == size + 1 ? 0 : ans;        \n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n * 时间复杂度：O (n)\n * 空间复杂度：O (1)\n\n\n# 困难点\n\n * 顺序是否可以被打乱（排序）\n\n\n# 59. 螺旋矩阵 II\n\n * 题目：59. 螺旋矩阵 II\n * 讲解：文章讲解、视频讲解\n * 要求：转圈的逻辑和区间定义\n\n\n# 录前想法\n\n分为四部，然后通过判断需要循环的圈数为 n/2 ，直接 AC\n\nclass Solution {\npublic:\n    vector<vector<int>> generateMatrix(int n) {\n        // 定义结果集\n        vector<vector<int>> ans(n, vector<int>(n, 0));\n        int left = 0, up = 0,sum = 1;\n\n        for(int j = 0; j <= n/2; j++){\n            // 左 -> 右\n            for(int i = left; i < n - left; ++i ){\n                ans[left][i] = sum++;\n            }\n            ++left;\n\n            // 上 -> 下\n            for(int i = up + 1; i < n - up; ++i ){\n                ans[i][n - up - 1] = sum++;\n            }\n            ++up;\n\n            // 右 -> 左\n            for(int i = n - left - 1; i >= left - 1; --i){\n                ans[n - left][i] = sum++;\n            }\n\n            // 下 -> 上\n            for(int i = n - up - 1; i >= up; --i){\n                ans[i][up - 1] = sum++;\n            }\n        }\n\n        return ans;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n * 时间复杂度 O (n^2)\n * 空间复杂度 O (1)\n\n\n# 录后想法\n\n和卡哥思路差不多🆗\n\n\n# 困难点\n\n * 需要仔细判断从哪开始到哪结束\n\n\n# 总结\n\n 1. 先考虑完成题目\n 2. 双指针需要灵活使用，不能死板\n 3. 注意条件中顺序是否能被打乱（排序）",
      "normalizedContent": "> 977. 有序数组的平方 、209. 长度最小的子数组 、59. 螺旋矩阵 ii 、总结\n\n\n# 977. 有序数组的平方\n\n * 题目：977. 有序数组的平方\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：理解双指针思想\n\n\n# 录前想法\n\n我的思路是用双指针，找到负数的最大值，正数的最小值，然后交换，不额外申请新的空间【未实现❌】\n\n类似冒牌排序，将大的元素冒泡上去。\n\nclass solution {\npublic:\n    vector<int> sortedsquares(vector<int>& nums) {\n        int fast = 0,slow = 0;\n        int size = nums.size();\n        int tmp = 0;\n\n        if (nums[fast] >= 0){\n            return plus(nums,size);\n        }else{\n            // 找到第一个正数，包括0\n            while(nums[fast] < 0){++fast;}\n        }\n\n        for(;fast < size,slow > 0;){\n            // -4 -1 0 3 10\n            // -4  0 1 3 10 \n            // 0   4 1 3 10\n            // 0   1 4 3 10\n            // 0   1 3 4 10\n            // 平方\n            if(nums[fast] < -nums[slow]){\n                tmp = nums[fast];\n                nums[fast] = -nums[slow];\n                nums[slow] = tmp;\n                --slow;\n            }else{\n                tmp = nums[fast];\n                nums[fast] = -nums[slow];\n                nums[slow] = tmp;\n            }\n        }\n\n        return plus(nums,size);\n    }\n\n    vector<int> plus(vector<int>& nums,int size){\n\n        for(int i = 0;i < size;++i){\n            nums[i] = nums[i]*nums[i];\n        }\n\n        return nums;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n# 录后想法\n\n看完卡哥的题解后发现自己写的有点画蛇添足，冒泡不如暴力自带的排序时间复杂度低😥\n\n发现随想录里的双指针是用了额外空间的，下次练习要先考虑 ac 再考虑优化。\n\n\n\nclass solution {\npublic:\n    vector<int> sortedsquares(vector<int>& nums) {\n       \n       int size = nums.size();\n       // 额外空间\n       vector<int> ans(size,0);\n       // 指向最大元素\n       int p = size - 1;\n\n       for(int left = 0,right = p;left <= right;){\n           if(nums[left]*nums[left] < nums[right]*nums[right]){\n               ans[p--] = nums[right]*nums[right];\n               --right;\n           }else{\n                ans[p--] = nums[left]*nums[left];\n                ++left;\n           }\n       }\n\n       return ans;\n    }\n\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n * 时间复杂度：o (n)\n * 空间复杂度：o (n)\n\n\n# 困难点\n\n * 想不到双指针的移动\n\n\n# 209. 长度最小的子数组\n\n * 题目：209. 长度最小的子数组\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：理解滑动窗口\n\n\n# 录前想法\n\n我的思路：先排序然后从小到大不断缩小范围找到最小子数组\n\nclass solution {\npublic:\n    int minsubarraylen(int target, vector<int>& nums) {\n\n        int size = nums.size();\n        \n        // 排序\n        sort(nums.begin(), nums.end());\n\n        // 双指针\n        int ans = size + 1,sum = 0;\n\n        for (int left = 0,right = 0; right < nums.size(); ++right){\n            sum += nums[right]; \n            while(sum >= target){\n                ans = min(right - left + 1,ans);\n                sum -= nums[left++];\n            }\n        }\n\n        if (ans == size + 1){\n            return 0;\n        }else{\n            return ans;\n        }\n        \n    }\n\n    int min(int a,int b){\n        return a > b ? b : a;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n * 时间复杂度：o (n)\n * 空间复杂度：o (1)\n\n没有通过，卡在了第 17 个测试用例\n\n213\n[12,28,83,4,25,26,25,2,25,25,25,12]\n// 正确 8\n// 我的 7\n\n\n1\n2\n3\n4\n\n\n经过排查，发现是因为排序导致了顺序出错了，不能排序\n\n将 sort 注释即通过\n\n\n# 录后想法\n\n和卡哥的思路相同，在写法有不同，主要是在三目运算。\n\n修改后代码如下\n\nclass solution {\npublic:\n    int minsubarraylen(int target, vector<int>& nums) {\n\n        int size = nums.size();\n        int ans = size + 1,sum = 0,tmpsub = 0;\n\n        // 双指针\n        for (int left = 0,right = 0; right < nums.size(); ++right){\n            sum += nums[right]; \n            while(sum >= target){\n                // 窗口内元素\n                tmpsub = right - left + 1;\n                ans = tmpsub > ans ? ans : tmpsub;\n                sum -= nums[left++];\n            }\n        }\n\n        return ans == size + 1 ? 0 : ans;        \n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n * 时间复杂度：o (n)\n * 空间复杂度：o (1)\n\n\n# 困难点\n\n * 顺序是否可以被打乱（排序）\n\n\n# 59. 螺旋矩阵 ii\n\n * 题目：59. 螺旋矩阵 ii\n * 讲解：文章讲解、视频讲解\n * 要求：转圈的逻辑和区间定义\n\n\n# 录前想法\n\n分为四部，然后通过判断需要循环的圈数为 n/2 ，直接 ac\n\nclass solution {\npublic:\n    vector<vector<int>> generatematrix(int n) {\n        // 定义结果集\n        vector<vector<int>> ans(n, vector<int>(n, 0));\n        int left = 0, up = 0,sum = 1;\n\n        for(int j = 0; j <= n/2; j++){\n            // 左 -> 右\n            for(int i = left; i < n - left; ++i ){\n                ans[left][i] = sum++;\n            }\n            ++left;\n\n            // 上 -> 下\n            for(int i = up + 1; i < n - up; ++i ){\n                ans[i][n - up - 1] = sum++;\n            }\n            ++up;\n\n            // 右 -> 左\n            for(int i = n - left - 1; i >= left - 1; --i){\n                ans[n - left][i] = sum++;\n            }\n\n            // 下 -> 上\n            for(int i = n - up - 1; i >= up; --i){\n                ans[i][up - 1] = sum++;\n            }\n        }\n\n        return ans;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n * 时间复杂度 o (n^2)\n * 空间复杂度 o (1)\n\n\n# 录后想法\n\n和卡哥思路差不多🆗\n\n\n# 困难点\n\n * 需要仔细判断从哪开始到哪结束\n\n\n# 总结\n\n 1. 先考虑完成题目\n 2. 双指针需要灵活使用，不能死板\n 3. 注意条件中顺序是否能被打乱（排序）",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "结构体和内存对齐",
      "frontmatter": {
        "title": "结构体和内存对齐",
        "date": "2023-06-02T18:31:22.000Z",
        "permalink": "/pages/20d234/",
        "categories": [
          "Go",
          "深入Go"
        ],
        "tags": [
          "探索-GO"
        ]
      },
      "regularPath": "/01.Go/03.%E6%B7%B1%E5%85%A5Go/03.%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90.html",
      "relativePath": "01.Go/03.深入Go/03.结构体和内存对齐.md",
      "key": "v-2bf5c5b2",
      "path": "/pages/20d234/",
      "lastUpdated": "6/2/2023, 6:34:00 PM",
      "lastUpdatedTimestamp": 1685702040000,
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {}
    },
    {
      "title": "Day03-链表",
      "frontmatter": {
        "title": "Day03-链表",
        "date": "2023-05-26T00:55:34.000Z",
        "permalink": "/pages/2c5009/",
        "categories": [
          "算法",
          "算法打卡"
        ],
        "tags": [
          "打卡"
        ]
      },
      "regularPath": "/02.%E7%AE%97%E6%B3%95/01.%E7%AE%97%E6%B3%95%E6%89%93%E5%8D%A1/03.Day03-%E9%93%BE%E8%A1%A8.html",
      "relativePath": "02.算法/01.算法打卡/03.Day03-链表.md",
      "key": "v-c042b388",
      "path": "/pages/2c5009/",
      "headers": [
        {
          "level": 2,
          "title": "链表理论基础",
          "slug": "链表理论基础",
          "normalizedTitle": "链表理论基础",
          "charIndex": 51
        },
        {
          "level": 2,
          "title": "203.移除链表元素",
          "slug": "_203-移除链表元素",
          "normalizedTitle": "203. 移除链表元素",
          "charIndex": 98
        },
        {
          "level": 3,
          "title": "录前想法",
          "slug": "录前想法",
          "normalizedTitle": "录前想法",
          "charIndex": 166
        },
        {
          "level": 3,
          "title": "录后想法",
          "slug": "录后想法",
          "normalizedTitle": "录后想法",
          "charIndex": 852
        },
        {
          "level": 3,
          "title": "总结",
          "slug": "总结",
          "normalizedTitle": "总结",
          "charIndex": 44
        },
        {
          "level": 2,
          "title": "707.设计链表",
          "slug": "_707-设计链表",
          "normalizedTitle": "707. 设计链表",
          "charIndex": 1609
        },
        {
          "level": 3,
          "title": "录前想法",
          "slug": "录前想法-2",
          "normalizedTitle": "录前想法",
          "charIndex": 166
        },
        {
          "level": 3,
          "title": "录后想法",
          "slug": "录后想法-2",
          "normalizedTitle": "录后想法",
          "charIndex": 852
        },
        {
          "level": 3,
          "title": "总结",
          "slug": "总结-2",
          "normalizedTitle": "总结",
          "charIndex": 44
        },
        {
          "level": 2,
          "title": "206.反转链表",
          "slug": "_206-反转链表",
          "normalizedTitle": "206. 反转链表",
          "charIndex": 6752
        },
        {
          "level": 3,
          "title": "录前想法",
          "slug": "录前想法-3",
          "normalizedTitle": "录前想法",
          "charIndex": 166
        },
        {
          "level": 3,
          "title": "录后想法",
          "slug": "录后想法-3",
          "normalizedTitle": "录后想法",
          "charIndex": 852
        },
        {
          "level": 3,
          "title": "总结",
          "slug": "总结-3",
          "normalizedTitle": "总结",
          "charIndex": 44
        },
        {
          "level": 2,
          "title": "总结",
          "slug": "总结-4",
          "normalizedTitle": "总结",
          "charIndex": 44
        }
      ],
      "excerpt": "<blockquote>\n<p>977. 有序数组的平方 、209. 长度最小的子数组 、59. 螺旋矩阵 II 、总结</p>\n</blockquote>\n",
      "lastUpdated": "6/2/2023, 6:34:00 PM",
      "lastUpdatedTimestamp": 1685702040000,
      "headersStr": "链表理论基础 203.移除链表元素 录前想法 录后想法 总结 707.设计链表 录前想法 录后想法 总结 206.反转链表 录前想法 录后想法 总结 总结",
      "content": "> 977. 有序数组的平方 、209. 长度最小的子数组 、59. 螺旋矩阵 II 、总结\n\n\n# 链表理论基础\n\n * 讲解：文章讲解\n * 要求：了解链接基础，以及链表和数组的区别\n\n\n# 203. 移除链表元素\n\n * 题目：203. 移除链表元素\n * 讲解：文章讲解、视频讲解\n * 要求：虚拟头结点的使用技巧\n\n\n# 录前想法\n\n我想的是判断空，通过虚拟头节点比对下一个节点来删除元素（未通过❌）\n\nclass Solution {\npublic:\n    ListNode* removeElements(ListNode* head, int val) {\n\n        // 判断空\n        if (head == NULL){\n            return head;\n        }\n\n        // 虚拟头节点\n        ListNode* newHead = new ListNode(0);\n        newHead->next = head;\n        // 操作指针\n        ListNode* cur = newHead;\n\n        while(cur->next != NULL){\n            if(cur->next->val == val){\n                cur->next = cur->next->next;\n            }\n            cur = cur->next;\n        } \n\n        return newHead->next;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n错在空指针，\n\n在删除节点后，如果下一个节点也需要被删除，那么当前指针 cur 应该保持不变，以便检查下一个节点\n\n\n# 录后想法\n\n看过卡哥思路后发现\n\n 1. 做了删除节点判断\n 2. 内存管理（销毁删除节点内存）\n\nclass Solution {\npublic:\n    ListNode* removeElements(ListNode* head, int val) {\n\n        // 判断空\n        if (head == NULL){\n            return head;\n        }\n\n        // 虚拟头节点\n        ListNode* newHead = new ListNode(0);\n        newHead->next = head;\n        // 操作指针\n        ListNode* cur = newHead;\n\n        while(cur->next != NULL){\n            if(cur->next->val == val){\n                ListNode* tmp = cur->next;\n                cur->next = cur->next->next;\n                delete tmp; // 销毁内存\n            }else{\n                cur = cur->next;\n            }  \n        } \n\n        return newHead->next;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 总结\n\n\n# 707. 设计链表\n\n * 题目：707. 设计链表\n * 讲解：文章讲解、视频讲解\n * 要求：掌握链表综合操作\n\n\n# 录前想法\n\n坎坎坷坷的，没有写出来，不知道从何下手\n\n看了一眼卡哥的代码，发现要自己定义结构体，自己写构造函数😓\n\n下面是第一次提交的错误代码（❌）\n\nclass MyLinkedList {\npublic:\n    // 定义链表节点结构体\n    struct LinkedNode {\n        int val;\n        LinkedNode* next;\n        LinkedNode(int val):val(val), next(nullptr){}\n    };\n\n    MyLinkedList() {\n        head = new LinkedNode(0);\n        size = 0;\n    }\n\n    int get(int index) {\n        // index表示下标从0开始\n        if(index > size - 1 || index < 0){\n            return -1;\n        }\n\n        LinkedNode* cur = head->next;\n        while(index--){\n            cur = cur->next;\n        }\n        return cur->val;\n    }\n    \n    void addAtHead(int val) {\n        LinkedNode* node = new LinkedNode(val);\n        node->next = head->next;\n        head->next = node;\n        ++size;\n    }\n    \n    void addAtTail(int val) {\n        LinkedNode* node = new LinkedNode(val);\n        LinkedNode* cur = head->next;\n        while(cur->next){\n            cur = cur->next;\n        }\n        cur->next = node;\n        ++size;\n    }\n    \n    void addAtIndex(int index, int val) {\n        // index表示下标从0开始\n        if(index > size){\n            return;\n        }\n        if(index < 0){\n            addAtHead(val);\n            return;\n        }\n\n        LinkedNode* cur = head;\n        while(index--){\n            cur = cur->next;\n        }\n\n        // 1->2\n        LinkedNode* node = new LinkedNode(val);\n        // 2->3\n        node->next = cur->next;\n        // 1->2->3\n        cur->next = node;\n        size++;\n    }\n    \n    void deleteAtIndex(int index) {\n        // index表示下标从0开始\n        if(index >= size - 1 || index < 0){return;}\n\n        // 获取待删除元素的前一个元素\n        LinkedNode* cur = head;\n        while(index--){\n            cur = cur->next;\n        }\n\n        LinkedNode* tmp = cur->next;\n        cur->next = cur->next->next;\n        delete tmp;\n        tmp = nullptr;\n\n        size--;\n    }\nprivate:\n    int size;\n    LinkedNode* head;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n\n\n经过调试喝排查，发现\n\nint get(int index) {\n    // index表示下标从0开始\n    if(index > (size - 1) || index < 0){ // 应该要加上括号！！！\n        return -1;\n    }\n\n    ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nvoid deleteAtIndex(int index) {\n    // index表示下标从0开始\n    if(index >= (size - 1) || index < 0){return;} // 应该要加上括号！！！\n\n    ...\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 录后想法\n\n一些内存管理还不熟，比如删除元素时 tmp 的处理，只单纯的 delete，没有置为空。\n\n    // 删除第index个节点，如果index 大于等于链表的长度，直接return，注意index是从0开始的\n    void deleteAtIndex(int index) {\n        ...\n        delete tmp;\n        //delete命令指示释放了tmp指针原本所指的那部分内存，\n        //被delete后的指针tmp的值（地址）并非就是NULL，而是随机值。也就是被delete后，\n        //如果不再加上一句tmp=nullptr,tmp会成为乱指的野指针\n        //如果之后的程序不小心使用了tmp，会指向难以预想的内存空间\n        tmp=nullptr;\n        _size--;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n以下是后面结合卡哥讲解后的代码（✅）\n\nclass MyLinkedList {\npublic:\n    // 定义链表节点结构体\n    struct LinkedNode {\n        int val;\n        LinkedNode* next;\n        LinkedNode(int val):val(val), next(nullptr){}\n    };\n\n    MyLinkedList() {\n        head = new LinkedNode(0);\n        size = 0;\n    }\n\n    int get(int index) {\n        // index表示下标从0开始\n        if(index > (size - 1) || index < 0){\n            return -1;\n        }\n\n        LinkedNode* cur = head->next;\n        while(index--){\n            cur = cur->next;\n        }\n        return cur->val;\n    }\n    \n    void addAtHead(int val) {\n        LinkedNode* node = new LinkedNode(val);\n        node->next = head->next;\n        head->next = node;\n        ++size;\n    }\n    \n    void addAtTail(int val) {\n        LinkedNode* node = new LinkedNode(val);\n        LinkedNode* cur = head;\n        while(cur->next){\n            cur = cur->next;\n        }\n        cur->next = node;\n        ++size;\n    }\n    \n    void addAtIndex(int index, int val) {\n        // index表示下标从0开始\n        if(index > size){\n            return;\n        }\n        if(index < 0){\n            index = 0;\n        }\n\n        LinkedNode* cur = head;\n        while(index--){\n            cur = cur->next;\n        }\n\n        // 1->2\n        LinkedNode* node = new LinkedNode(val);\n        // 2->3\n        node->next = cur->next;\n        // 1->2->3\n        cur->next = node;\n        size++;\n    }\n    \n    void deleteAtIndex(int index) {\n        // index表示下标从0开始\n        if(index > (size - 1) || index < 0){return;}\n\n        // 获取待删除元素的前一个元素\n        LinkedNode* cur = head;\n        while(index--){\n            cur = cur->next;\n        }\n\n        LinkedNode* tmp = cur->next;\n        cur->next = cur->next->next;\n        delete tmp;\n        tmp = nullptr;\n\n        size--;\n    }\nprivate:\n    int size;\n    LinkedNode* head;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n\n\n\n# 总结\n\n 1. 判断元素越界时，若要做运算要加上括号\n 2. 虚拟头节点很方便\n    1. 可以找到元素的前一个节点，方便删除和插入\n    2. 可以直接到指定元素结点\n\n\n# 206. 反转链表\n\n * 题目：206. 反转链表\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：双指针应用\n\n\n# 录前想法\n\n双指针反转，全部后指前，下面代码（❌）\n\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n\n        // 虚拟头节点\n        ListNode* newHead = new ListNode(0);\n        newHead->next = head;\n\n        ListNode* pre = newHead;\n        ListNode* cur = newHead->next;\n        while(cur && cur->next){\n            ListNode* tmp = cur->next;\n            cur->next = pre;\n            pre = cur;\n            cur = tmp; \n        }\n\n        return newHead->next;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n经过调试检查后发现以下几点错误：\n\n 1. 虚拟头节点多余\n 2. pre 初始值不正确\n 3. 返回值错误\n\n\n# 录后想法\n\n>  1. 双指针\n\n看过卡哥的讲解后，优化了上面的代码（✅）\n\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n\n        ListNode* pre = NULL;\n        ListNode* cur = head;\n        ListNode* tmp;\n\n        while(cur){\n            tmp = cur->next;\n            cur->next = pre;\n            pre = cur;\n            cur = tmp; \n        }\n\n        return pre;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n * 时间复杂度：O（n）\n * 空间复杂度：O（1）\n\n>  2. 递归\n\n核心思路没变，利用递归巧妙的对应了双指针 while 循环。\n\nclass Solution {\npublic:\n    ListNode* reverse(ListNode* pre,ListNode* cur) {\n\n        // 对应双指针的return pre;\n        if(cur == NULL){return pre;}\n        \n        ListNode* tmp = cur->next;\n        cur->next = pre;\n        \n        // 巧妙的对应\n        // pre = cur;\n        // cur = tmp;\n        return reverse(cur,tmp);\n\n    }\n\n    ListNode* reverseList(ListNode* head) {\n\n        return reverse(NULL,head);\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n * 时间复杂度: O (n)\n * 空间复杂度: O (n)\n\n\n# 总结\n\n * 反转：后 -> 前\n\n\n# 总结\n\n这次写的时间比较久，在中间设计链表部分卡的时间长，看似链表的那些基础操作容易，自己上手写大大小小的错误就出来了。\n\n容易错的点：\n\n 1. 忘记删除完元素要 delete，且置为空\n 2. 是否需要虚拟头节点？",
      "normalizedContent": "> 977. 有序数组的平方 、209. 长度最小的子数组 、59. 螺旋矩阵 ii 、总结\n\n\n# 链表理论基础\n\n * 讲解：文章讲解\n * 要求：了解链接基础，以及链表和数组的区别\n\n\n# 203. 移除链表元素\n\n * 题目：203. 移除链表元素\n * 讲解：文章讲解、视频讲解\n * 要求：虚拟头结点的使用技巧\n\n\n# 录前想法\n\n我想的是判断空，通过虚拟头节点比对下一个节点来删除元素（未通过❌）\n\nclass solution {\npublic:\n    listnode* removeelements(listnode* head, int val) {\n\n        // 判断空\n        if (head == null){\n            return head;\n        }\n\n        // 虚拟头节点\n        listnode* newhead = new listnode(0);\n        newhead->next = head;\n        // 操作指针\n        listnode* cur = newhead;\n\n        while(cur->next != null){\n            if(cur->next->val == val){\n                cur->next = cur->next->next;\n            }\n            cur = cur->next;\n        } \n\n        return newhead->next;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n错在空指针，\n\n在删除节点后，如果下一个节点也需要被删除，那么当前指针 cur 应该保持不变，以便检查下一个节点\n\n\n# 录后想法\n\n看过卡哥思路后发现\n\n 1. 做了删除节点判断\n 2. 内存管理（销毁删除节点内存）\n\nclass solution {\npublic:\n    listnode* removeelements(listnode* head, int val) {\n\n        // 判断空\n        if (head == null){\n            return head;\n        }\n\n        // 虚拟头节点\n        listnode* newhead = new listnode(0);\n        newhead->next = head;\n        // 操作指针\n        listnode* cur = newhead;\n\n        while(cur->next != null){\n            if(cur->next->val == val){\n                listnode* tmp = cur->next;\n                cur->next = cur->next->next;\n                delete tmp; // 销毁内存\n            }else{\n                cur = cur->next;\n            }  \n        } \n\n        return newhead->next;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 总结\n\n\n# 707. 设计链表\n\n * 题目：707. 设计链表\n * 讲解：文章讲解、视频讲解\n * 要求：掌握链表综合操作\n\n\n# 录前想法\n\n坎坎坷坷的，没有写出来，不知道从何下手\n\n看了一眼卡哥的代码，发现要自己定义结构体，自己写构造函数😓\n\n下面是第一次提交的错误代码（❌）\n\nclass mylinkedlist {\npublic:\n    // 定义链表节点结构体\n    struct linkednode {\n        int val;\n        linkednode* next;\n        linkednode(int val):val(val), next(nullptr){}\n    };\n\n    mylinkedlist() {\n        head = new linkednode(0);\n        size = 0;\n    }\n\n    int get(int index) {\n        // index表示下标从0开始\n        if(index > size - 1 || index < 0){\n            return -1;\n        }\n\n        linkednode* cur = head->next;\n        while(index--){\n            cur = cur->next;\n        }\n        return cur->val;\n    }\n    \n    void addathead(int val) {\n        linkednode* node = new linkednode(val);\n        node->next = head->next;\n        head->next = node;\n        ++size;\n    }\n    \n    void addattail(int val) {\n        linkednode* node = new linkednode(val);\n        linkednode* cur = head->next;\n        while(cur->next){\n            cur = cur->next;\n        }\n        cur->next = node;\n        ++size;\n    }\n    \n    void addatindex(int index, int val) {\n        // index表示下标从0开始\n        if(index > size){\n            return;\n        }\n        if(index < 0){\n            addathead(val);\n            return;\n        }\n\n        linkednode* cur = head;\n        while(index--){\n            cur = cur->next;\n        }\n\n        // 1->2\n        linkednode* node = new linkednode(val);\n        // 2->3\n        node->next = cur->next;\n        // 1->2->3\n        cur->next = node;\n        size++;\n    }\n    \n    void deleteatindex(int index) {\n        // index表示下标从0开始\n        if(index >= size - 1 || index < 0){return;}\n\n        // 获取待删除元素的前一个元素\n        linkednode* cur = head;\n        while(index--){\n            cur = cur->next;\n        }\n\n        linkednode* tmp = cur->next;\n        cur->next = cur->next->next;\n        delete tmp;\n        tmp = nullptr;\n\n        size--;\n    }\nprivate:\n    int size;\n    linkednode* head;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n\n\n经过调试喝排查，发现\n\nint get(int index) {\n    // index表示下标从0开始\n    if(index > (size - 1) || index < 0){ // 应该要加上括号！！！\n        return -1;\n    }\n\n    ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nvoid deleteatindex(int index) {\n    // index表示下标从0开始\n    if(index >= (size - 1) || index < 0){return;} // 应该要加上括号！！！\n\n    ...\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 录后想法\n\n一些内存管理还不熟，比如删除元素时 tmp 的处理，只单纯的 delete，没有置为空。\n\n    // 删除第index个节点，如果index 大于等于链表的长度，直接return，注意index是从0开始的\n    void deleteatindex(int index) {\n        ...\n        delete tmp;\n        //delete命令指示释放了tmp指针原本所指的那部分内存，\n        //被delete后的指针tmp的值（地址）并非就是null，而是随机值。也就是被delete后，\n        //如果不再加上一句tmp=nullptr,tmp会成为乱指的野指针\n        //如果之后的程序不小心使用了tmp，会指向难以预想的内存空间\n        tmp=nullptr;\n        _size--;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n以下是后面结合卡哥讲解后的代码（✅）\n\nclass mylinkedlist {\npublic:\n    // 定义链表节点结构体\n    struct linkednode {\n        int val;\n        linkednode* next;\n        linkednode(int val):val(val), next(nullptr){}\n    };\n\n    mylinkedlist() {\n        head = new linkednode(0);\n        size = 0;\n    }\n\n    int get(int index) {\n        // index表示下标从0开始\n        if(index > (size - 1) || index < 0){\n            return -1;\n        }\n\n        linkednode* cur = head->next;\n        while(index--){\n            cur = cur->next;\n        }\n        return cur->val;\n    }\n    \n    void addathead(int val) {\n        linkednode* node = new linkednode(val);\n        node->next = head->next;\n        head->next = node;\n        ++size;\n    }\n    \n    void addattail(int val) {\n        linkednode* node = new linkednode(val);\n        linkednode* cur = head;\n        while(cur->next){\n            cur = cur->next;\n        }\n        cur->next = node;\n        ++size;\n    }\n    \n    void addatindex(int index, int val) {\n        // index表示下标从0开始\n        if(index > size){\n            return;\n        }\n        if(index < 0){\n            index = 0;\n        }\n\n        linkednode* cur = head;\n        while(index--){\n            cur = cur->next;\n        }\n\n        // 1->2\n        linkednode* node = new linkednode(val);\n        // 2->3\n        node->next = cur->next;\n        // 1->2->3\n        cur->next = node;\n        size++;\n    }\n    \n    void deleteatindex(int index) {\n        // index表示下标从0开始\n        if(index > (size - 1) || index < 0){return;}\n\n        // 获取待删除元素的前一个元素\n        linkednode* cur = head;\n        while(index--){\n            cur = cur->next;\n        }\n\n        linkednode* tmp = cur->next;\n        cur->next = cur->next->next;\n        delete tmp;\n        tmp = nullptr;\n\n        size--;\n    }\nprivate:\n    int size;\n    linkednode* head;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n\n\n\n# 总结\n\n 1. 判断元素越界时，若要做运算要加上括号\n 2. 虚拟头节点很方便\n    1. 可以找到元素的前一个节点，方便删除和插入\n    2. 可以直接到指定元素结点\n\n\n# 206. 反转链表\n\n * 题目：206. 反转链表\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：双指针应用\n\n\n# 录前想法\n\n双指针反转，全部后指前，下面代码（❌）\n\nclass solution {\npublic:\n    listnode* reverselist(listnode* head) {\n\n        // 虚拟头节点\n        listnode* newhead = new listnode(0);\n        newhead->next = head;\n\n        listnode* pre = newhead;\n        listnode* cur = newhead->next;\n        while(cur && cur->next){\n            listnode* tmp = cur->next;\n            cur->next = pre;\n            pre = cur;\n            cur = tmp; \n        }\n\n        return newhead->next;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n经过调试检查后发现以下几点错误：\n\n 1. 虚拟头节点多余\n 2. pre 初始值不正确\n 3. 返回值错误\n\n\n# 录后想法\n\n>  1. 双指针\n\n看过卡哥的讲解后，优化了上面的代码（✅）\n\nclass solution {\npublic:\n    listnode* reverselist(listnode* head) {\n\n        listnode* pre = null;\n        listnode* cur = head;\n        listnode* tmp;\n\n        while(cur){\n            tmp = cur->next;\n            cur->next = pre;\n            pre = cur;\n            cur = tmp; \n        }\n\n        return pre;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n * 时间复杂度：o（n）\n * 空间复杂度：o（1）\n\n>  2. 递归\n\n核心思路没变，利用递归巧妙的对应了双指针 while 循环。\n\nclass solution {\npublic:\n    listnode* reverse(listnode* pre,listnode* cur) {\n\n        // 对应双指针的return pre;\n        if(cur == null){return pre;}\n        \n        listnode* tmp = cur->next;\n        cur->next = pre;\n        \n        // 巧妙的对应\n        // pre = cur;\n        // cur = tmp;\n        return reverse(cur,tmp);\n\n    }\n\n    listnode* reverselist(listnode* head) {\n\n        return reverse(null,head);\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n * 时间复杂度: o (n)\n * 空间复杂度: o (n)\n\n\n# 总结\n\n * 反转：后 -> 前\n\n\n# 总结\n\n这次写的时间比较久，在中间设计链表部分卡的时间长，看似链表的那些基础操作容易，自己上手写大大小小的错误就出来了。\n\n容易错的点：\n\n 1. 忘记删除完元素要 delete，且置为空\n 2. 是否需要虚拟头节点？",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "Day04-链表",
      "frontmatter": {
        "title": "Day04-链表",
        "date": "2023-05-27T00:19:58.000Z",
        "permalink": "/pages/115af7/",
        "categories": [
          "算法",
          "算法打卡"
        ],
        "tags": [
          "打卡"
        ]
      },
      "regularPath": "/02.%E7%AE%97%E6%B3%95/01.%E7%AE%97%E6%B3%95%E6%89%93%E5%8D%A1/04.Day04-%E9%93%BE%E8%A1%A8.html",
      "relativePath": "02.算法/01.算法打卡/04.Day04-链表.md",
      "key": "v-72f05d08",
      "path": "/pages/115af7/",
      "headers": [
        {
          "level": 2,
          "title": "24. 两两交换链表中的节点",
          "slug": "_24-两两交换链表中的节点",
          "normalizedTitle": "24. 两两交换链表中的节点",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "录前想法",
          "slug": "录前想法",
          "normalizedTitle": "录前想法",
          "charIndex": 141
        },
        {
          "level": 3,
          "title": "录后想法",
          "slug": "录后想法",
          "normalizedTitle": "录后想法",
          "charIndex": 1883
        },
        {
          "level": 3,
          "title": "总结",
          "slug": "总结",
          "normalizedTitle": "总结",
          "charIndex": 965
        },
        {
          "level": 2,
          "title": "19.删除链表的倒数第N个节点",
          "slug": "_19-删除链表的倒数第n个节点",
          "normalizedTitle": "19. 删除链表的倒数第 n 个节点",
          "charIndex": 17
        },
        {
          "level": 3,
          "title": "录前想法",
          "slug": "录前想法-2",
          "normalizedTitle": "录前想法",
          "charIndex": 141
        },
        {
          "level": 3,
          "title": "录后想法",
          "slug": "录后想法-2",
          "normalizedTitle": "录后想法",
          "charIndex": 1883
        },
        {
          "level": 3,
          "title": "总结",
          "slug": "总结-2",
          "normalizedTitle": "总结",
          "charIndex": 965
        },
        {
          "level": 2,
          "title": "面试题 02.07. 链表相交",
          "slug": "面试题-02-07-链表相交",
          "normalizedTitle": "面试题 02.07. 链表相交",
          "charIndex": 37
        },
        {
          "level": 3,
          "title": "录前想法",
          "slug": "录前想法-3",
          "normalizedTitle": "录前想法",
          "charIndex": 141
        },
        {
          "level": 3,
          "title": "录后想法",
          "slug": "录后想法-3",
          "normalizedTitle": "录后想法",
          "charIndex": 1883
        },
        {
          "level": 3,
          "title": "总结",
          "slug": "总结-3",
          "normalizedTitle": "总结",
          "charIndex": 965
        },
        {
          "level": 2,
          "title": "142.环形链表II",
          "slug": "_142-环形链表ii",
          "normalizedTitle": "142. 环形链表 ii",
          "charIndex": 53
        },
        {
          "level": 3,
          "title": "录前想法",
          "slug": "录前想法-4",
          "normalizedTitle": "录前想法",
          "charIndex": 141
        },
        {
          "level": 3,
          "title": "录后想法",
          "slug": "录后想法-4",
          "normalizedTitle": "录后想法",
          "charIndex": 1883
        },
        {
          "level": 3,
          "title": "总结",
          "slug": "总结-4",
          "normalizedTitle": "总结",
          "charIndex": 965
        },
        {
          "level": 2,
          "title": "总结",
          "slug": "总结-5",
          "normalizedTitle": "总结",
          "charIndex": 965
        }
      ],
      "excerpt": "<blockquote>\n<p>24. 两两交换链表中的节点、19. 删除链表的倒数第 N 个节点 、面试题 02.07. 链表相交、142. 环形链表 II</p>\n</blockquote>\n",
      "lastUpdated": "6/2/2023, 6:34:00 PM",
      "lastUpdatedTimestamp": 1685702040000,
      "headersStr": "24. 两两交换链表中的节点 录前想法 录后想法 总结 19.删除链表的倒数第N个节点 录前想法 录后想法 总结 面试题 02.07. 链表相交 录前想法 录后想法 总结 142.环形链表II 录前想法 录后想法 总结 总结",
      "content": "> 24. 两两交换链表中的节点、19. 删除链表的倒数第 N 个节点 、面试题 02.07. 链表相交、142. 环形链表 II\n\n\n# 24. 两两交换链表中的节点\n\n * 题目：24. 两两交换链表中的节点\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：虚拟头结点\n\n\n# 录前想法\n\n开始时的思路：\n\npre -> 1 -> 2 -> 3 -> 4\n\n 1. 1 -> 3\n\n 2. 2 -> 1\n\n 3. pre -> 2\n\npre -> 2 -> 1 -> 3 -> 4\n\n以下代码未通过 (❌)\n\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n\n        // 虚拟头节点\n        ListNode* newHead = new ListNode(0);\n        newHead->next = head;\n\n        // 双指针\n        ListNode* pre = newHead;\n        ListNode* cur = newHead->next;\n        ListNode* tmp = cur->next;\n\n        while(cur->next){\n    \n            // 1 -> 3\n            cur->next = cur->next->next;\n            // 2 -> 1\n            tmp->next = cur;\n            // pre -> 2\n            pre->next = tmp;\n\n            pre = cur;\n            tmp = cur->next;\n            cur = tmp->next;\n        }\n\n        return newHead->next;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n经过一段时间的调试总结了以下问题：\n\n 1. 如果一开始就使用 cur -> next 需要考虑空的情况\n 2. 循环时要先定值、后变值，不然循环的条件就失效了\n\n以下代码已 AC (✔️)\n\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n\n        if(!head){return head;}\n\n        // 虚拟头节点\n        ListNode* newHead = new ListNode(0);\n        newHead->next = head;\n\n        // 双指针\n        ListNode* pre = newHead;\n        ListNode* cur = newHead->next;\n        // 需要判断空\n        ListNode* tmp = cur->next;\n\n        // 循环判断，先定值，后变值，不然无法判断\n        while(pre->next && pre->next->next){\n\n            cur = pre->next;\n            tmp = cur->next;\n    \n            // 1 -> 3\n            cur->next = cur->next->next;\n            // 2 -> 1\n            tmp->next = cur;\n            // pre -> 2\n            pre->next = tmp;\n\n            pre = pre->next->next;\n        }\n\n        return newHead->next;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 录后想法\n\n看了卡哥的思路后，可以再进行优化：\n\n 1. 一开始的赋值操作可以放入循环中\n 2. 统一的 pre 指针使用观感上舒服很多\n\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n\n        // 虚拟头节点\n        ListNode *newHead = new ListNode(0);\n        newHead->next = head;\n\n        // 双指针\n        ListNode *pre = newHead;\n        ListNode *tmp1,*tmp2;\n\n        while(pre->next && pre->next->next){\n            \n            tmp1 = pre->next;\n            tmp2 = pre->next->next->next;\n\n            pre->next = pre->next->next;\n            pre->next->next = tmp1;\n            pre->next->next->next = tmp2;\n            \n            pre = pre->next->next;\n\n        }\n\n        return newHead->next;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 总结\n\n其实没有那么死板，重在理解交换的步骤顺序\n\n\n\n\n# 19. 删除链表的倒数第 N 个节点\n\n * 题目：19. 删除链表的倒数第 N 个节点\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：双指针的操作（删除第 N 个节点，要指向 第 N 个节点的前一个节点）\n\n\n# 录前想法\n\n双指针隔 n+1 个元素前进，直接 AC (✔️)\n\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n\n        // 虚拟头节点\n        ListNode *newHead = new ListNode(0);\n        newHead->next = head;\n        // 快慢指针\n        ListNode *slow = newHead;\n        ListNode *fast = newHead;\n        // 间隔\n        while(n--){\n            fast = fast->next;\n        }\n        // 同时移动\n        while(fast->next){\n            fast = fast->next;\n            slow = slow->next;\n        }\n\n        slow->next = slow->next->next;\n\n        return newHead->next; \n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n * 时间复杂度: O (n)\n * 空间复杂度: O (1)\n\n\n# 录后想法\n\n和卡哥思路一致✌️\n\n\n# 总结\n\n无\n\n\n# 面试题 02.07. 链表相交\n\n * 题目：面试题 02.07. 链表相交\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：注意数值相同，不代表指针相同\n\n\n# 录前想法\n\n 1. 分别计算出链表 A 和 B 的长度\n\n 2. 移动长链表\n\n 3. 同时移动\n\n 4. 返回相同或空\n\n以下代码，已 AC (✔️)\n\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        \n        // 1.分别计算出链表A和B的长度\n        int sizeA = 0,sizeB = 0;\n        ListNode *tmpA = headA;\n        ListNode *tmpB = headB;\n        while(tmpA){\n            tmpA = tmpA->next;\n            ++sizeA;\n        }\n        while(tmpB){\n            tmpB = tmpB->next;\n            ++sizeB;\n        }\n\n        // 2. 移动长链表\n        tmpA = headA;\n        tmpB = headB;\n\n        if (sizeA > sizeB){\n            for(int i = sizeA - sizeB;i > 0;--i){\n                tmpA = tmpA->next;\n            }\n        }else{\n            for(int i = sizeB - sizeA;i > 0;--i){\n                tmpB = tmpB->next;\n            }\n        }\n\n        // 3. 同时移动\n        while(tmpB && tmpA){\n            if(tmpB == tmpA){\n                return tmpA;\n            }\n\n            tmpA = tmpA->next;\n            tmpB = tmpB->next;\n        }\n\n        // 4. 返回空\n        return NULL;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n * 时间复杂度: O (n)\n * 空间复杂度: O (1)\n\n\n# 录后想法\n\n思路与卡哥一致，写法上参考后有改进的地方：\n\n * 在循环上可以控制一个，交换另一个\n\n// 原代码\nif (sizeA > sizeB){\n\tfor(int i = sizeA - sizeB;i > 0;--i){\n\t\ttmpA = tmpA->next;\n\t}\n}else{\n\tfor(int i = sizeB - sizeA;i > 0;--i){\n\t\ttmpB = tmpB->next;\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n// 改进后\nif (sizeA < sizeB){\n    swap(sizeA,sizeB);\n    swap(tmpA,tmpB);\n}\n\nfor(int i = sizeA - sizeB;i > 0;--i){\n    tmpA = tmpA->next;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 总结\n\n * 循环的写法可以控制一个修改另一个\n\n\n# 142. 环形链表 II\n\n * 题目：142. 环形链表 II\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：确定环和找环入口\n\n\n# 录前想法\n\n 1. 快慢指针找到环\n 2. 慢指针回原位，同时和快指针往前走，相遇点就是入口（之前写过，记得结论）\n\n以下代码，超时了，估计是哪里死循环了（❌）\n\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n\n        if(!head){return head;}\n\n        // 虚拟头节点\n        ListNode *newHead = new ListNode(0);\n        newHead->next = head;\n        // 快慢指针\n        ListNode *fast = newHead;\n        ListNode *slow = newHead;\n        // 找到相遇点\n        while(fast->next && fast->next->next){\n            \n            // 先赋值\n            fast = fast->next->next;\n            slow = slow->next;\n\n            if(fast == slow){\n                // slow归原位\n                slow = newHead->next;\n                // 共同前进\n                while(fast != slow){\n                    fast = fast->next;\n                    slow = slow->next;\n                }\n                return fast;\n            }\n        }\n\n        return NULL;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n暂时没有找到错在哪，去看看卡哥的讲解。\n\n\n# 录后想法\n\n经过比对发现，思路是一致的，不同的地方在虚拟头节点的使用，删除虚拟头节点后就 AC (✔️)\n\n// 改进后\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n\n        if(!head){return head;}\n\n        // 快慢指针\n        ListNode *fast = head;\n        ListNode *slow = head;\n        \n        // 找到相遇点\n        while(fast && fast->next){\n            \n            // 先赋值\n            fast = fast->next->next;\n            slow = slow->next;\n\n            if(slow == fast){\n\n                fast =  head;\n                if(!fast){return nullptr;}\n\n                while(fast != slow){\n                    fast = fast->next;\n                    slow = slow->next;\n                }\n\n                return fast;\n            }\n\n        }\n\n        return nullptr;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# 总结\n\n * 虚拟头节点不能乱用，哪些情况下需要使用虚拟头节点呢？\n\n\n# 总结\n\n 1. 虚拟头节点是否该使用？\n 2. 双指针\n    1. 快慢指针（一个每次都走的比另一个快）\n    2. 滑动窗口",
      "normalizedContent": "> 24. 两两交换链表中的节点、19. 删除链表的倒数第 n 个节点 、面试题 02.07. 链表相交、142. 环形链表 ii\n\n\n# 24. 两两交换链表中的节点\n\n * 题目：24. 两两交换链表中的节点\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：虚拟头结点\n\n\n# 录前想法\n\n开始时的思路：\n\npre -> 1 -> 2 -> 3 -> 4\n\n 1. 1 -> 3\n\n 2. 2 -> 1\n\n 3. pre -> 2\n\npre -> 2 -> 1 -> 3 -> 4\n\n以下代码未通过 (❌)\n\nclass solution {\npublic:\n    listnode* swappairs(listnode* head) {\n\n        // 虚拟头节点\n        listnode* newhead = new listnode(0);\n        newhead->next = head;\n\n        // 双指针\n        listnode* pre = newhead;\n        listnode* cur = newhead->next;\n        listnode* tmp = cur->next;\n\n        while(cur->next){\n    \n            // 1 -> 3\n            cur->next = cur->next->next;\n            // 2 -> 1\n            tmp->next = cur;\n            // pre -> 2\n            pre->next = tmp;\n\n            pre = cur;\n            tmp = cur->next;\n            cur = tmp->next;\n        }\n\n        return newhead->next;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n经过一段时间的调试总结了以下问题：\n\n 1. 如果一开始就使用 cur -> next 需要考虑空的情况\n 2. 循环时要先定值、后变值，不然循环的条件就失效了\n\n以下代码已 ac (✔️)\n\nclass solution {\npublic:\n    listnode* swappairs(listnode* head) {\n\n        if(!head){return head;}\n\n        // 虚拟头节点\n        listnode* newhead = new listnode(0);\n        newhead->next = head;\n\n        // 双指针\n        listnode* pre = newhead;\n        listnode* cur = newhead->next;\n        // 需要判断空\n        listnode* tmp = cur->next;\n\n        // 循环判断，先定值，后变值，不然无法判断\n        while(pre->next && pre->next->next){\n\n            cur = pre->next;\n            tmp = cur->next;\n    \n            // 1 -> 3\n            cur->next = cur->next->next;\n            // 2 -> 1\n            tmp->next = cur;\n            // pre -> 2\n            pre->next = tmp;\n\n            pre = pre->next->next;\n        }\n\n        return newhead->next;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 录后想法\n\n看了卡哥的思路后，可以再进行优化：\n\n 1. 一开始的赋值操作可以放入循环中\n 2. 统一的 pre 指针使用观感上舒服很多\n\nclass solution {\npublic:\n    listnode* swappairs(listnode* head) {\n\n        // 虚拟头节点\n        listnode *newhead = new listnode(0);\n        newhead->next = head;\n\n        // 双指针\n        listnode *pre = newhead;\n        listnode *tmp1,*tmp2;\n\n        while(pre->next && pre->next->next){\n            \n            tmp1 = pre->next;\n            tmp2 = pre->next->next->next;\n\n            pre->next = pre->next->next;\n            pre->next->next = tmp1;\n            pre->next->next->next = tmp2;\n            \n            pre = pre->next->next;\n\n        }\n\n        return newhead->next;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 总结\n\n其实没有那么死板，重在理解交换的步骤顺序\n\n\n\n\n# 19. 删除链表的倒数第 n 个节点\n\n * 题目：19. 删除链表的倒数第 n 个节点\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：双指针的操作（删除第 n 个节点，要指向 第 n 个节点的前一个节点）\n\n\n# 录前想法\n\n双指针隔 n+1 个元素前进，直接 ac (✔️)\n\nclass solution {\npublic:\n    listnode* removenthfromend(listnode* head, int n) {\n\n        // 虚拟头节点\n        listnode *newhead = new listnode(0);\n        newhead->next = head;\n        // 快慢指针\n        listnode *slow = newhead;\n        listnode *fast = newhead;\n        // 间隔\n        while(n--){\n            fast = fast->next;\n        }\n        // 同时移动\n        while(fast->next){\n            fast = fast->next;\n            slow = slow->next;\n        }\n\n        slow->next = slow->next->next;\n\n        return newhead->next; \n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n * 时间复杂度: o (n)\n * 空间复杂度: o (1)\n\n\n# 录后想法\n\n和卡哥思路一致✌️\n\n\n# 总结\n\n无\n\n\n# 面试题 02.07. 链表相交\n\n * 题目：面试题 02.07. 链表相交\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：注意数值相同，不代表指针相同\n\n\n# 录前想法\n\n 1. 分别计算出链表 a 和 b 的长度\n\n 2. 移动长链表\n\n 3. 同时移动\n\n 4. 返回相同或空\n\n以下代码，已 ac (✔️)\n\nclass solution {\npublic:\n    listnode *getintersectionnode(listnode *heada, listnode *headb) {\n        \n        // 1.分别计算出链表a和b的长度\n        int sizea = 0,sizeb = 0;\n        listnode *tmpa = heada;\n        listnode *tmpb = headb;\n        while(tmpa){\n            tmpa = tmpa->next;\n            ++sizea;\n        }\n        while(tmpb){\n            tmpb = tmpb->next;\n            ++sizeb;\n        }\n\n        // 2. 移动长链表\n        tmpa = heada;\n        tmpb = headb;\n\n        if (sizea > sizeb){\n            for(int i = sizea - sizeb;i > 0;--i){\n                tmpa = tmpa->next;\n            }\n        }else{\n            for(int i = sizeb - sizea;i > 0;--i){\n                tmpb = tmpb->next;\n            }\n        }\n\n        // 3. 同时移动\n        while(tmpb && tmpa){\n            if(tmpb == tmpa){\n                return tmpa;\n            }\n\n            tmpa = tmpa->next;\n            tmpb = tmpb->next;\n        }\n\n        // 4. 返回空\n        return null;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n * 时间复杂度: o (n)\n * 空间复杂度: o (1)\n\n\n# 录后想法\n\n思路与卡哥一致，写法上参考后有改进的地方：\n\n * 在循环上可以控制一个，交换另一个\n\n// 原代码\nif (sizea > sizeb){\n\tfor(int i = sizea - sizeb;i > 0;--i){\n\t\ttmpa = tmpa->next;\n\t}\n}else{\n\tfor(int i = sizeb - sizea;i > 0;--i){\n\t\ttmpb = tmpb->next;\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n// 改进后\nif (sizea < sizeb){\n    swap(sizea,sizeb);\n    swap(tmpa,tmpb);\n}\n\nfor(int i = sizea - sizeb;i > 0;--i){\n    tmpa = tmpa->next;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 总结\n\n * 循环的写法可以控制一个修改另一个\n\n\n# 142. 环形链表 ii\n\n * 题目：142. 环形链表 ii\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：确定环和找环入口\n\n\n# 录前想法\n\n 1. 快慢指针找到环\n 2. 慢指针回原位，同时和快指针往前走，相遇点就是入口（之前写过，记得结论）\n\n以下代码，超时了，估计是哪里死循环了（❌）\n\nclass solution {\npublic:\n    listnode *detectcycle(listnode *head) {\n\n        if(!head){return head;}\n\n        // 虚拟头节点\n        listnode *newhead = new listnode(0);\n        newhead->next = head;\n        // 快慢指针\n        listnode *fast = newhead;\n        listnode *slow = newhead;\n        // 找到相遇点\n        while(fast->next && fast->next->next){\n            \n            // 先赋值\n            fast = fast->next->next;\n            slow = slow->next;\n\n            if(fast == slow){\n                // slow归原位\n                slow = newhead->next;\n                // 共同前进\n                while(fast != slow){\n                    fast = fast->next;\n                    slow = slow->next;\n                }\n                return fast;\n            }\n        }\n\n        return null;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n暂时没有找到错在哪，去看看卡哥的讲解。\n\n\n# 录后想法\n\n经过比对发现，思路是一致的，不同的地方在虚拟头节点的使用，删除虚拟头节点后就 ac (✔️)\n\n// 改进后\nclass solution {\npublic:\n    listnode *detectcycle(listnode *head) {\n\n        if(!head){return head;}\n\n        // 快慢指针\n        listnode *fast = head;\n        listnode *slow = head;\n        \n        // 找到相遇点\n        while(fast && fast->next){\n            \n            // 先赋值\n            fast = fast->next->next;\n            slow = slow->next;\n\n            if(slow == fast){\n\n                fast =  head;\n                if(!fast){return nullptr;}\n\n                while(fast != slow){\n                    fast = fast->next;\n                    slow = slow->next;\n                }\n\n                return fast;\n            }\n\n        }\n\n        return nullptr;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# 总结\n\n * 虚拟头节点不能乱用，哪些情况下需要使用虚拟头节点呢？\n\n\n# 总结\n\n 1. 虚拟头节点是否该使用？\n 2. 双指针\n    1. 快慢指针（一个每次都走的比另一个快）\n    2. 滑动窗口",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "Day05-哈希",
      "frontmatter": {
        "title": "Day05-哈希",
        "date": "2023-05-29T16:34:30.000Z",
        "permalink": "/pages/311b6b/",
        "categories": [
          "算法",
          "算法打卡"
        ],
        "tags": [
          "打卡"
        ]
      },
      "regularPath": "/02.%E7%AE%97%E6%B3%95/01.%E7%AE%97%E6%B3%95%E6%89%93%E5%8D%A1/05.Day05-%E5%93%88%E5%B8%8C.html",
      "relativePath": "02.算法/01.算法打卡/05.Day05-哈希.md",
      "key": "v-72465a38",
      "path": "/pages/311b6b/",
      "headers": [
        {
          "level": 2,
          "title": "哈希表理论基础",
          "slug": "哈希表理论基础",
          "normalizedTitle": "哈希表理论基础",
          "charIndex": 2
        },
        {
          "level": 2,
          "title": "242.有效的字母异位词",
          "slug": "_242-有效的字母异位词",
          "normalizedTitle": "242. 有效的字母异位词",
          "charIndex": 10
        },
        {
          "level": 3,
          "title": "录前想法",
          "slug": "录前想法",
          "normalizedTitle": "录前想法",
          "charIndex": 920
        },
        {
          "level": 3,
          "title": "录后想法",
          "slug": "录后想法",
          "normalizedTitle": "录后想法",
          "charIndex": 1703
        },
        {
          "level": 3,
          "title": "总结",
          "slug": "总结",
          "normalizedTitle": "总结",
          "charIndex": 128
        },
        {
          "level": 2,
          "title": "349.两个数组的交集",
          "slug": "_349-两个数组的交集",
          "normalizedTitle": "349. 两个数组的交集",
          "charIndex": 24
        },
        {
          "level": 3,
          "title": "录前想法",
          "slug": "录前想法-2",
          "normalizedTitle": "录前想法",
          "charIndex": 920
        },
        {
          "level": 3,
          "title": "录后想法",
          "slug": "录后想法-2",
          "normalizedTitle": "录后想法",
          "charIndex": 1703
        },
        {
          "level": 3,
          "title": "总结",
          "slug": "总结-2",
          "normalizedTitle": "总结",
          "charIndex": 128
        },
        {
          "level": 2,
          "title": "202.快乐数",
          "slug": "_202-快乐数",
          "normalizedTitle": "202. 快乐数",
          "charIndex": 37
        },
        {
          "level": 3,
          "title": "录前想法",
          "slug": "录前想法-3",
          "normalizedTitle": "录前想法",
          "charIndex": 920
        },
        {
          "level": 3,
          "title": "录后想法",
          "slug": "录后想法-3",
          "normalizedTitle": "录后想法",
          "charIndex": 1703
        },
        {
          "level": 3,
          "title": "总结",
          "slug": "总结-3",
          "normalizedTitle": "总结",
          "charIndex": 128
        },
        {
          "level": 2,
          "title": "1.两数之和",
          "slug": "_1-两数之和",
          "normalizedTitle": "1. 两数之和",
          "charIndex": 46
        },
        {
          "level": 3,
          "title": "录前想法",
          "slug": "录前想法-4",
          "normalizedTitle": "录前想法",
          "charIndex": 920
        },
        {
          "level": 3,
          "title": "录后想法",
          "slug": "录后想法-4",
          "normalizedTitle": "录后想法",
          "charIndex": 1703
        },
        {
          "level": 3,
          "title": "总结",
          "slug": "总结-4",
          "normalizedTitle": "总结",
          "charIndex": 128
        },
        {
          "level": 2,
          "title": "总结",
          "slug": "总结-5",
          "normalizedTitle": "总结",
          "charIndex": 128
        }
      ],
      "excerpt": "<blockquote>\n<p>哈希表理论基础、242. 有效的字母异位词、349. 两个数组的交集、202. 快乐数、1. 两数之和</p>\n</blockquote>\n",
      "lastUpdated": "6/2/2023, 6:34:00 PM",
      "lastUpdatedTimestamp": 1685702040000,
      "headersStr": "哈希表理论基础 242.有效的字母异位词 录前想法 录后想法 总结 349.两个数组的交集 录前想法 录后想法 总结 202.快乐数 录前想法 录后想法 总结 1.两数之和 录前想法 录后想法 总结 总结",
      "content": "> 哈希表理论基础、242. 有效的字母异位词、349. 两个数组的交集、202. 快乐数、1. 两数之和\n\n\n# 哈希表理论基础\n\n * 讲解\n\n * 要求：了解哈希表的内部实现原理，哈希函数，哈希碰撞，以及常见哈希表的区别，数组，set 和 map\n\n总结：\n\n 1. 当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法\n 2. 牺牲了空间换取了时间\n\n集合                       底层实现   是否有序   数值是否可以重复   能否更改数值   查询效率       增删效率\nstd::set                 红黑树    有序     否          否        O(log n)   O(log n)\nstd::multiset            红黑树    有序     是          否        O(logn)    O(logn)\nstd::unordered_set(✔️)   哈希表    无序     否          否        O(1)       O(1)\n\n----------------------------------------\n\n映射                   底层实现   是否有序     数值是否可以重复   能否更改数值     查询效率       增删效率\nstd::map             红黑树    key 有序   key 不可重复   key 不可修改   O(logn)    O(logn)\nstd::multimap        红黑树    key 有序   key 可重复    key 不可修改   O(log n)   O(log n)\nstd::unordered_map   哈希表    key 无序   key 不可重复   key 不可修改   O(1)       O(1)\n\n\n# 242. 有效的字母异位词\n\n * 题目：242. 有效的字母异位词\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：数组用来做哈希表\n\n\n# 录前想法\n\n按要求，数组作为哈希表来记录每个字符，s 字符串的字符 ++，t 字符串的字符 --，若最后 tmp 数组中都为 0 则为有效的字母异位词。\n\n以下代码已 AC (✔️)\n\nclass Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        \n        if(s.size() != t.size()){return false;}\n\n        // 初始化数组\n        int tmp[26] = {0};\n\n        // s.size() == t.size()\n        for(int i = 0; i < s.size();++i){\n            // 记录s字符串\n            tmp[s[i] - 'a']++;\n            // 从tmp中删除t字符串字符\n            tmp[t[i] - 'a']--;\n        }\n\n        // 查看tmp是否全为0\n        for(int i = 0; i < 26;++i){\n            cout<<tmp[i]<<endl;\n            if(tmp[i] != 0){\n                return false;\n            }\n        }\n\n        return true;\n \n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n * 时间复杂度: O (n)\n * 空间复杂度: O (1)\n\n\n# 录后想法\n\n思路一致✌️\n\n\n# 总结\n\n无\n\n\n# 349. 两个数组的交集\n\n * 题目：349. 两个数组的交集\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：使用数组和 set 两种解法\n\n\n# 录前想法\n\n> 数组\n\n 1. 定义 set 数据结构，防止结果重复\n 2. 定义 1000 数组\n 3. 记录 nums1 并判断 nums2 是否存在\n 4. 类型转换并返回\n\n已 AC (✔️)\n\nclass Solution {\npublic:\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\n        // 去重结果集\n        unordered_set<int> result;\n\n        // 使用数组\n        int tmp[1000] = {0};\n\n        // 记录nums1\n        for(int i = 0;i < nums1.size();++i){\n            tmp[nums1[i]] = 1;\n        }\n\n        // 判断nums2元素是否存在\n        for(int i = 0;i < nums2.size();++i){\n            if(tmp[nums2[i]] == 1){\n                result.insert(nums2[i]);\n            }\n        }\n\n        return vector<int>(result.begin(), result.end());;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n> set 数据结构\n\n写出来和上面数组差不多，对 SET 数据结构操作不熟练。\n\n\n# 录后想法\n\n主要是迭代器的使用，AC (✔️)\n\nclass Solution {\npublic:\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\n        // 去重结果集\n        unordered_set<int> result;\n        unordered_set<int> tmp(nums1.begin(),nums1.end());\n\n        // 使用SET\n        for(int num : nums2){\n            // tmp.find(num) 未找到则返回tmp.end()\n            if(tmp.find(num) != tmp.end()){\n                result.insert(num);\n            }\n        }\n\n        return vector<int>(result.begin(), result.end());;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 总结\n\n * SET 数据结构的无重复\n * 迭代器的使用\n\n\n# 202. 快乐数\n\n * 题目：202. 快乐数\n\n * 讲解：文章讲解\n\n * 要求：set 的应用\n\n\n# 录前想法\n\n暴力求和判断是否为 1，若出现和为个位数且不为 1 就是 false\n\n下面是代码实现，未通过 (❌)\n\nclass Solution {\npublic:\n    bool isHappy(int n) {\n\n        if(n == 1){return true;}\n\n        // 备份n\n        int tmp;\n        int len = 0,sum = 0,p;\n\n        while(1){\n\n            // 备份n\n            tmp = n;\n            // 初始化、归零\n            len = 0;\n            p = 10;\n            sum = 0;\n\n            // 判断n有几位\n            while(tmp != 0){\n                tmp /= 10;\n                ++len;\n            }\n\n            // 若出现个位则直接返回false\n            if(len == 1){\n                return false;\n            }\n\n            tmp = n;\n\n            // 循环记录平方和\n            while(len--){\n\n                // 取数\n                tmp = n%p;\n                // 记录和\n                sum += tmp * tmp;\n\n                if(len == 1){\n                    tmp = n/p;\n                    sum += tmp * tmp;\n                    break;\n                }\n                \n                p *= 10; \n            }\n\n            // 判断是否为1\n            if(sum == 1){\n                return true;\n            }else{\n                n = sum;\n            }\n        }\n\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n\n\n应该是思路错了，且并没有用上 set\n\n\n# 录后想法\n\n * 会 无限循环，那么也就是说求和的过程中，sum 会重复出现，这对解题很重要！\n\n看了卡哥的讲解后发现是思路错了，不是出现 sum 为个位数时返回 false，而是出现了重复的 sum\n\n根据这个思路可以写出以下代码：AC (✔️)\n\nclass Solution {\npublic:\n    bool isHappy(int n) {\n\n        int sum;\n        unordered_set<int> tmp;\n\n        while(1){\n\n            // 循环记录平方和\n            sum = 0;\n            while(n){\n                // 取个数数并平方和\n                sum += (n%10)*(n%10);\n                // 缩短位数（剔除个位）\n                n /= 10;\n            }\n\n            // 判断是否为1\n            if(sum == 1){\n                return true;\n            }else{\n                n = sum;\n            }\n\n            // sum曾经出现过\n            if(tmp.find(sum) != tmp.end()){\n                return false;\n            }else{\n                tmp.insert(sum);\n            }\n\n        }\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 总结\n\n * 无限循环 = 会重复出现值\n\n * 分解正数的个位数\n   \n   while(n){\n       // 取个数数并平方和\n       sum += (n%10)*(n%10);\n       // 缩短位数（剔除个位）\n       n /= 10;\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n\n# 1. 两数之和\n\n * 题目：1. 两数之和\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：map 解决哈希问题\n\n\n# 录前想法\n\n 1. 可以暴力的循环比对\n 2. 利用相加，使用 MAP 数据结构保存值，快速匹配\n\nMAP 的掌握不熟，下面代码为暴力解法，已 AC (✔️)\n\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        \n       for(int i = 0; i < nums.size();++i){\n            for(int j = i + 1; j < nums.size();++j){\n                if(nums[i]+nums[j] == target){\n                    return {i,j};\n                }\n            }\n       }\n\n        return {};\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 录后想法\n\n思路正确，顺便学习以下 map 用法，AC (✔️)\n\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        \n        // 将nums装入map中\n        std::unordered_map <int,int> map;\n        for(int i = 0; i < nums.size(); ++i){\n            auto iter = map.find(target - nums[i]); \n            if(iter != map.end()){\n                // iter->second 下标\n                // iter->frist  值\n                return {iter->second, i};\n            }\n            map.insert(pair<int, int>(nums[i], i)); \n        }\n\n        return {};\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 总结\n\n * 判断 key 有序无序选择使用 MAP\n\n映射                   底层实现   是否有序     数值是否可以重复   能否更改数值     查询效率       增删效率\nstd::map             红黑树    key 有序   key 不可重复   key 不可修改   O(log n)   O(log n)\nstd::multimap        红黑树    key 有序   key 可重复    key 不可修改   O(log n)   O(log n)\nstd::unordered_map   哈希表    key 无序   key 不可重复   key 不可修改   O(1)       O(1)\n\n\n# 总结\n\n 1. 数组、SET 集合、MAP 的应用\n\n * SET 集合：查元素、保存不重复\n * MAP：查元素，需要下标\n\n集合                       底层实现   是否有序   数值是否可以重复   能否更改数值   查询效率       增删效率\nstd::set                 红黑树    有序     否          否        O(log n)   O(log n)\nstd::multiset            红黑树    有序     是          否        O(logn)    O(logn)\nstd::unordered_set(✔️)   哈希表    无序     否          否        O(1)       O(1)\n\n----------------------------------------\n\n映射                   底层实现   是否有序     数值是否可以重复   能否更改数值     查询效率       增删效率\nstd::map             红黑树    key 有序   key 不可重复   key 不可修改   O(logn)    O(logn)\nstd::multimap        红黑树    key 有序   key 可重复    key 不可修改   O(log n)   O(log n)\nstd::unordered_map   哈希表    key 无序   key 不可重复   key 不可修改   O(1)       O(1)\n\n 2. 迭代器的使用\n\n// 判断元素是否出现过\nif(tmp.find(sum) != tmp.end()){}\n\n\n1\n2\n\n 3. 个位运算\n\nwhile(n){\n\tsum += n%10; // n%10个位\n\tn /= 10;     // 剔除已使用个位\n}\n\n\n1\n2\n3\n4\n",
      "normalizedContent": "> 哈希表理论基础、242. 有效的字母异位词、349. 两个数组的交集、202. 快乐数、1. 两数之和\n\n\n# 哈希表理论基础\n\n * 讲解\n\n * 要求：了解哈希表的内部实现原理，哈希函数，哈希碰撞，以及常见哈希表的区别，数组，set 和 map\n\n总结：\n\n 1. 当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法\n 2. 牺牲了空间换取了时间\n\n集合                       底层实现   是否有序   数值是否可以重复   能否更改数值   查询效率       增删效率\nstd::set                 红黑树    有序     否          否        o(log n)   o(log n)\nstd::multiset            红黑树    有序     是          否        o(logn)    o(logn)\nstd::unordered_set(✔️)   哈希表    无序     否          否        o(1)       o(1)\n\n----------------------------------------\n\n映射                   底层实现   是否有序     数值是否可以重复   能否更改数值     查询效率       增删效率\nstd::map             红黑树    key 有序   key 不可重复   key 不可修改   o(logn)    o(logn)\nstd::multimap        红黑树    key 有序   key 可重复    key 不可修改   o(log n)   o(log n)\nstd::unordered_map   哈希表    key 无序   key 不可重复   key 不可修改   o(1)       o(1)\n\n\n# 242. 有效的字母异位词\n\n * 题目：242. 有效的字母异位词\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：数组用来做哈希表\n\n\n# 录前想法\n\n按要求，数组作为哈希表来记录每个字符，s 字符串的字符 ++，t 字符串的字符 --，若最后 tmp 数组中都为 0 则为有效的字母异位词。\n\n以下代码已 ac (✔️)\n\nclass solution {\npublic:\n    bool isanagram(string s, string t) {\n        \n        if(s.size() != t.size()){return false;}\n\n        // 初始化数组\n        int tmp[26] = {0};\n\n        // s.size() == t.size()\n        for(int i = 0; i < s.size();++i){\n            // 记录s字符串\n            tmp[s[i] - 'a']++;\n            // 从tmp中删除t字符串字符\n            tmp[t[i] - 'a']--;\n        }\n\n        // 查看tmp是否全为0\n        for(int i = 0; i < 26;++i){\n            cout<<tmp[i]<<endl;\n            if(tmp[i] != 0){\n                return false;\n            }\n        }\n\n        return true;\n \n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n * 时间复杂度: o (n)\n * 空间复杂度: o (1)\n\n\n# 录后想法\n\n思路一致✌️\n\n\n# 总结\n\n无\n\n\n# 349. 两个数组的交集\n\n * 题目：349. 两个数组的交集\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：使用数组和 set 两种解法\n\n\n# 录前想法\n\n> 数组\n\n 1. 定义 set 数据结构，防止结果重复\n 2. 定义 1000 数组\n 3. 记录 nums1 并判断 nums2 是否存在\n 4. 类型转换并返回\n\n已 ac (✔️)\n\nclass solution {\npublic:\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\n        // 去重结果集\n        unordered_set<int> result;\n\n        // 使用数组\n        int tmp[1000] = {0};\n\n        // 记录nums1\n        for(int i = 0;i < nums1.size();++i){\n            tmp[nums1[i]] = 1;\n        }\n\n        // 判断nums2元素是否存在\n        for(int i = 0;i < nums2.size();++i){\n            if(tmp[nums2[i]] == 1){\n                result.insert(nums2[i]);\n            }\n        }\n\n        return vector<int>(result.begin(), result.end());;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n> set 数据结构\n\n写出来和上面数组差不多，对 set 数据结构操作不熟练。\n\n\n# 录后想法\n\n主要是迭代器的使用，ac (✔️)\n\nclass solution {\npublic:\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\n        // 去重结果集\n        unordered_set<int> result;\n        unordered_set<int> tmp(nums1.begin(),nums1.end());\n\n        // 使用set\n        for(int num : nums2){\n            // tmp.find(num) 未找到则返回tmp.end()\n            if(tmp.find(num) != tmp.end()){\n                result.insert(num);\n            }\n        }\n\n        return vector<int>(result.begin(), result.end());;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 总结\n\n * set 数据结构的无重复\n * 迭代器的使用\n\n\n# 202. 快乐数\n\n * 题目：202. 快乐数\n\n * 讲解：文章讲解\n\n * 要求：set 的应用\n\n\n# 录前想法\n\n暴力求和判断是否为 1，若出现和为个位数且不为 1 就是 false\n\n下面是代码实现，未通过 (❌)\n\nclass solution {\npublic:\n    bool ishappy(int n) {\n\n        if(n == 1){return true;}\n\n        // 备份n\n        int tmp;\n        int len = 0,sum = 0,p;\n\n        while(1){\n\n            // 备份n\n            tmp = n;\n            // 初始化、归零\n            len = 0;\n            p = 10;\n            sum = 0;\n\n            // 判断n有几位\n            while(tmp != 0){\n                tmp /= 10;\n                ++len;\n            }\n\n            // 若出现个位则直接返回false\n            if(len == 1){\n                return false;\n            }\n\n            tmp = n;\n\n            // 循环记录平方和\n            while(len--){\n\n                // 取数\n                tmp = n%p;\n                // 记录和\n                sum += tmp * tmp;\n\n                if(len == 1){\n                    tmp = n/p;\n                    sum += tmp * tmp;\n                    break;\n                }\n                \n                p *= 10; \n            }\n\n            // 判断是否为1\n            if(sum == 1){\n                return true;\n            }else{\n                n = sum;\n            }\n        }\n\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n\n\n应该是思路错了，且并没有用上 set\n\n\n# 录后想法\n\n * 会 无限循环，那么也就是说求和的过程中，sum 会重复出现，这对解题很重要！\n\n看了卡哥的讲解后发现是思路错了，不是出现 sum 为个位数时返回 false，而是出现了重复的 sum\n\n根据这个思路可以写出以下代码：ac (✔️)\n\nclass solution {\npublic:\n    bool ishappy(int n) {\n\n        int sum;\n        unordered_set<int> tmp;\n\n        while(1){\n\n            // 循环记录平方和\n            sum = 0;\n            while(n){\n                // 取个数数并平方和\n                sum += (n%10)*(n%10);\n                // 缩短位数（剔除个位）\n                n /= 10;\n            }\n\n            // 判断是否为1\n            if(sum == 1){\n                return true;\n            }else{\n                n = sum;\n            }\n\n            // sum曾经出现过\n            if(tmp.find(sum) != tmp.end()){\n                return false;\n            }else{\n                tmp.insert(sum);\n            }\n\n        }\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 总结\n\n * 无限循环 = 会重复出现值\n\n * 分解正数的个位数\n   \n   while(n){\n       // 取个数数并平方和\n       sum += (n%10)*(n%10);\n       // 缩短位数（剔除个位）\n       n /= 10;\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n\n# 1. 两数之和\n\n * 题目：1. 两数之和\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：map 解决哈希问题\n\n\n# 录前想法\n\n 1. 可以暴力的循环比对\n 2. 利用相加，使用 map 数据结构保存值，快速匹配\n\nmap 的掌握不熟，下面代码为暴力解法，已 ac (✔️)\n\nclass solution {\npublic:\n    vector<int> twosum(vector<int>& nums, int target) {\n        \n       for(int i = 0; i < nums.size();++i){\n            for(int j = i + 1; j < nums.size();++j){\n                if(nums[i]+nums[j] == target){\n                    return {i,j};\n                }\n            }\n       }\n\n        return {};\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 录后想法\n\n思路正确，顺便学习以下 map 用法，ac (✔️)\n\nclass solution {\npublic:\n    vector<int> twosum(vector<int>& nums, int target) {\n        \n        // 将nums装入map中\n        std::unordered_map <int,int> map;\n        for(int i = 0; i < nums.size(); ++i){\n            auto iter = map.find(target - nums[i]); \n            if(iter != map.end()){\n                // iter->second 下标\n                // iter->frist  值\n                return {iter->second, i};\n            }\n            map.insert(pair<int, int>(nums[i], i)); \n        }\n\n        return {};\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 总结\n\n * 判断 key 有序无序选择使用 map\n\n映射                   底层实现   是否有序     数值是否可以重复   能否更改数值     查询效率       增删效率\nstd::map             红黑树    key 有序   key 不可重复   key 不可修改   o(log n)   o(log n)\nstd::multimap        红黑树    key 有序   key 可重复    key 不可修改   o(log n)   o(log n)\nstd::unordered_map   哈希表    key 无序   key 不可重复   key 不可修改   o(1)       o(1)\n\n\n# 总结\n\n 1. 数组、set 集合、map 的应用\n\n * set 集合：查元素、保存不重复\n * map：查元素，需要下标\n\n集合                       底层实现   是否有序   数值是否可以重复   能否更改数值   查询效率       增删效率\nstd::set                 红黑树    有序     否          否        o(log n)   o(log n)\nstd::multiset            红黑树    有序     是          否        o(logn)    o(logn)\nstd::unordered_set(✔️)   哈希表    无序     否          否        o(1)       o(1)\n\n----------------------------------------\n\n映射                   底层实现   是否有序     数值是否可以重复   能否更改数值     查询效率       增删效率\nstd::map             红黑树    key 有序   key 不可重复   key 不可修改   o(logn)    o(logn)\nstd::multimap        红黑树    key 有序   key 可重复    key 不可修改   o(log n)   o(log n)\nstd::unordered_map   哈希表    key 无序   key 不可重复   key 不可修改   o(1)       o(1)\n\n 2. 迭代器的使用\n\n// 判断元素是否出现过\nif(tmp.find(sum) != tmp.end()){}\n\n\n1\n2\n\n 3. 个位运算\n\nwhile(n){\n\tsum += n%10; // n%10个位\n\tn /= 10;     // 剔除已使用个位\n}\n\n\n1\n2\n3\n4\n",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "Day06-哈希",
      "frontmatter": {
        "title": "Day06-哈希",
        "date": "2023-05-30T01:13:06.000Z",
        "permalink": "/pages/5d4a2f/",
        "categories": [
          "算法",
          "算法打卡"
        ],
        "tags": [
          "打卡"
        ]
      },
      "regularPath": "/02.%E7%AE%97%E6%B3%95/01.%E7%AE%97%E6%B3%95%E6%89%93%E5%8D%A1/06.Day06-%E5%93%88%E5%B8%8C.html",
      "relativePath": "02.算法/01.算法打卡/06.Day06-哈希.md",
      "key": "v-24f403b8",
      "path": "/pages/5d4a2f/",
      "headers": [
        {
          "level": 2,
          "title": "454.四数相加II",
          "slug": "_454-四数相加ii",
          "normalizedTitle": "454. 四数相加 ii",
          "charIndex": 4
        },
        {
          "level": 3,
          "title": "录前想法",
          "slug": "录前想法",
          "normalizedTitle": "录前想法",
          "charIndex": 130
        },
        {
          "level": 3,
          "title": "录后想法",
          "slug": "录后想法",
          "normalizedTitle": "录后想法",
          "charIndex": 850
        },
        {
          "level": 3,
          "title": "总结",
          "slug": "总结",
          "normalizedTitle": "总结",
          "charIndex": 865
        },
        {
          "level": 2,
          "title": "383. 赎金信",
          "slug": "_383-赎金信",
          "normalizedTitle": "383. 赎金信",
          "charIndex": 18
        },
        {
          "level": 3,
          "title": "录前想法",
          "slug": "录前想法-2",
          "normalizedTitle": "录前想法",
          "charIndex": 130
        },
        {
          "level": 3,
          "title": "录后想法",
          "slug": "录后想法-2",
          "normalizedTitle": "录后想法",
          "charIndex": 850
        },
        {
          "level": 3,
          "title": "总结",
          "slug": "总结-2",
          "normalizedTitle": "总结",
          "charIndex": 865
        },
        {
          "level": 2,
          "title": "15. 三数之和",
          "slug": "_15-三数之和",
          "normalizedTitle": "15. 三数之和",
          "charIndex": 28
        },
        {
          "level": 3,
          "title": "录前想法",
          "slug": "录前想法-3",
          "normalizedTitle": "录前想法",
          "charIndex": 130
        },
        {
          "level": 3,
          "title": "录后想法",
          "slug": "录后想法-3",
          "normalizedTitle": "录后想法",
          "charIndex": 850
        },
        {
          "level": 3,
          "title": "总结",
          "slug": "总结-3",
          "normalizedTitle": "总结",
          "charIndex": 865
        },
        {
          "level": 2,
          "title": "18. 四数之和",
          "slug": "_18-四数之和",
          "normalizedTitle": "18. 四数之和",
          "charIndex": 44
        },
        {
          "level": 3,
          "title": "录前想法",
          "slug": "录前想法-4",
          "normalizedTitle": "录前想法",
          "charIndex": 130
        },
        {
          "level": 3,
          "title": "录后想法",
          "slug": "录后想法-4",
          "normalizedTitle": "录后想法",
          "charIndex": 850
        },
        {
          "level": 3,
          "title": "总结",
          "slug": "总结-4",
          "normalizedTitle": "总结",
          "charIndex": 865
        },
        {
          "level": 2,
          "title": "总结",
          "slug": "总结-5",
          "normalizedTitle": "总结",
          "charIndex": 865
        }
      ],
      "excerpt": "<div class=\"custom-block tip\"><p class=\"custom-block-title\">提示</p>\n<p>454. 四数相加 II、 383. 赎金信、 15. 三数之和 <code>【很难】</code>   、 18. 四数之和 <code>【很难】</code></p>\n</div>\n",
      "lastUpdated": "6/2/2023, 6:34:00 PM",
      "lastUpdatedTimestamp": 1685702040000,
      "headersStr": "454.四数相加II 录前想法 录后想法 总结 383. 赎金信 录前想法 录后想法 总结 15. 三数之和 录前想法 录后想法 总结 18. 四数之和 录前想法 录后想法 总结 总结",
      "content": "提示\n\n454. 四数相加 II、 383. 赎金信、 15. 三数之和 【很难】 、 18. 四数之和 【很难】\n\n\n# 454. 四数相加 II\n\n * 题目：454. 四数相加 II\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：map 巧解\n\n\n# 录前想法\n\n做过，记得思路，两个为一组记录为 MAP 的 Key，再两个一组记录为 MAP 的 - Key\n\n下面是实现代码，已 AC (✔️)\n\nclass Solution {\npublic:\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\n\n        // 创建map\n        unordered_map<int,int> map;\n        \n        int ans = 0;\n\n        // 第一组循环\n        for(int num1 : nums1){\n            for(int num2 : nums2){\n                map[num1+num2]++;\n            }\n        }\n\n        // 第二组循环\n        for(int num3 : nums3){\n            for(int num4 : nums4){\n                ans += map[-(num3+num4)];\n            }\n        }\n\n        return ans;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n * 时间复杂度: O (n^2)\n * 空间复杂度: O (n^2)\n\n\n# 录后想法\n\n一致✌️\n\n\n# 总结\n\n无\n\n\n# 383. 赎金信\n\n * 题目：383. 赎金信\n\n * 讲解：文章讲解\n\n * 要求：和上一题同思路\n\n\n# 录前想法\n\n与上一题思路一致，已 AC (✔️)\n\nclass Solution {\npublic:\n    bool canConstruct(string ransomNote, string magazine) {\n\n        // 创建map\n        unordered_map<char,int> map;\n\n        // 放入ransomNote\n        for(int i = 0; i < ransomNote.size(); ++i){\n            map[ransomNote[i]]++;\n        }\n\n        // 出magazine\n        for(int i = 0; i < magazine.size(); ++i){\n            map[magazine[i]]--;\n        }\n\n        for(int i = 0; i < ransomNote.size(); ++i){\n            if(map[ransomNote[i]] > 0){\n                return false;\n            }\n        }\n\n        // 判断是否全部出完\n        return true;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n * 时间复杂度: O (n)\n * 空间复杂度: O (1)\n\n\n# 录后想法\n\nmap 的空间消耗要比数组大一些的，因为 map 要维护红黑树或者哈希表，而且还要做哈希函数，是费时的\n\n使用数组会节省空间\n\nclass Solution {\npublic:\n    bool canConstruct(string ransomNote, string magazine) {\n\n        // 创建map\n        int arr[26] = {0};\n\n        // 放入ransomNote\n        for(int i = 0; i < magazine.size(); ++i){\n            arr[magazine[i] - 'a']++;\n        }\n\n        // 出magazine\n        for(int i = 0; i < ransomNote.size(); ++i){\n            arr[ransomNote[i] - 'a']--;\n\n            if(arr[ransomNote[i] - 'a'] < 0){\n                return false;\n            }\n        }\n\n        // 判断是否全部出完\n        return true;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n * 时间复杂度: O (n)\n * 空间复杂度: O (1)\n\n\n# 总结\n\nmap 固然好，但也开销大\n\n\n# 15. 三数之和\n\n * 题目：15. 三数之和\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：双指针\n\n\n# 录前想法\n\n只想到了暴力的解法，双指针没想。。。\n\n\n# 录后想法\n\n看过卡哥的讲解视频后，整理出以下实现思路：\n\n * i 确定 nums [i]，向后移动\n * left 和 right 确定 nums [left] 和 nums [right]，向中间缩\n\nclass Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        \n        // 创建二位数组结果集合\n\n        // 排序\n\n        // 遍历\n\n            // 对i去重\n\n            // 三数之和 > 0\n                // right--\n\n            // 三数之和 < 0\n                // left++\n\n            // 三数之和 = 0\n                // 收集结果\n\n                // 对left去重\n\n                // 对right去重\n            \n        // 返回结果集合\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n以下是最终实现的代码，已 AC (✔️)：\n\nclass Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        \n        // 创建二位数组结果集合\n        vector<vector<int>> result;\n        int left,right;\n\n        // 排序\n        sort(nums.begin(), nums.end());\n\n        // 遍历\n        for(int i = 0; i < nums.size(); ++i){\n\n            if(nums[i] > 0){return result;}\n\n            // 对i去重\n            if(i > 0 && nums[i] == nums[i-1]){continue;}\n\n            // 创建双指针\n            left = i + 1;\n            right = nums.size() - 1;\n\n            while(left < right){\n                \n                // 求和\n                int tmp = nums[i] + nums[left] + nums[right];\n                \n                if(tmp > 0){// 三数之和 > 0\n                    // right--\n                    right--;\n                }else if(tmp < 0){// 三数之和 < 0\n                    // left++\n                    left++;\n                }else{// 三数之和 = 0\n                    // 收集结果\n                    result.push_back(vector<int>{nums[i],nums[left],nums[right]});\n\n                    // 对left去重\n                    while(left < right && nums[left] == nums[left + 1]){\n                        left++;\n                    }\n\n                    // 对right去重\n                    while(left < right && nums[right] == nums[right - 1]){\n                        right--;\n                    }\n\n                    // 同时缩小\n                    left++;\n                    right--;\n                } \n            }\n        }\n            \n        // 返回结果集合\n        return result;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n\n\n\n# 总结\n\n * 要注意去重的细节\n * 双指针收缩\n\n\n# 18. 四数之和\n\n * 题目：18. 四数之和\n * 讲解：文章讲解、视频讲解\n * 要求：\n   * 1. 为什么 454. 四数相加 II 会简单很多？\n     2. 双指针\n\n\n# 录前想法\n\n和三数之和的思路相似，学习完三数之和有思路写出代码，已 AC (✔️)\n\nclass Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\n\n        int size = nums.size();     // 获取数组长度\n        vector<vector<int>> result; // 结果集合\n        long tmpSum = 0;             // 是数之和\n        int left,right;             // 双指针\n\n        // 小于4判断\n        if (size < 4) { return result; }\n\n        // 排序\n        sort(nums.begin(), nums.end());\n\n        // 循环a\n        for(int a = 0; a < size - 3; ++a){\n            \n            // 对a去重\n            if(a > 0 && nums[a] == nums[a-1]){continue;}\n\n            // 循环b\n            for(int b = a + 1; b < size - 2; ++b){\n\n                // 对b去重\n                if(b > a + 1 && nums[b] == nums[b-1]){continue;}\n\n                // 双指针\n                left = b + 1;\n                right = size - 1;\n\n                // 双指针移动\n                while(left < right){\n\n                    // 求和\n                    tmpSum = (long)nums[a]+nums[b]+nums[left]+nums[right];\n\n                    // 对比target\n                    if(tmpSum > target){\n                        --right;\n                    }else if(tmpSum < target){\n                        ++left;\n                    }else{\n                        result.push_back(vector<int>{nums[a],nums[b],nums[left],nums[right]});\n\n                        // left 去重\n                        while(left < right && nums[left] == nums[left+1]){++left;}\n\n                        // right去重\n                        while(left < right && nums[right] == nums[right-1]){--right;}\n\n                        ++left;\n                        --right;\n                    }\n                }\n            }\n        }\n\n        return result;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n\n\n\n# 录后想法\n\n剪枝的细节操作，叹服\n\n整理完后，写出以下代码，已 AC (✔️)\n\n * 求和时 long 类型，防止溢出\n\nclass Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\n\n        int size = nums.size();     // 获取数组长度\n        vector<vector<int>> result; // 结果集合\n        long tmpSum = 0;             // 是数之和 long防止溢出\n        int left,right;             // 双指针\n\n        // 小于4判断\n        if (size < 4) { return result; }\n\n        // 排序\n        sort(nums.begin(), nums.end());\n\n        // 循环a\n        for(int a = 0; a < size - 3; ++a){\n            \n            // 对a去重\n            if(a > 0 && nums[a] == nums[a-1]){continue;}\n\n            // 循环b\n            for(int b = a + 1; b < size - 2; ++b){\n\n                // 对b去重\n                if(b > a + 1 && nums[b] == nums[b-1]){continue;}\n\n                // 一层剪枝\n                if(nums[a]+nums[b] > 0 && target > 0 && nums[a]+nums[b]>target){break;}\n                // 双指针\n                left = b + 1;\n                right = size - 1;\n\n                // 双指针移动\n                while(left < right){\n\n                    // 求和\n                    tmpSum = (long)nums[a]+nums[b]+nums[left]+nums[right];\n\n                    // 对比target\n                    if(tmpSum > target){\n                        --right;\n                    }else if(tmpSum < target){\n                        ++left;\n                    }else{\n                        result.push_back(vector<int>{nums[a],nums[b],nums[left],nums[right]});\n\n                        // left 去重\n                        while(left < right && nums[left] == nums[left+1]){++left;}\n\n                        // right去重\n                        while(left < right && nums[right] == nums[right-1]){--right;}\n\n                        ++left;\n                        --right;\n                    }\n                }\n            }\n        }\n\n        return result;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n\n\n\n# 总结\n\n * 细节的剪枝操作\n\n\n# 总结\n\n三数之和与四数之和太难了，细节上的操作很多，侧面也反映对代码的掌握不足，继续刷！",
      "normalizedContent": "提示\n\n454. 四数相加 ii、 383. 赎金信、 15. 三数之和 【很难】 、 18. 四数之和 【很难】\n\n\n# 454. 四数相加 ii\n\n * 题目：454. 四数相加 ii\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：map 巧解\n\n\n# 录前想法\n\n做过，记得思路，两个为一组记录为 map 的 key，再两个一组记录为 map 的 - key\n\n下面是实现代码，已 ac (✔️)\n\nclass solution {\npublic:\n    int foursumcount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\n\n        // 创建map\n        unordered_map<int,int> map;\n        \n        int ans = 0;\n\n        // 第一组循环\n        for(int num1 : nums1){\n            for(int num2 : nums2){\n                map[num1+num2]++;\n            }\n        }\n\n        // 第二组循环\n        for(int num3 : nums3){\n            for(int num4 : nums4){\n                ans += map[-(num3+num4)];\n            }\n        }\n\n        return ans;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n * 时间复杂度: o (n^2)\n * 空间复杂度: o (n^2)\n\n\n# 录后想法\n\n一致✌️\n\n\n# 总结\n\n无\n\n\n# 383. 赎金信\n\n * 题目：383. 赎金信\n\n * 讲解：文章讲解\n\n * 要求：和上一题同思路\n\n\n# 录前想法\n\n与上一题思路一致，已 ac (✔️)\n\nclass solution {\npublic:\n    bool canconstruct(string ransomnote, string magazine) {\n\n        // 创建map\n        unordered_map<char,int> map;\n\n        // 放入ransomnote\n        for(int i = 0; i < ransomnote.size(); ++i){\n            map[ransomnote[i]]++;\n        }\n\n        // 出magazine\n        for(int i = 0; i < magazine.size(); ++i){\n            map[magazine[i]]--;\n        }\n\n        for(int i = 0; i < ransomnote.size(); ++i){\n            if(map[ransomnote[i]] > 0){\n                return false;\n            }\n        }\n\n        // 判断是否全部出完\n        return true;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n * 时间复杂度: o (n)\n * 空间复杂度: o (1)\n\n\n# 录后想法\n\nmap 的空间消耗要比数组大一些的，因为 map 要维护红黑树或者哈希表，而且还要做哈希函数，是费时的\n\n使用数组会节省空间\n\nclass solution {\npublic:\n    bool canconstruct(string ransomnote, string magazine) {\n\n        // 创建map\n        int arr[26] = {0};\n\n        // 放入ransomnote\n        for(int i = 0; i < magazine.size(); ++i){\n            arr[magazine[i] - 'a']++;\n        }\n\n        // 出magazine\n        for(int i = 0; i < ransomnote.size(); ++i){\n            arr[ransomnote[i] - 'a']--;\n\n            if(arr[ransomnote[i] - 'a'] < 0){\n                return false;\n            }\n        }\n\n        // 判断是否全部出完\n        return true;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n * 时间复杂度: o (n)\n * 空间复杂度: o (1)\n\n\n# 总结\n\nmap 固然好，但也开销大\n\n\n# 15. 三数之和\n\n * 题目：15. 三数之和\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：双指针\n\n\n# 录前想法\n\n只想到了暴力的解法，双指针没想。。。\n\n\n# 录后想法\n\n看过卡哥的讲解视频后，整理出以下实现思路：\n\n * i 确定 nums [i]，向后移动\n * left 和 right 确定 nums [left] 和 nums [right]，向中间缩\n\nclass solution {\npublic:\n    vector<vector<int>> threesum(vector<int>& nums) {\n        \n        // 创建二位数组结果集合\n\n        // 排序\n\n        // 遍历\n\n            // 对i去重\n\n            // 三数之和 > 0\n                // right--\n\n            // 三数之和 < 0\n                // left++\n\n            // 三数之和 = 0\n                // 收集结果\n\n                // 对left去重\n\n                // 对right去重\n            \n        // 返回结果集合\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n以下是最终实现的代码，已 ac (✔️)：\n\nclass solution {\npublic:\n    vector<vector<int>> threesum(vector<int>& nums) {\n        \n        // 创建二位数组结果集合\n        vector<vector<int>> result;\n        int left,right;\n\n        // 排序\n        sort(nums.begin(), nums.end());\n\n        // 遍历\n        for(int i = 0; i < nums.size(); ++i){\n\n            if(nums[i] > 0){return result;}\n\n            // 对i去重\n            if(i > 0 && nums[i] == nums[i-1]){continue;}\n\n            // 创建双指针\n            left = i + 1;\n            right = nums.size() - 1;\n\n            while(left < right){\n                \n                // 求和\n                int tmp = nums[i] + nums[left] + nums[right];\n                \n                if(tmp > 0){// 三数之和 > 0\n                    // right--\n                    right--;\n                }else if(tmp < 0){// 三数之和 < 0\n                    // left++\n                    left++;\n                }else{// 三数之和 = 0\n                    // 收集结果\n                    result.push_back(vector<int>{nums[i],nums[left],nums[right]});\n\n                    // 对left去重\n                    while(left < right && nums[left] == nums[left + 1]){\n                        left++;\n                    }\n\n                    // 对right去重\n                    while(left < right && nums[right] == nums[right - 1]){\n                        right--;\n                    }\n\n                    // 同时缩小\n                    left++;\n                    right--;\n                } \n            }\n        }\n            \n        // 返回结果集合\n        return result;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n\n\n\n# 总结\n\n * 要注意去重的细节\n * 双指针收缩\n\n\n# 18. 四数之和\n\n * 题目：18. 四数之和\n * 讲解：文章讲解、视频讲解\n * 要求：\n   * 1. 为什么 454. 四数相加 ii 会简单很多？\n     2. 双指针\n\n\n# 录前想法\n\n和三数之和的思路相似，学习完三数之和有思路写出代码，已 ac (✔️)\n\nclass solution {\npublic:\n    vector<vector<int>> foursum(vector<int>& nums, int target) {\n\n        int size = nums.size();     // 获取数组长度\n        vector<vector<int>> result; // 结果集合\n        long tmpsum = 0;             // 是数之和\n        int left,right;             // 双指针\n\n        // 小于4判断\n        if (size < 4) { return result; }\n\n        // 排序\n        sort(nums.begin(), nums.end());\n\n        // 循环a\n        for(int a = 0; a < size - 3; ++a){\n            \n            // 对a去重\n            if(a > 0 && nums[a] == nums[a-1]){continue;}\n\n            // 循环b\n            for(int b = a + 1; b < size - 2; ++b){\n\n                // 对b去重\n                if(b > a + 1 && nums[b] == nums[b-1]){continue;}\n\n                // 双指针\n                left = b + 1;\n                right = size - 1;\n\n                // 双指针移动\n                while(left < right){\n\n                    // 求和\n                    tmpsum = (long)nums[a]+nums[b]+nums[left]+nums[right];\n\n                    // 对比target\n                    if(tmpsum > target){\n                        --right;\n                    }else if(tmpsum < target){\n                        ++left;\n                    }else{\n                        result.push_back(vector<int>{nums[a],nums[b],nums[left],nums[right]});\n\n                        // left 去重\n                        while(left < right && nums[left] == nums[left+1]){++left;}\n\n                        // right去重\n                        while(left < right && nums[right] == nums[right-1]){--right;}\n\n                        ++left;\n                        --right;\n                    }\n                }\n            }\n        }\n\n        return result;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n\n\n\n# 录后想法\n\n剪枝的细节操作，叹服\n\n整理完后，写出以下代码，已 ac (✔️)\n\n * 求和时 long 类型，防止溢出\n\nclass solution {\npublic:\n    vector<vector<int>> foursum(vector<int>& nums, int target) {\n\n        int size = nums.size();     // 获取数组长度\n        vector<vector<int>> result; // 结果集合\n        long tmpsum = 0;             // 是数之和 long防止溢出\n        int left,right;             // 双指针\n\n        // 小于4判断\n        if (size < 4) { return result; }\n\n        // 排序\n        sort(nums.begin(), nums.end());\n\n        // 循环a\n        for(int a = 0; a < size - 3; ++a){\n            \n            // 对a去重\n            if(a > 0 && nums[a] == nums[a-1]){continue;}\n\n            // 循环b\n            for(int b = a + 1; b < size - 2; ++b){\n\n                // 对b去重\n                if(b > a + 1 && nums[b] == nums[b-1]){continue;}\n\n                // 一层剪枝\n                if(nums[a]+nums[b] > 0 && target > 0 && nums[a]+nums[b]>target){break;}\n                // 双指针\n                left = b + 1;\n                right = size - 1;\n\n                // 双指针移动\n                while(left < right){\n\n                    // 求和\n                    tmpsum = (long)nums[a]+nums[b]+nums[left]+nums[right];\n\n                    // 对比target\n                    if(tmpsum > target){\n                        --right;\n                    }else if(tmpsum < target){\n                        ++left;\n                    }else{\n                        result.push_back(vector<int>{nums[a],nums[b],nums[left],nums[right]});\n\n                        // left 去重\n                        while(left < right && nums[left] == nums[left+1]){++left;}\n\n                        // right去重\n                        while(left < right && nums[right] == nums[right-1]){--right;}\n\n                        ++left;\n                        --right;\n                    }\n                }\n            }\n        }\n\n        return result;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n\n\n\n# 总结\n\n * 细节的剪枝操作\n\n\n# 总结\n\n三数之和与四数之和太难了，细节上的操作很多，侧面也反映对代码的掌握不足，继续刷！",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "Day07-字符串",
      "frontmatter": {
        "title": "Day07-字符串",
        "date": "2023-05-31T10:04:29.000Z",
        "permalink": "/pages/26eaf0/",
        "categories": [
          "算法",
          "算法打卡"
        ],
        "tags": [
          "打卡"
        ]
      },
      "regularPath": "/02.%E7%AE%97%E6%B3%95/01.%E7%AE%97%E6%B3%95%E6%89%93%E5%8D%A1/07.Day07-%E5%AD%97%E7%AC%A6%E4%B8%B2.html",
      "relativePath": "02.算法/01.算法打卡/07.Day07-字符串.md",
      "key": "v-3bb075f0",
      "path": "/pages/26eaf0/",
      "headers": [
        {
          "level": 2,
          "title": "344.反转字符串",
          "slug": "_344-反转字符串",
          "normalizedTitle": "344. 反转字符串",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "录前想法",
          "slug": "录前想法",
          "normalizedTitle": "录前想法",
          "charIndex": 166
        },
        {
          "level": 3,
          "title": "录后想法",
          "slug": "录后想法",
          "normalizedTitle": "录后想法",
          "charIndex": 533
        },
        {
          "level": 2,
          "title": "541. 反转字符串II",
          "slug": "_541-反转字符串ii",
          "normalizedTitle": "541. 反转字符串 ii",
          "charIndex": 13
        },
        {
          "level": 3,
          "title": "录前想法",
          "slug": "录前想法-2",
          "normalizedTitle": "录前想法",
          "charIndex": 166
        },
        {
          "level": 3,
          "title": "录后想法",
          "slug": "录后想法-2",
          "normalizedTitle": "录后想法",
          "charIndex": 533
        },
        {
          "level": 3,
          "title": "总结",
          "slug": "总结",
          "normalizedTitle": "总结",
          "charIndex": 2359
        },
        {
          "level": 2,
          "title": "剑指Offer 05.替换空格",
          "slug": "剑指offer-05-替换空格",
          "normalizedTitle": "剑指 offer 05. 替换空格",
          "charIndex": 27
        },
        {
          "level": 3,
          "title": "录前想法",
          "slug": "录前想法-3",
          "normalizedTitle": "录前想法",
          "charIndex": 166
        },
        {
          "level": 3,
          "title": "录后想法",
          "slug": "录后想法-3",
          "normalizedTitle": "录后想法",
          "charIndex": 533
        },
        {
          "level": 2,
          "title": "151.翻转字符串里的单词",
          "slug": "_151-翻转字符串里的单词",
          "normalizedTitle": "151. 翻转字符串里的单词",
          "charIndex": 46
        },
        {
          "level": 3,
          "title": "录前想法",
          "slug": "录前想法-4",
          "normalizedTitle": "录前想法",
          "charIndex": 166
        },
        {
          "level": 3,
          "title": "录后想法",
          "slug": "录后想法-4",
          "normalizedTitle": "录后想法",
          "charIndex": 533
        },
        {
          "level": 3,
          "title": "总结",
          "slug": "总结-2",
          "normalizedTitle": "总结",
          "charIndex": 2359
        },
        {
          "level": 2,
          "title": "剑指Offer58-II.左旋转字符串",
          "slug": "剑指offer58-ii-左旋转字符串",
          "normalizedTitle": "剑指 offer58-ii. 左旋转字符串",
          "charIndex": 62
        },
        {
          "level": 3,
          "title": "录前想法",
          "slug": "录前想法-5",
          "normalizedTitle": "录前想法",
          "charIndex": 166
        },
        {
          "level": 3,
          "title": "录后想法",
          "slug": "录后想法-5",
          "normalizedTitle": "录后想法",
          "charIndex": 533
        },
        {
          "level": 2,
          "title": "总结",
          "slug": "总结-3",
          "normalizedTitle": "总结",
          "charIndex": 2359
        }
      ],
      "excerpt": "<blockquote>\n<p>344. 反转字符串、541. 反转字符串 II、剑指 Offer 05. 替换空格、 151. 翻转字符串里的单词、 剑指 Offer58-II. 左旋转字符串</p>\n</blockquote>\n",
      "lastUpdated": "6/2/2023, 6:34:00 PM",
      "lastUpdatedTimestamp": 1685702040000,
      "headersStr": "344.反转字符串 录前想法 录后想法 541. 反转字符串II 录前想法 录后想法 总结 剑指Offer 05.替换空格 录前想法 录后想法 151.翻转字符串里的单词 录前想法 录后想法 总结 剑指Offer58-II.左旋转字符串 录前想法 录后想法 总结",
      "content": "> 344. 反转字符串、541. 反转字符串 II、剑指 Offer 05. 替换空格、 151. 翻转字符串里的单词、 剑指 Offer58-II. 左旋转字符串\n\n\n# 344. 反转字符串\n\n * 题目：344. 反转字符串\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：理解什么时候用库函数，什么时候不用库函数\n\n\n# 录前想法\n\n交换首末元素，注意数组越界，已 AC (✔️)\n\nclass Solution {\npublic:\n    void reverseString(vector<char>& s) {\n\n        int tmp;\n        int len = s.size() - 1;\n\n        // 交换\n        for(int i = 0; i <= len/2; ++i){\n            \n            tmp = s[i];\n            s[i] = s[len-i];\n            s[len-i] = tmp;\n\n        }\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 录后想法\n\n思路一致，多了两种交换的方法可以学习：\n\n 1. swap 函数\n    \n    swap(s[i],s[j]);\n    \n    \n    1\n    \n\n 2. 通过位运算\n    \n    s[i] ^= s[j];\n    s[j] ^= s[i];\n    s[i] ^= s[j];\n    \n    \n    1\n    2\n    3\n    \n\n\n# 541. 反转字符串 II\n\n * 题目：541. 反转字符串 II\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：先独立做再看解析\n\n\n# 录前想法\n\n有思路，但就是写不对，提交错了三次😓\n\n以下是我的代码，未 AC (❌)\n\nclass Solution {\npublic:\n    string reverseStr(string s, int k) {\n        \n        int len = s.size();\n        int pos = 0;\n\n        if(len <= k){\n            reverse(s,0 ,len - 1);\n            return s;\n        }\n\n        for(pos = k - 1; pos < len; pos += 2 * k){\n\n            // 反转前k个字符\n            // abcdefghe 8\n            reverse(s,pos - k + 1 ,pos);\n            \n        }\n\n        // 如果剩余字符少于 k 个，则将剩余字符全部反转。\n        // abcdefg 8\n        if(len - pos < k){\n            reverse(s,pos,len - pos - 1);\n        }\n\n        // 小于 2k 但大于或等于 k 个，则反转前 k 个字符\n        if(len - pos < 2 * k && len - pos >= k){\n            reverse(s,pos,pos + k - 1);\n        }\n\n        return s;\n    }\n\n    // 反转\n    void reverse(string &s,int l,int r){\n        for(;l < r;l++,r--){\n            swap(s[l],s[r]);\n        }\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n\n# 录后想法\n\n哇，感觉自己写的好复杂😂\n\n有考虑到间断跳跃\n\n以下是整理后已 AC 的代码（✔️）\n\nclass Solution {\npublic:\n    string reverseStr(string s, int k) {\n\n        int len = s.size();\n\n        for (int i = 0; i < len; i += (2 * k)) {\n            \n            if(i+k<=len){\n                reverse(s,i,i+k-1);\n                continue;\n            }\n\n            reverse(s,i,len-1);\n        }\n\n        return s;\n    }\n\n    // 反转\n    void reverse(string &s,int l,int r){\n        for(;l < r;l++,r--){\n            swap(s[l],s[r]);\n        }\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 总结\n\n * 间断的跳跃\n\n\n# 剑指 Offer 05. 替换空格\n\n * 题目：剑指 Offer 05. 替换空格\n\n * 讲解：文章讲解\n\n * 建议：对于线性数据结构，填充或者删除，后序处理会高效的多。好好体会一下。\n\n\n# 录前想法\n\n创建新的 char 数组，数组容量为 原数组+Space * 2 来保存结果集\n\nclass Solution {\npublic:\n    string replaceSpace(string s) {\n\n        // 统计空格数量\n        int len = s.size();\n        int spaceCount = 0;\n        int pos = 0;\n        \n        for(int i = 0; i < len; ++i){\n            if(s[i] == ' '){\n                ++spaceCount;\n            }\n        }\n\n\n        // 拓容\n        char ans[len + 2 * spaceCount];\n\n        // 循环填充\n        for(int i = 0; i < len; ++i){\n            \n            if(s[i] == ' '){\n                ans[pos++] = '%';\n                ans[pos++] = '2';\n                ans[pos++] = '0';\n            }else{\n                ans[pos++] = s[i];\n            }\n            \n        }\n\n        return string(ans);\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n运行时出现以下的错误\n\n\n\n经过一段时间的排查后发现是对 char*、char [] 与 string 的初始化及转换不熟悉导致\n\n核心时忽略了 char 数组自带的 '\\0' 字符，所以可以进行以下修改：\n\nclass Solution {\npublic:\n    string replaceSpace(string s) {\n\n\t   ...\n\n        // 拓容\n        char ans[len + 2 * spaceCount + 1];\n        \n       \t...\n\n        ans[pos] = '\\0';\n\n        return string(ans);\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n修改完后就没有问题了，最终已 AC 的实现代码如下：\n\nclass Solution {\npublic:\n    string replaceSpace(string s) {\n\n        // 统计空格数量\n        int len = s.size();\n        int spaceCount = 0;\n        int pos = 0;\n        \n        for(int i = 0; i < len; ++i){\n            if(s[i] == ' '){\n                ++spaceCount;\n            }\n        }\n\n\n        // 拓容\n        char ans[len + 2 * spaceCount + 1];\n\n        // 循环填充\n        for(int i = 0; i < len; ++i){\n            \n            if(s[i] == ' '){\n                ans[pos++] = '%';\n                ans[pos++] = '2';\n                ans[pos++] = '0';\n            }else{\n                ans[pos++] = s[i];\n            }\n            \n        }\n\n        ans[pos] = '\\0';\n\n        return string(ans);\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# 录后想法\n\n>  * 双指针\n>  * resize()\n\n\n\nclass Solution {\npublic:\n    string replaceSpace(string s) {\n\n        // 统计空格数量\n        int oldLen = s.size();\n        int newLen;\n        int spaceCount = 0;\n        \n        for(int i = 0; i < oldLen; ++i){\n            if(s[i] == ' '){\n                ++spaceCount;\n            }\n        }\n\n        newLen = oldLen + 2 * spaceCount;\n\n        // 拓容\n        s.resize(newLen);\n\n        // 循环填充\n        // fast 指向原数组的最后一个位置\n        // slow 指向新数组的最后一个位置\n        for(int fast = oldLen - 1,slow = newLen - 1; fast >= 0;){\n            \n            if(s[fast] == ' '){\n                s[slow--] = '0';\n                s[slow--] = '2';\n                s[slow--] = '%';\n                fast--;\n            }else{\n                s[slow--] = s[fast--];\n            }\n        }\n\n        return s;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# 151. 翻转字符串里的单词\n\n * 题目：151. 翻转字符串里的单词\n\n * 讲解：文章讲解、视频讲解\n\n * 建议：这道题目基本把 刚刚做过的字符串操作 都覆盖了，不过就算知道解题思路，本题代码并不容易写，要多练一练。\n\n\n# 录前想法\n\n 1. 去除多余的空格\n 2. 整体反转\n 3. 单词反转\n\n已经 AC (✔️)\n\nclass Solution {\npublic:\n    string reverseWords(string s) {\n        \n        int len = s.size();\n\n        // 1.双指针移动删除空格\n        // 对空格去重\n        int fast = 0,slow = 0;\n        // 1.1 删除\n        // 找到第一个不为空格的元素\n        while(s[fast] == ' ' && fast < len){fast++;}\n        // 1.2 中间遇到空格\n        while(fast < len){\n            \n            if(s[fast] != ' ' || (s[fast] == ' ' && s[fast-1] != ' ' && fast != 0)){\n                s[slow++] = s[fast++];\n            }else{\n                while(s[fast] == ' ' && fast < len){fast++;}\n            }\n\n        }\n        // 1.3 结尾遇到空格\n        if(s[slow - 1] == ' '){\n            s.resize(slow - 1);\n            len = slow - 1;\n        }else{\n            s.resize(slow);\n            len = slow;\n        }\n\n        // 2. 整体反转\n        reverse(s,0,len-1);\n\n        // 3. 再对每个单词反转\n        int l,r;\n        for(l = 0,r = 0; r < len; ++r){\n\n            if(s[r] == ' '){\n                reverse(s,l,r - 1);\n                l = r + 1;\n            }\n        }\n\n        // 反转最后一个单词\n        reverse(s,l,r - 1);\n\n        return s;\n    }\n\n    // 反转\n    void reverse(string &str,int l,int r){\n        for(;l<r; ++l,--r){\n            swap(str[l],str[r]);\n        }\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n * 时间复杂度: O (n)\n * 空间复杂度: O (1)\n\n\n# 录后想法\n\n思路一致\n\n\n# 总结\n\n删除中间段空格的核心判断代码：理解了 s [fast] 与 s [fast-1]\n\nif(s[fast] != ' ' || (s[fast] == ' ' && s[fast-1] != ' ' && fast != 0))\n\n\n1\n\n\n\n# 剑指 Offer58-II. 左旋转字符串\n\n * 题目：剑指 Offer58-II. 左旋转字符串\n\n * 讲解：文章讲解\n\n * 建议：题解中的解法如果没接触过的话，应该会想不到\n\n\n# 录前想法\n\n 1. 整体反转\n 2. 倒数 k 个字符反转\n 3. 正数 len - k 个字符反转\n\n以下代码已 AC (✔️)\n\nclass Solution {\npublic:\n    string reverseLeftWords(string s, int n) {\n\n        // abcdefg\n        // gfedc ba\n        // cdefg ab\n\n        // lrloseumgh\n        // hgmu esolrl\n        // umgh lrlose\n\n        int len = s.size();\n        // 整体反转\n        reverse(s,0,len-1);\n\n        // 倒数n个反转\n        reverse(s,len-n,len-1);\n\n        // 0 ~ len - n 反转\n        reverse(s,0,len-n-1);\n\n        return s;\n    }\n\n    void reverse(string &str,int l,int r){\n        for(;l<r;++l,--r){\n            swap(str[l],str[r]);\n        }\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 录后想法\n\n思路一致✌️\n\n\n# 总结\n\n * 关于 char*、char [] 与 string 的初始化及转换\n\n剪枝操作的细节好难，还需要多加练习！",
      "normalizedContent": "> 344. 反转字符串、541. 反转字符串 ii、剑指 offer 05. 替换空格、 151. 翻转字符串里的单词、 剑指 offer58-ii. 左旋转字符串\n\n\n# 344. 反转字符串\n\n * 题目：344. 反转字符串\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：理解什么时候用库函数，什么时候不用库函数\n\n\n# 录前想法\n\n交换首末元素，注意数组越界，已 ac (✔️)\n\nclass solution {\npublic:\n    void reversestring(vector<char>& s) {\n\n        int tmp;\n        int len = s.size() - 1;\n\n        // 交换\n        for(int i = 0; i <= len/2; ++i){\n            \n            tmp = s[i];\n            s[i] = s[len-i];\n            s[len-i] = tmp;\n\n        }\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 录后想法\n\n思路一致，多了两种交换的方法可以学习：\n\n 1. swap 函数\n    \n    swap(s[i],s[j]);\n    \n    \n    1\n    \n\n 2. 通过位运算\n    \n    s[i] ^= s[j];\n    s[j] ^= s[i];\n    s[i] ^= s[j];\n    \n    \n    1\n    2\n    3\n    \n\n\n# 541. 反转字符串 ii\n\n * 题目：541. 反转字符串 ii\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：先独立做再看解析\n\n\n# 录前想法\n\n有思路，但就是写不对，提交错了三次😓\n\n以下是我的代码，未 ac (❌)\n\nclass solution {\npublic:\n    string reversestr(string s, int k) {\n        \n        int len = s.size();\n        int pos = 0;\n\n        if(len <= k){\n            reverse(s,0 ,len - 1);\n            return s;\n        }\n\n        for(pos = k - 1; pos < len; pos += 2 * k){\n\n            // 反转前k个字符\n            // abcdefghe 8\n            reverse(s,pos - k + 1 ,pos);\n            \n        }\n\n        // 如果剩余字符少于 k 个，则将剩余字符全部反转。\n        // abcdefg 8\n        if(len - pos < k){\n            reverse(s,pos,len - pos - 1);\n        }\n\n        // 小于 2k 但大于或等于 k 个，则反转前 k 个字符\n        if(len - pos < 2 * k && len - pos >= k){\n            reverse(s,pos,pos + k - 1);\n        }\n\n        return s;\n    }\n\n    // 反转\n    void reverse(string &s,int l,int r){\n        for(;l < r;l++,r--){\n            swap(s[l],s[r]);\n        }\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n\n# 录后想法\n\n哇，感觉自己写的好复杂😂\n\n有考虑到间断跳跃\n\n以下是整理后已 ac 的代码（✔️）\n\nclass solution {\npublic:\n    string reversestr(string s, int k) {\n\n        int len = s.size();\n\n        for (int i = 0; i < len; i += (2 * k)) {\n            \n            if(i+k<=len){\n                reverse(s,i,i+k-1);\n                continue;\n            }\n\n            reverse(s,i,len-1);\n        }\n\n        return s;\n    }\n\n    // 反转\n    void reverse(string &s,int l,int r){\n        for(;l < r;l++,r--){\n            swap(s[l],s[r]);\n        }\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 总结\n\n * 间断的跳跃\n\n\n# 剑指 offer 05. 替换空格\n\n * 题目：剑指 offer 05. 替换空格\n\n * 讲解：文章讲解\n\n * 建议：对于线性数据结构，填充或者删除，后序处理会高效的多。好好体会一下。\n\n\n# 录前想法\n\n创建新的 char 数组，数组容量为 原数组+space * 2 来保存结果集\n\nclass solution {\npublic:\n    string replacespace(string s) {\n\n        // 统计空格数量\n        int len = s.size();\n        int spacecount = 0;\n        int pos = 0;\n        \n        for(int i = 0; i < len; ++i){\n            if(s[i] == ' '){\n                ++spacecount;\n            }\n        }\n\n\n        // 拓容\n        char ans[len + 2 * spacecount];\n\n        // 循环填充\n        for(int i = 0; i < len; ++i){\n            \n            if(s[i] == ' '){\n                ans[pos++] = '%';\n                ans[pos++] = '2';\n                ans[pos++] = '0';\n            }else{\n                ans[pos++] = s[i];\n            }\n            \n        }\n\n        return string(ans);\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n运行时出现以下的错误\n\n\n\n经过一段时间的排查后发现是对 char*、char [] 与 string 的初始化及转换不熟悉导致\n\n核心时忽略了 char 数组自带的 '\\0' 字符，所以可以进行以下修改：\n\nclass solution {\npublic:\n    string replacespace(string s) {\n\n\t   ...\n\n        // 拓容\n        char ans[len + 2 * spacecount + 1];\n        \n       \t...\n\n        ans[pos] = '\\0';\n\n        return string(ans);\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n修改完后就没有问题了，最终已 ac 的实现代码如下：\n\nclass solution {\npublic:\n    string replacespace(string s) {\n\n        // 统计空格数量\n        int len = s.size();\n        int spacecount = 0;\n        int pos = 0;\n        \n        for(int i = 0; i < len; ++i){\n            if(s[i] == ' '){\n                ++spacecount;\n            }\n        }\n\n\n        // 拓容\n        char ans[len + 2 * spacecount + 1];\n\n        // 循环填充\n        for(int i = 0; i < len; ++i){\n            \n            if(s[i] == ' '){\n                ans[pos++] = '%';\n                ans[pos++] = '2';\n                ans[pos++] = '0';\n            }else{\n                ans[pos++] = s[i];\n            }\n            \n        }\n\n        ans[pos] = '\\0';\n\n        return string(ans);\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# 录后想法\n\n>  * 双指针\n>  * resize()\n\n\n\nclass solution {\npublic:\n    string replacespace(string s) {\n\n        // 统计空格数量\n        int oldlen = s.size();\n        int newlen;\n        int spacecount = 0;\n        \n        for(int i = 0; i < oldlen; ++i){\n            if(s[i] == ' '){\n                ++spacecount;\n            }\n        }\n\n        newlen = oldlen + 2 * spacecount;\n\n        // 拓容\n        s.resize(newlen);\n\n        // 循环填充\n        // fast 指向原数组的最后一个位置\n        // slow 指向新数组的最后一个位置\n        for(int fast = oldlen - 1,slow = newlen - 1; fast >= 0;){\n            \n            if(s[fast] == ' '){\n                s[slow--] = '0';\n                s[slow--] = '2';\n                s[slow--] = '%';\n                fast--;\n            }else{\n                s[slow--] = s[fast--];\n            }\n        }\n\n        return s;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# 151. 翻转字符串里的单词\n\n * 题目：151. 翻转字符串里的单词\n\n * 讲解：文章讲解、视频讲解\n\n * 建议：这道题目基本把 刚刚做过的字符串操作 都覆盖了，不过就算知道解题思路，本题代码并不容易写，要多练一练。\n\n\n# 录前想法\n\n 1. 去除多余的空格\n 2. 整体反转\n 3. 单词反转\n\n已经 ac (✔️)\n\nclass solution {\npublic:\n    string reversewords(string s) {\n        \n        int len = s.size();\n\n        // 1.双指针移动删除空格\n        // 对空格去重\n        int fast = 0,slow = 0;\n        // 1.1 删除\n        // 找到第一个不为空格的元素\n        while(s[fast] == ' ' && fast < len){fast++;}\n        // 1.2 中间遇到空格\n        while(fast < len){\n            \n            if(s[fast] != ' ' || (s[fast] == ' ' && s[fast-1] != ' ' && fast != 0)){\n                s[slow++] = s[fast++];\n            }else{\n                while(s[fast] == ' ' && fast < len){fast++;}\n            }\n\n        }\n        // 1.3 结尾遇到空格\n        if(s[slow - 1] == ' '){\n            s.resize(slow - 1);\n            len = slow - 1;\n        }else{\n            s.resize(slow);\n            len = slow;\n        }\n\n        // 2. 整体反转\n        reverse(s,0,len-1);\n\n        // 3. 再对每个单词反转\n        int l,r;\n        for(l = 0,r = 0; r < len; ++r){\n\n            if(s[r] == ' '){\n                reverse(s,l,r - 1);\n                l = r + 1;\n            }\n        }\n\n        // 反转最后一个单词\n        reverse(s,l,r - 1);\n\n        return s;\n    }\n\n    // 反转\n    void reverse(string &str,int l,int r){\n        for(;l<r; ++l,--r){\n            swap(str[l],str[r]);\n        }\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n * 时间复杂度: o (n)\n * 空间复杂度: o (1)\n\n\n# 录后想法\n\n思路一致\n\n\n# 总结\n\n删除中间段空格的核心判断代码：理解了 s [fast] 与 s [fast-1]\n\nif(s[fast] != ' ' || (s[fast] == ' ' && s[fast-1] != ' ' && fast != 0))\n\n\n1\n\n\n\n# 剑指 offer58-ii. 左旋转字符串\n\n * 题目：剑指 offer58-ii. 左旋转字符串\n\n * 讲解：文章讲解\n\n * 建议：题解中的解法如果没接触过的话，应该会想不到\n\n\n# 录前想法\n\n 1. 整体反转\n 2. 倒数 k 个字符反转\n 3. 正数 len - k 个字符反转\n\n以下代码已 ac (✔️)\n\nclass solution {\npublic:\n    string reverseleftwords(string s, int n) {\n\n        // abcdefg\n        // gfedc ba\n        // cdefg ab\n\n        // lrloseumgh\n        // hgmu esolrl\n        // umgh lrlose\n\n        int len = s.size();\n        // 整体反转\n        reverse(s,0,len-1);\n\n        // 倒数n个反转\n        reverse(s,len-n,len-1);\n\n        // 0 ~ len - n 反转\n        reverse(s,0,len-n-1);\n\n        return s;\n    }\n\n    void reverse(string &str,int l,int r){\n        for(;l<r;++l,--r){\n            swap(str[l],str[r]);\n        }\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 录后想法\n\n思路一致✌️\n\n\n# 总结\n\n * 关于 char*、char [] 与 string 的初始化及转换\n\n剪枝操作的细节好难，还需要多加练习！",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "Day08-字符串",
      "frontmatter": {
        "title": "Day08-字符串",
        "date": "2023-06-01T12:33:54.000Z",
        "permalink": "/pages/8ef17c/",
        "categories": [
          "算法",
          "算法打卡"
        ],
        "tags": [
          "打卡"
        ]
      },
      "regularPath": "/02.%E7%AE%97%E6%B3%95/01.%E7%AE%97%E6%B3%95%E6%89%93%E5%8D%A1/08.Day08-%E5%AD%97%E7%AC%A6%E4%B8%B2.html",
      "relativePath": "02.算法/01.算法打卡/08.Day08-字符串.md",
      "key": "v-27115b6c",
      "path": "/pages/8ef17c/",
      "headers": [
        {
          "level": 2,
          "title": "28.实现 strStr()",
          "slug": "_28-实现-strstr",
          "normalizedTitle": "28. 实现 strstr ()",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "录前想法",
          "slug": "录前想法",
          "normalizedTitle": "录前想法",
          "charIndex": 139
        },
        {
          "level": 3,
          "title": "录后想法",
          "slug": "录后想法",
          "normalizedTitle": "录后想法",
          "charIndex": 167
        },
        {
          "level": 3,
          "title": "总结",
          "slug": "总结",
          "normalizedTitle": "总结",
          "charIndex": 1761
        },
        {
          "level": 2,
          "title": "459.重复的子字符串",
          "slug": "_459-重复的子字符串",
          "normalizedTitle": "459. 重复的子字符串",
          "charIndex": 20
        },
        {
          "level": 3,
          "title": "录前想法",
          "slug": "录前想法-2",
          "normalizedTitle": "录前想法",
          "charIndex": 139
        },
        {
          "level": 3,
          "title": "录后想法",
          "slug": "录后想法-2",
          "normalizedTitle": "录后想法",
          "charIndex": 167
        },
        {
          "level": 3,
          "title": "总结",
          "slug": "总结-2",
          "normalizedTitle": "总结",
          "charIndex": 1761
        },
        {
          "level": 2,
          "title": "总结",
          "slug": "总结-3",
          "normalizedTitle": "总结",
          "charIndex": 1761
        }
      ],
      "excerpt": "<blockquote>\n<p>28. 实现 strStr ()、 459. 重复的子字符串</p>\n</blockquote>\n",
      "lastUpdated": "6/2/2023, 6:34:00 PM",
      "lastUpdatedTimestamp": 1685702040000,
      "headersStr": "28.实现 strStr() 录前想法 录后想法 总结 459.重复的子字符串 录前想法 录后想法 总结 总结",
      "content": "> 28. 实现 strStr ()、 459. 重复的子字符串\n\n\n# 28. 实现 strStr ()\n\n * 题目：28. 实现 strStr ()\n * 讲解：文章讲解、视频讲解 (理论)、视频讲解 (next 数组)\n * 要求：理解大名鼎鼎的 KMP 算法\n\n\n# 录前想法\n\n只想出暴力 O (n^2) 的解法\n\n\n# 录后想法\n\n看完讲解，一开始对求 next 数组部分的初始化变量非常不解，尤其是两个 \"末尾\"\n\n难点我觉得在于单个变量包含了两种含义，既是前缀头又是最长相等前后缀，没绕明白\n\n再摸索摸索\n\n自己慢慢磨出了代码，已 AC (✔️)\n\nclass Solution {\npublic:\n    int strStr(string haystack, string needle) {\n\n        int needleLen = needle.size();\n        int haystackLen = haystack.size();\n        int next[needleLen];\n\n        // 求出next数组\n        getNext(next,needle);\n\n        // 遍历\n        // i 控制文本串\n        // j 控制模式串\n        for(int i = 0,j = 0; i < haystackLen; ++i){\n            \n            // 匹配不相等\n            while(haystack[i] != needle[j] && j > 0){\n                j = next[j - 1];\n            }\n\n            // 匹配\n            if(haystack[i] == needle[j]){\n                j++;\n            }\n\n            // 以满足返回\n            if(j == needleLen){\n                // i = 8\n                // needleLen = 6\n                // ans = 3\n\n                return i - needleLen + 1;\n            }\n        }\n\n        return -1;\n    }\n\n    // 求next数组\n    void getNext(int *next,string needle){\n\n        int p = 0; // 定义前缀头和记录最长相等前后缀记录\n        next[0] = 0;\n\n        // 定义后缀表尾和控制整体模式串\n        for(int s = 1;s < needle.size(); ++s){\n            \n            // 不匹配时，回退\n            while(p > 0 && needle[p] != needle[s]){\n                p = next[p-1];\n            }\n\n            // 匹配\n            if(needle[p] == needle[s]){\n                ++p;\n            }\n\n            // 更新\n            next[s] = p;\n        }\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n\n\n\n# 总结\n\n * 回退部分确实如卡哥所说一开始写的时 if 不是 while😂\n\n\n# 459. 重复的子字符串\n\n * 题目：459. 重复的子字符串\n * 讲解：文章讲解、视频讲解\n * 要求：KMP 算法的应用\n\n\n# 录前想法\n\n\n# 录后想法\n\n\n# 总结\n\n\n# 总结\n\n * 数组初始化的细节：\n\nint a[n]={0}; // 注意n必须为const类型，否则错误\n\n\n1\n",
      "normalizedContent": "> 28. 实现 strstr ()、 459. 重复的子字符串\n\n\n# 28. 实现 strstr ()\n\n * 题目：28. 实现 strstr ()\n * 讲解：文章讲解、视频讲解 (理论)、视频讲解 (next 数组)\n * 要求：理解大名鼎鼎的 kmp 算法\n\n\n# 录前想法\n\n只想出暴力 o (n^2) 的解法\n\n\n# 录后想法\n\n看完讲解，一开始对求 next 数组部分的初始化变量非常不解，尤其是两个 \"末尾\"\n\n难点我觉得在于单个变量包含了两种含义，既是前缀头又是最长相等前后缀，没绕明白\n\n再摸索摸索\n\n自己慢慢磨出了代码，已 ac (✔️)\n\nclass solution {\npublic:\n    int strstr(string haystack, string needle) {\n\n        int needlelen = needle.size();\n        int haystacklen = haystack.size();\n        int next[needlelen];\n\n        // 求出next数组\n        getnext(next,needle);\n\n        // 遍历\n        // i 控制文本串\n        // j 控制模式串\n        for(int i = 0,j = 0; i < haystacklen; ++i){\n            \n            // 匹配不相等\n            while(haystack[i] != needle[j] && j > 0){\n                j = next[j - 1];\n            }\n\n            // 匹配\n            if(haystack[i] == needle[j]){\n                j++;\n            }\n\n            // 以满足返回\n            if(j == needlelen){\n                // i = 8\n                // needlelen = 6\n                // ans = 3\n\n                return i - needlelen + 1;\n            }\n        }\n\n        return -1;\n    }\n\n    // 求next数组\n    void getnext(int *next,string needle){\n\n        int p = 0; // 定义前缀头和记录最长相等前后缀记录\n        next[0] = 0;\n\n        // 定义后缀表尾和控制整体模式串\n        for(int s = 1;s < needle.size(); ++s){\n            \n            // 不匹配时，回退\n            while(p > 0 && needle[p] != needle[s]){\n                p = next[p-1];\n            }\n\n            // 匹配\n            if(needle[p] == needle[s]){\n                ++p;\n            }\n\n            // 更新\n            next[s] = p;\n        }\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n\n\n\n# 总结\n\n * 回退部分确实如卡哥所说一开始写的时 if 不是 while😂\n\n\n# 459. 重复的子字符串\n\n * 题目：459. 重复的子字符串\n * 讲解：文章讲解、视频讲解\n * 要求：kmp 算法的应用\n\n\n# 录前想法\n\n\n# 录后想法\n\n\n# 总结\n\n\n# 总结\n\n * 数组初始化的细节：\n\nint a[n]={0}; // 注意n必须为const类型，否则错误\n\n\n1\n",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "Day09-栈与队列",
      "frontmatter": {
        "title": "Day09-栈与队列",
        "date": "2023-06-02T09:38:28.000Z",
        "permalink": "/pages/5b91fa/",
        "categories": [
          "算法",
          "算法打卡"
        ],
        "tags": [
          "打卡"
        ]
      },
      "regularPath": "/02.%E7%AE%97%E6%B3%95/01.%E7%AE%97%E6%B3%95%E6%89%93%E5%8D%A1/09.Day09-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97.html",
      "relativePath": "02.算法/01.算法打卡/09.Day09-栈与队列.md",
      "key": "v-ea597386",
      "path": "/pages/5b91fa/",
      "headers": [
        {
          "level": 2,
          "title": "理论基础",
          "slug": "理论基础",
          "normalizedTitle": "理论基础",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "三个常见STL版本",
          "slug": "三个常见stl版本",
          "normalizedTitle": "三个常见 stl 版本",
          "charIndex": 44
        },
        {
          "level": 3,
          "title": "四个问题",
          "slug": "四个问题",
          "normalizedTitle": "四个问题",
          "charIndex": 337
        },
        {
          "level": 2,
          "title": "232.用栈实现队列",
          "slug": "_232-用栈实现队列",
          "normalizedTitle": "232. 用栈实现队列",
          "charIndex": 7
        },
        {
          "level": 3,
          "title": "录前想法",
          "slug": "录前想法",
          "normalizedTitle": "录前想法",
          "charIndex": 1338
        },
        {
          "level": 3,
          "title": "录后想法",
          "slug": "录后想法",
          "normalizedTitle": "录后想法",
          "charIndex": 1381
        },
        {
          "level": 2,
          "title": "225. 用队列实现栈",
          "slug": "_225-用队列实现栈",
          "normalizedTitle": "225. 用队列实现栈",
          "charIndex": 19
        },
        {
          "level": 3,
          "title": "录前想法",
          "slug": "录前想法-2",
          "normalizedTitle": "录前想法",
          "charIndex": 1338
        },
        {
          "level": 3,
          "title": "录后想法",
          "slug": "录后想法-2",
          "normalizedTitle": "录后想法",
          "charIndex": 1381
        },
        {
          "level": 2,
          "title": "总结",
          "slug": "总结",
          "normalizedTitle": "总结",
          "charIndex": 3213
        }
      ],
      "excerpt": "<blockquote>\n<p>理论基础、232. 用栈实现队列、225. 用队列实现栈</p>\n</blockquote>\n",
      "lastUpdated": "6/3/2023, 3:44:40 PM",
      "lastUpdatedTimestamp": 1685778280000,
      "headersStr": "理论基础 三个常见STL版本 四个问题 232.用栈实现队列 录前想法 录后想法 225. 用队列实现栈 录前想法 录后想法 总结",
      "content": "> 理论基础、232. 用栈实现队列、225. 用队列实现栈\n\n\n# 理论基础\n\n\n# 三个常见 STL 版本\n\n 1. HP STL 其他版本的 C++ STL，一般是以 HP STL 为蓝本实现出来的，HP STL 是 C++ STL 的第一个实现版本，而且开放源代码。\n\n 2. P.J.Plauger STL 由 P.J.Plauger 参照 HP STL 实现出来的，被 Visual C++ 编译器所采用，不是开源的。\n\n 3. SGI STL 由 Silicon Graphics Computer Systems 公司参照 HP STL 实现，被 Linux 的 C++ 编译器 GCC 所采用，SGI STL 是开源软件，源码可读性甚高。(主要)\n\n\n# 四个问题\n\n>  1. C++ 中 stack 是容器么？\n>  2. 我们使用的 stack 是属于哪个版本的 STL？\n>  3. 我们使用的 STL 中 stack 是如何实现的？\n>  4. stack 提供迭代器来遍历 stack 空间么？\n\n 1. C++ 中 stack 是容器么？\n    \n    不属于容器，栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。\n\n所以 STL 中栈往往不被归类为容器，而被归类为 container adapter（容器适配器）。\n\n 2. 我们使用的 stack 是属于哪个版本的 STL？\n\n * Visual C++ 编译器所采用 P.J.Plauger STL\n\n * Linux 的 C++ 编译器 GCC 所采用 SGI STL\n\n 3. 我们使用的 STL 中 stack 是如何实现的？\n\n栈的底层实现可以是 vector，deque，list 都是可以的， 主要就是数组和链表的底层实现。\n\n\n\n我们常用的 SGI STL，默认是以 deque 为缺省情况下栈和队列的底层结构。\n\ndeque 是一个双向队列，只要封住一段，只开通另一端就可以实现栈的逻辑了。\n\n----------------------------------------\n\n我们也可以指定 vector 为栈的底层实现，初始化语句如下：\n\nstd::stack<int, std::vector<int> > third;  // 使用vector为底层容器的栈\n\n\n1\n\n\n也可以指定 list 为起底层实现，初始化 queue 的语句如下：\n\nstd::queue<int, std::list<int>> third; // 定义以list为底层容器的队列\n\n\n1\n\n 4. stack 提供迭代器来遍历 stack 空间么？\n\nNO，栈提供 push 和 pop 等等接口，所有元素必须符合先进后出规则，所以栈不提供走访功能，也不提供迭代器 (iterator)。 不像是 set 或者 map 提供迭代器 iterator 来遍历所有元素。\n\n\n# 232. 用栈实现队列\n\n * 题目：232. 用栈实现队列\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：模拟过程\n\n\n# 录前想法\n\n使用两个栈实现单向的队列（先进先出），没有自己动手实现，讲解视频\n\n\n# 录后想法\n\n * 双栈（进出栈的设计）\n * peek () 函数设计时的巧用\n\n\n\n以下时看完讲解后的实现代码，已 AC (✔️)\n\nclass MyQueue {\npublic:\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n        stIn.push(x);\n    }\n    \n    int pop() {\n        // 输出栈为空\n        if(stOut.empty()){\n            // 将输入栈全部放入\n            while(!stIn.empty()){\n                stOut.push(stIn.top());\n                stIn.pop();\n            }\n        }\n        int result = stOut.top();\n        stOut.pop();\n        return result;\n    }\n    \n    int peek() {\n        // 先从输出栈中弹出\n        int tmp = this->pop();\n        // 再放入输出栈\n        stOut.push(tmp);\n        return tmp;\n    }\n    \n    bool empty() {\n        return stIn.empty() && stOut.empty();\n    }\nprivate:\n    stack<int> stIn;\n    stack<int> stOut;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# 225. 用队列实现栈\n\n * 题目：225. 用队列实现栈\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：用一个队列模拟栈\n\n\n# 录前想法\n\n只考虑了使用一个队列模拟栈的情况，核心还是出栈的设计，我的思路是通过出不停的出队列和入队列将最后一个元素推到第一个元素的位置上，再进行操作\n\n * 1 2 3\n * 2 3 1\n * 3 1 2\n\n以下是实现代码，已 AC (✔️)\n\nclass MyStack {\npublic:\n    MyStack() {\n\n    }\n    \n    void push(int x) {\n        q.push(x);\n    }\n    \n    int pop() {\n        int size = q.size();\n        int result = q.back();\n\n        // 循环进出，暴露出最后一个元素\n        while(--size){\n            // 获取第一个元素\n            int tmp = q.front();\n            // 第一个元素出队\n            q.pop();\n            // 将其再插入末尾\n            q.push(tmp);\n        }\n\n        // 删除最后一个元素\n        q.pop();\n\n        return result;\n    }\n    \n    int top() {\n        return q.back();\n    }\n    \n    bool empty() {\n        return q.empty();\n    }\nprivate:\n    queue<int> q;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n * 时间复杂度: push 为 O (n)，其他为 O (1)\n * 空间复杂度: O (n)\n\n\n# 录后想法\n\n和卡哥思路一致✌️\n\n\n# 总结\n\nQueue类 成员函数如下：\n\n * back () 返回最后一个元素\n * empty () 如果队列空则返回真\n * front () 返回第一个元素\n * pop () 删除第一个元素\n * push () 在末尾加入一个元素\n * size () 返回队列中元素的个数\n\nStack类 成员函数如下：\n\n * 出栈：push ()\n * 压栈：pop ()\n * 栈是否为空：empty ()\n * 栈的大小：size ()\n * 访问栈顶：top ()",
      "normalizedContent": "> 理论基础、232. 用栈实现队列、225. 用队列实现栈\n\n\n# 理论基础\n\n\n# 三个常见 stl 版本\n\n 1. hp stl 其他版本的 c++ stl，一般是以 hp stl 为蓝本实现出来的，hp stl 是 c++ stl 的第一个实现版本，而且开放源代码。\n\n 2. p.j.plauger stl 由 p.j.plauger 参照 hp stl 实现出来的，被 visual c++ 编译器所采用，不是开源的。\n\n 3. sgi stl 由 silicon graphics computer systems 公司参照 hp stl 实现，被 linux 的 c++ 编译器 gcc 所采用，sgi stl 是开源软件，源码可读性甚高。(主要)\n\n\n# 四个问题\n\n>  1. c++ 中 stack 是容器么？\n>  2. 我们使用的 stack 是属于哪个版本的 stl？\n>  3. 我们使用的 stl 中 stack 是如何实现的？\n>  4. stack 提供迭代器来遍历 stack 空间么？\n\n 1. c++ 中 stack 是容器么？\n    \n    不属于容器，栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。\n\n所以 stl 中栈往往不被归类为容器，而被归类为 container adapter（容器适配器）。\n\n 2. 我们使用的 stack 是属于哪个版本的 stl？\n\n * visual c++ 编译器所采用 p.j.plauger stl\n\n * linux 的 c++ 编译器 gcc 所采用 sgi stl\n\n 3. 我们使用的 stl 中 stack 是如何实现的？\n\n栈的底层实现可以是 vector，deque，list 都是可以的， 主要就是数组和链表的底层实现。\n\n\n\n我们常用的 sgi stl，默认是以 deque 为缺省情况下栈和队列的底层结构。\n\ndeque 是一个双向队列，只要封住一段，只开通另一端就可以实现栈的逻辑了。\n\n----------------------------------------\n\n我们也可以指定 vector 为栈的底层实现，初始化语句如下：\n\nstd::stack<int, std::vector<int> > third;  // 使用vector为底层容器的栈\n\n\n1\n\n\n也可以指定 list 为起底层实现，初始化 queue 的语句如下：\n\nstd::queue<int, std::list<int>> third; // 定义以list为底层容器的队列\n\n\n1\n\n 4. stack 提供迭代器来遍历 stack 空间么？\n\nno，栈提供 push 和 pop 等等接口，所有元素必须符合先进后出规则，所以栈不提供走访功能，也不提供迭代器 (iterator)。 不像是 set 或者 map 提供迭代器 iterator 来遍历所有元素。\n\n\n# 232. 用栈实现队列\n\n * 题目：232. 用栈实现队列\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：模拟过程\n\n\n# 录前想法\n\n使用两个栈实现单向的队列（先进先出），没有自己动手实现，讲解视频\n\n\n# 录后想法\n\n * 双栈（进出栈的设计）\n * peek () 函数设计时的巧用\n\n\n\n以下时看完讲解后的实现代码，已 ac (✔️)\n\nclass myqueue {\npublic:\n    myqueue() {\n\n    }\n    \n    void push(int x) {\n        stin.push(x);\n    }\n    \n    int pop() {\n        // 输出栈为空\n        if(stout.empty()){\n            // 将输入栈全部放入\n            while(!stin.empty()){\n                stout.push(stin.top());\n                stin.pop();\n            }\n        }\n        int result = stout.top();\n        stout.pop();\n        return result;\n    }\n    \n    int peek() {\n        // 先从输出栈中弹出\n        int tmp = this->pop();\n        // 再放入输出栈\n        stout.push(tmp);\n        return tmp;\n    }\n    \n    bool empty() {\n        return stin.empty() && stout.empty();\n    }\nprivate:\n    stack<int> stin;\n    stack<int> stout;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# 225. 用队列实现栈\n\n * 题目：225. 用队列实现栈\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：用一个队列模拟栈\n\n\n# 录前想法\n\n只考虑了使用一个队列模拟栈的情况，核心还是出栈的设计，我的思路是通过出不停的出队列和入队列将最后一个元素推到第一个元素的位置上，再进行操作\n\n * 1 2 3\n * 2 3 1\n * 3 1 2\n\n以下是实现代码，已 ac (✔️)\n\nclass mystack {\npublic:\n    mystack() {\n\n    }\n    \n    void push(int x) {\n        q.push(x);\n    }\n    \n    int pop() {\n        int size = q.size();\n        int result = q.back();\n\n        // 循环进出，暴露出最后一个元素\n        while(--size){\n            // 获取第一个元素\n            int tmp = q.front();\n            // 第一个元素出队\n            q.pop();\n            // 将其再插入末尾\n            q.push(tmp);\n        }\n\n        // 删除最后一个元素\n        q.pop();\n\n        return result;\n    }\n    \n    int top() {\n        return q.back();\n    }\n    \n    bool empty() {\n        return q.empty();\n    }\nprivate:\n    queue<int> q;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n * 时间复杂度: push 为 o (n)，其他为 o (1)\n * 空间复杂度: o (n)\n\n\n# 录后想法\n\n和卡哥思路一致✌️\n\n\n# 总结\n\nqueue类 成员函数如下：\n\n * back () 返回最后一个元素\n * empty () 如果队列空则返回真\n * front () 返回第一个元素\n * pop () 删除第一个元素\n * push () 在末尾加入一个元素\n * size () 返回队列中元素的个数\n\nstack类 成员函数如下：\n\n * 出栈：push ()\n * 压栈：pop ()\n * 栈是否为空：empty ()\n * 栈的大小：size ()\n * 访问栈顶：top ()",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "Day12-二叉树",
      "frontmatter": {
        "title": "Day12-二叉树",
        "date": "2023-06-06T14:54:40.000Z",
        "permalink": "/pages/e42f06/",
        "categories": [
          "算法",
          "算法打卡"
        ],
        "tags": [
          "打卡"
        ]
      },
      "regularPath": "/02.%E7%AE%97%E6%B3%95/01.%E7%AE%97%E6%B3%95%E6%89%93%E5%8D%A1/12.Day12-%E4%BA%8C%E5%8F%89%E6%A0%91.html",
      "relativePath": "02.算法/01.算法打卡/12.Day12-二叉树.md",
      "key": "v-ec50e718",
      "path": "/pages/e42f06/",
      "headers": [
        {
          "level": 2,
          "title": "理论基础",
          "slug": "理论基础",
          "normalizedTitle": "理论基础",
          "charIndex": 2
        },
        {
          "level": 2,
          "title": "递归遍历",
          "slug": "递归遍历",
          "normalizedTitle": "递归遍历",
          "charIndex": 7
        },
        {
          "level": 2,
          "title": "迭代遍历",
          "slug": "迭代遍历",
          "normalizedTitle": "迭代遍历",
          "charIndex": 13
        },
        {
          "level": 2,
          "title": "统一迭代",
          "slug": "统一迭代",
          "normalizedTitle": "统一迭代",
          "charIndex": 18
        }
      ],
      "excerpt": "<blockquote>\n<p>理论基础、递归遍历 、迭代遍历、统一迭代</p>\n</blockquote>\n",
      "headersStr": "理论基础 递归遍历 迭代遍历 统一迭代",
      "content": "> 理论基础、递归遍历 、迭代遍历、统一迭代\n\n\n# 理论基础\n\n\n# 递归遍历\n\n\n# 迭代遍历\n\n\n# 统一迭代",
      "normalizedContent": "> 理论基础、递归遍历 、迭代遍历、统一迭代\n\n\n# 理论基础\n\n\n# 递归遍历\n\n\n# 迭代遍历\n\n\n# 统一迭代",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "Day11-栈与队列",
      "frontmatter": {
        "title": "Day11-栈与队列",
        "date": "2023-06-05T16:01:03.000Z",
        "permalink": "/pages/9f1ed7/",
        "categories": [
          "算法",
          "算法打卡"
        ],
        "tags": [
          "打卡"
        ]
      },
      "regularPath": "/02.%E7%AE%97%E6%B3%95/01.%E7%AE%97%E6%B3%95%E6%89%93%E5%8D%A1/11.Day11-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97.html",
      "relativePath": "02.算法/01.算法打卡/11.Day11-栈与队列.md",
      "key": "v-ea742706",
      "path": "/pages/9f1ed7/",
      "headers": [
        {
          "level": 2,
          "title": "239.滑动窗口最大值",
          "slug": "_239-滑动窗口最大值",
          "normalizedTitle": "239. 滑动窗口最大值",
          "charIndex": 7
        },
        {
          "level": 3,
          "title": "录前想法",
          "slug": "录前想法",
          "normalizedTitle": "录前想法",
          "charIndex": 132
        },
        {
          "level": 3,
          "title": "录后想法",
          "slug": "录后想法",
          "normalizedTitle": "录后想法",
          "charIndex": 203
        },
        {
          "level": 3,
          "title": "总结",
          "slug": "总结",
          "normalizedTitle": "总结",
          "charIndex": 54
        },
        {
          "level": 2,
          "title": "347.前 K 个高频元素",
          "slug": "_347-前-k-个高频元素",
          "normalizedTitle": "347. 前 k 个高频元素",
          "charIndex": 30
        },
        {
          "level": 3,
          "title": "录前想法",
          "slug": "录前想法-2",
          "normalizedTitle": "录前想法",
          "charIndex": 132
        },
        {
          "level": 3,
          "title": "录后想法",
          "slug": "录后想法-2",
          "normalizedTitle": "录后想法",
          "charIndex": 203
        },
        {
          "level": 3,
          "title": "总结",
          "slug": "总结-2",
          "normalizedTitle": "总结",
          "charIndex": 54
        },
        {
          "level": 2,
          "title": "总结",
          "slug": "总结-3",
          "normalizedTitle": "总结",
          "charIndex": 54
        }
      ],
      "excerpt": "<div class=\"custom-block tip\"><p class=\"custom-block-title\">提示</p>\n<ul>\n<li>\n<p>239. 滑动窗口最大值【<strong>单调队列</strong>】</p>\n</li>\n<li>\n<p>347. 前 K 个高频元素【<strong>大小堆</strong>】</p>\n</li>\n<li>\n<p>总结</p>\n</li>\n</ul>\n</div>\n",
      "lastUpdated": "6/5/2023, 8:30:15 PM",
      "lastUpdatedTimestamp": 1685968215000,
      "headersStr": "239.滑动窗口最大值 录前想法 录后想法 总结 347.前 K 个高频元素 录前想法 录后想法 总结 总结",
      "content": "提示\n\n * 239. 滑动窗口最大值【单调队列】\n\n * 347. 前 K 个高频元素【大小堆】\n\n * 总结\n\n\n# 239. 滑动窗口最大值\n\n * 题目：239. 滑动窗口最大值\n * 讲解：文章讲解、视频讲解\n * 要求：需要自己去构造单调队列\n\n\n# 录前想法\n\n使用一个队列，队首为最大值，然后每加入一个值就弹出一个值\n\n有这个思路，卡在了如何维护最大值\n\n没有想到实现的方法...\n\n\n# 录后想法\n\n * push (): 循环挤出前面小于新加入元素\n * pop (): 若最大元素 == 新判断元素，就弹出\n\n根据思路，第一次实现代码，未 AC (❌)\n\nclass Solution {\nprivate:\n    class MyQueue { //单调队列（从大到小）\n        private:\n            deque<int> que;\n        public:\n            void pop(int val){\n                if(!que.empty() && que.front() == val){\n                    que.pop_front();\n                }\n            }\n            void push(int val){\n                while(!que.empty() && que.back() < val){\n                    que.pop_back();\n                }\n                que.push_back(val);\n            }\n\n            int getMaxVlaue(){\n                return que.front();\n            }\n            \n    };\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n\n        MyQueue que;\n        vector<int> ans;\n\n        int len = nums.size();\n        if(len == 1){return nums;}\n\n        for(int i = 0; i < len; ++i){\n\n            if(i < k - 1){\n                que.push(nums[i]);\n            }else{\n                que.pop(nums[i]);\n                que.push(nums[i]);\n                ans.push_back(que.getMaxVlaue());\n            }\n\n        }\n\n        return ans;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n检查问题，发现是在调用队列时出现问题\n\n以下测试用例失败\n\n[7,2,4]\n2\n\n\n1\n2\n\n\n分析发现 pop () 调用不对\n\nint len = nums.size();\nif(len == 1){return nums;}\n\nfor(int i = 0; i < len; ++i){\n\n    if(i < k - 1){\n        que.push(nums[i]);\n    }else{\n        que.pop(nums[i]); // pop出现问题，应该是que.pop(nums[i-k-1]);\n        que.push(nums[i]);\n        ans.push_back(que.getMaxVlaue());\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n参考卡哥的代码修改后，以下代码已 AC (✔️)\n\nclass Solution {\nprivate:\n    class MyQueue{\n        private:\n            deque<int> que;\n        public:\n            void pop(int val){\n                // 队列操作需要判空\n                if(!que.empty() && val == que.front()){\n                    que.pop_front();\n                }\n            }\n            void push(int val){\n                // 挤出前面小于val的数\n                while(!que.empty() && val > que.back()){\n                    que.pop_back();\n                }\n                que.push_back(val);\n            }\n            int front(){\n                return que.front();\n            }\n    };\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        \n        MyQueue que;\n        vector<int> result;\n        \n        // 装入前k个元素\n        for(int i = 0; i < k; ++i){\n            que.push(nums[i]);\n        }\n        // 存储第一个最大值\n        result.push_back(que.front());\n\n        for(int i = k; i < nums.size(); ++i){\n            que.pop(nums[i-k]);\n            que.push(nums[i]);\n            result.push_back(que.front());\n        }\n\n        return result;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n# 总结\n\n双端队列的方法\n\nDEQUE< >       函数\nfront()        返回第一个元素的引用。\nback()         返回最后一个元素的引用。\nassign()       用新元素替换原有内容。\npush_back()    在序列的尾部添加一个元素。\npush_front()   在序列的头部添加一个元素。\npop_back()     移除容器尾部的元素。\npop_front()    移除容器头部的元素。\ninsert()       在指定的位置插入一个或多个元素。\n\n\n# 347. 前 K 个高频元素\n\n * 题目：347. 前 K 个高频元素\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：大 / 小顶堆的应用， 在 C++ 中就是优先级队列\n\n\n# 录前想法\n\n 1. 使用 map 数据结构，key 为元素，val 为元素出现的频率，再排序，获取前 k 个，返回\n 2. 和上面思路类似，使用二位数组 arr [][] 前面为元素，后面为元素出现频率，结果为排序顺序\n\n实现做了实现，也都没有是现成功😓\n\n方法 1，卡在了排序\n\n方法 2，卡在了装入元素部分\n\n\n# 录后想法\n\n卡哥的思路与方法 1 类似，在排序部分使用了大小堆，其实不理解为什么卡哥说大根堆不行，小根堆可以\n\n我理解的是大根堆弹出的前几个元素不就是频率出现最多的值嘛？\n\n测试后发现，确实可以是大根堆，就是大根堆堆的会多，因为小根堆只用维护 k，大根堆需要全部放入堆中再取出。\n\n代码实现思路入下，已 AC (✔️)：\n\nclass Solution {\npublic:\n    // 小顶堆\n    class mycomparison {\n        public:\n            bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {\n                return lhs.second > rhs.second;\n            }\n        };\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n\n        // 定义map\n        unordered_map<int, int> map;\n        // 定义结果集\n        vector<int> result(k);\n\n        // 统计元素出现的频率\n        for (int i = 0; i < nums.size(); i++) {\n            map[nums[i]]++;\n        }\n\n        /*\n            频率排序\n        */\n\n        // 定义小根堆\n        priority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pri_que;\n\n        // 遍历排序\n        for(unordered_map<int,int>::iterator it = map.begin(); it != map.end(); ++it){\n            pri_que.push(*it);\n            // 如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k\n            if(pri_que.size() > k){\n                pri_que.pop();\n            }\n        }\n\n        // 找出前k个(因为是要从高频 -> 低频排序，所以结果集从后往前装)\n        for(int i = k - 1;i >= 0; --i){\n            result[i] = pri_que.top().first;\n            pri_que.pop();\n        }\n\n        return result;\n        \n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\nclass Solution {\npublic:\n    // 大顶堆\n    class mycomparison {\n        public:\n            bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {\n                return lhs.second < rhs.second;\n            }\n        };\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n\n        // 定义map\n        unordered_map<int, int> map;\n        // 定义结果集\n        vector<int> result(k);\n\n        // 统计元素出现的频率\n        for (int i = 0; i < nums.size(); i++) {\n            map[nums[i]]++;\n        }\n\n        /*\n            频率排序\n        */\n\n        // 定义小根堆\n        priority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pri_que;\n\n        // 遍历排序\n        for(unordered_map<int,int>::iterator it = map.begin(); it != map.end(); ++it){\n            pri_que.push(*it);\n            // // 如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k\n            // if(pri_que.size() > k){\n            //     pri_que.pop();\n            // }\n        }\n\n        // 找出前k个(因为是要从高频 -> 低频排序，所以结果集从后往前装)\n        for(int i = 0;i < k; ++i){\n            result[i] = pri_que.top().first;\n            pri_que.pop();\n        }\n\n        return result;\n\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n\n# 总结\n\n * 大 / 小对维护前 k 值的应用\n\n\n# 总结\n\n维护前K值方法\n\n 1. 单调队列【双端队列的使用 deque】\n 2. 大 / 小根堆【priority_queue】",
      "normalizedContent": "提示\n\n * 239. 滑动窗口最大值【单调队列】\n\n * 347. 前 k 个高频元素【大小堆】\n\n * 总结\n\n\n# 239. 滑动窗口最大值\n\n * 题目：239. 滑动窗口最大值\n * 讲解：文章讲解、视频讲解\n * 要求：需要自己去构造单调队列\n\n\n# 录前想法\n\n使用一个队列，队首为最大值，然后每加入一个值就弹出一个值\n\n有这个思路，卡在了如何维护最大值\n\n没有想到实现的方法...\n\n\n# 录后想法\n\n * push (): 循环挤出前面小于新加入元素\n * pop (): 若最大元素 == 新判断元素，就弹出\n\n根据思路，第一次实现代码，未 ac (❌)\n\nclass solution {\nprivate:\n    class myqueue { //单调队列（从大到小）\n        private:\n            deque<int> que;\n        public:\n            void pop(int val){\n                if(!que.empty() && que.front() == val){\n                    que.pop_front();\n                }\n            }\n            void push(int val){\n                while(!que.empty() && que.back() < val){\n                    que.pop_back();\n                }\n                que.push_back(val);\n            }\n\n            int getmaxvlaue(){\n                return que.front();\n            }\n            \n    };\npublic:\n    vector<int> maxslidingwindow(vector<int>& nums, int k) {\n\n        myqueue que;\n        vector<int> ans;\n\n        int len = nums.size();\n        if(len == 1){return nums;}\n\n        for(int i = 0; i < len; ++i){\n\n            if(i < k - 1){\n                que.push(nums[i]);\n            }else{\n                que.pop(nums[i]);\n                que.push(nums[i]);\n                ans.push_back(que.getmaxvlaue());\n            }\n\n        }\n\n        return ans;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n检查问题，发现是在调用队列时出现问题\n\n以下测试用例失败\n\n[7,2,4]\n2\n\n\n1\n2\n\n\n分析发现 pop () 调用不对\n\nint len = nums.size();\nif(len == 1){return nums;}\n\nfor(int i = 0; i < len; ++i){\n\n    if(i < k - 1){\n        que.push(nums[i]);\n    }else{\n        que.pop(nums[i]); // pop出现问题，应该是que.pop(nums[i-k-1]);\n        que.push(nums[i]);\n        ans.push_back(que.getmaxvlaue());\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n参考卡哥的代码修改后，以下代码已 ac (✔️)\n\nclass solution {\nprivate:\n    class myqueue{\n        private:\n            deque<int> que;\n        public:\n            void pop(int val){\n                // 队列操作需要判空\n                if(!que.empty() && val == que.front()){\n                    que.pop_front();\n                }\n            }\n            void push(int val){\n                // 挤出前面小于val的数\n                while(!que.empty() && val > que.back()){\n                    que.pop_back();\n                }\n                que.push_back(val);\n            }\n            int front(){\n                return que.front();\n            }\n    };\npublic:\n    vector<int> maxslidingwindow(vector<int>& nums, int k) {\n        \n        myqueue que;\n        vector<int> result;\n        \n        // 装入前k个元素\n        for(int i = 0; i < k; ++i){\n            que.push(nums[i]);\n        }\n        // 存储第一个最大值\n        result.push_back(que.front());\n\n        for(int i = k; i < nums.size(); ++i){\n            que.pop(nums[i-k]);\n            que.push(nums[i]);\n            result.push_back(que.front());\n        }\n\n        return result;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n# 总结\n\n双端队列的方法\n\ndeque< >       函数\nfront()        返回第一个元素的引用。\nback()         返回最后一个元素的引用。\nassign()       用新元素替换原有内容。\npush_back()    在序列的尾部添加一个元素。\npush_front()   在序列的头部添加一个元素。\npop_back()     移除容器尾部的元素。\npop_front()    移除容器头部的元素。\ninsert()       在指定的位置插入一个或多个元素。\n\n\n# 347. 前 k 个高频元素\n\n * 题目：347. 前 k 个高频元素\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：大 / 小顶堆的应用， 在 c++ 中就是优先级队列\n\n\n# 录前想法\n\n 1. 使用 map 数据结构，key 为元素，val 为元素出现的频率，再排序，获取前 k 个，返回\n 2. 和上面思路类似，使用二位数组 arr [][] 前面为元素，后面为元素出现频率，结果为排序顺序\n\n实现做了实现，也都没有是现成功😓\n\n方法 1，卡在了排序\n\n方法 2，卡在了装入元素部分\n\n\n# 录后想法\n\n卡哥的思路与方法 1 类似，在排序部分使用了大小堆，其实不理解为什么卡哥说大根堆不行，小根堆可以\n\n我理解的是大根堆弹出的前几个元素不就是频率出现最多的值嘛？\n\n测试后发现，确实可以是大根堆，就是大根堆堆的会多，因为小根堆只用维护 k，大根堆需要全部放入堆中再取出。\n\n代码实现思路入下，已 ac (✔️)：\n\nclass solution {\npublic:\n    // 小顶堆\n    class mycomparison {\n        public:\n            bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {\n                return lhs.second > rhs.second;\n            }\n        };\n    vector<int> topkfrequent(vector<int>& nums, int k) {\n\n        // 定义map\n        unordered_map<int, int> map;\n        // 定义结果集\n        vector<int> result(k);\n\n        // 统计元素出现的频率\n        for (int i = 0; i < nums.size(); i++) {\n            map[nums[i]]++;\n        }\n\n        /*\n            频率排序\n        */\n\n        // 定义小根堆\n        priority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pri_que;\n\n        // 遍历排序\n        for(unordered_map<int,int>::iterator it = map.begin(); it != map.end(); ++it){\n            pri_que.push(*it);\n            // 如果堆的大小大于了k，则队列弹出，保证堆的大小一直为k\n            if(pri_que.size() > k){\n                pri_que.pop();\n            }\n        }\n\n        // 找出前k个(因为是要从高频 -> 低频排序，所以结果集从后往前装)\n        for(int i = k - 1;i >= 0; --i){\n            result[i] = pri_que.top().first;\n            pri_que.pop();\n        }\n\n        return result;\n        \n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\nclass solution {\npublic:\n    // 大顶堆\n    class mycomparison {\n        public:\n            bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {\n                return lhs.second < rhs.second;\n            }\n        };\n    vector<int> topkfrequent(vector<int>& nums, int k) {\n\n        // 定义map\n        unordered_map<int, int> map;\n        // 定义结果集\n        vector<int> result(k);\n\n        // 统计元素出现的频率\n        for (int i = 0; i < nums.size(); i++) {\n            map[nums[i]]++;\n        }\n\n        /*\n            频率排序\n        */\n\n        // 定义小根堆\n        priority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pri_que;\n\n        // 遍历排序\n        for(unordered_map<int,int>::iterator it = map.begin(); it != map.end(); ++it){\n            pri_que.push(*it);\n            // // 如果堆的大小大于了k，则队列弹出，保证堆的大小一直为k\n            // if(pri_que.size() > k){\n            //     pri_que.pop();\n            // }\n        }\n\n        // 找出前k个(因为是要从高频 -> 低频排序，所以结果集从后往前装)\n        for(int i = 0;i < k; ++i){\n            result[i] = pri_que.top().first;\n            pri_que.pop();\n        }\n\n        return result;\n\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n\n# 总结\n\n * 大 / 小对维护前 k 值的应用\n\n\n# 总结\n\n维护前k值方法\n\n 1. 单调队列【双端队列的使用 deque】\n 2. 大 / 小根堆【priority_queue】",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "Day10-栈与队列",
      "frontmatter": {
        "title": "Day10-栈与队列",
        "date": "2023-06-03T11:05:34.000Z",
        "permalink": "/pages/51e036/",
        "categories": [
          "算法",
          "算法打卡"
        ],
        "tags": [
          "打卡"
        ]
      },
      "regularPath": "/02.%E7%AE%97%E6%B3%95/01.%E7%AE%97%E6%B3%95%E6%89%93%E5%8D%A1/10.Day10-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97.html",
      "relativePath": "02.算法/01.算法打卡/10.Day10-栈与队列.md",
      "key": "v-7483b8bd",
      "path": "/pages/51e036/",
      "headers": [
        {
          "level": 2,
          "title": "20.有效的括号",
          "slug": "_20-有效的括号",
          "normalizedTitle": "20. 有效的括号",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "录前想法",
          "slug": "录前想法",
          "normalizedTitle": "录前想法",
          "charIndex": 118
        },
        {
          "level": 3,
          "title": "录后想法",
          "slug": "录后想法",
          "normalizedTitle": "录后想法",
          "charIndex": 1411
        },
        {
          "level": 2,
          "title": "1047. 删除字符串中的所有相邻重复项",
          "slug": "_1047-删除字符串中的所有相邻重复项",
          "normalizedTitle": "1047. 删除字符串中的所有相邻重复项",
          "charIndex": 12
        },
        {
          "level": 3,
          "title": "录前想法",
          "slug": "录前想法-2",
          "normalizedTitle": "录前想法",
          "charIndex": 118
        },
        {
          "level": 3,
          "title": "录后想法",
          "slug": "录后想法-2",
          "normalizedTitle": "录后想法",
          "charIndex": 1411
        },
        {
          "level": 2,
          "title": "150. 逆波兰表达式求值",
          "slug": "_150-逆波兰表达式求值",
          "normalizedTitle": "150. 逆波兰表达式求值",
          "charIndex": 33
        },
        {
          "level": 3,
          "title": "录前想法",
          "slug": "录前想法-3",
          "normalizedTitle": "录前想法",
          "charIndex": 118
        },
        {
          "level": 3,
          "title": "录后想法",
          "slug": "录后想法-3",
          "normalizedTitle": "录后想法",
          "charIndex": 1411
        },
        {
          "level": 3,
          "title": "总结",
          "slug": "总结",
          "normalizedTitle": "总结",
          "charIndex": 5807
        }
      ],
      "excerpt": "<blockquote>\n<p>20. 有效的括号、1047. 删除字符串中的所有相邻重复项、150. 逆波兰表达式求值</p>\n</blockquote>\n",
      "lastUpdated": "6/5/2023, 8:30:15 PM",
      "lastUpdatedTimestamp": 1685968215000,
      "headersStr": "20.有效的括号 录前想法 录后想法 1047. 删除字符串中的所有相邻重复项 录前想法 录后想法 150. 逆波兰表达式求值 录前想法 录后想法 总结",
      "content": "> 20. 有效的括号、1047. 删除字符串中的所有相邻重复项、150. 逆波兰表达式求值\n\n\n# 20. 有效的括号\n\n * 题目：20. 有效的括号\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：思考有哪些不匹配的场景\n\n\n# 录前想法\n\n遇到 ([{ 就直接进栈，若遇到 }]) 需要先判断栈是否为空，若为空则直接返回 false，若栈中 top () 不是对应的另一半元素，也直接返回 false\n\n代码实现如下，已 AC (✔️)\n\nclass Solution {\npublic:\n    bool isValid(string str) {\n\n        stack<char> s;\n\n        for(int i = 0; i < str.size(); ++i){\n\n            if(str[i] == '(' || str[i] == '[' || str[i] == '{'){\n                s.push(str[i]);\n                continue;\n            }\n\n            // switch case\n            switch(str[i]){\n                case ')':\n                    if(s.empty() || s.top() != '('){\n                        return false;\n                    }else{\n                        s.pop();\n                    }\n                    break;\n                case ']':\n                    if(s.empty() || s.top() != '['){\n                        return false;\n                    }else{\n                        s.pop();\n                    }\n                    break;\n                case '}':\n                    if(s.empty() || s.top() != '{'){\n                        return false;\n                    }else{\n                        s.pop();\n                    }\n            }\n        }\n\n        return s.empty();\n    }   \n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n * 时间复杂度: O (n)\n * 空间复杂度: O (n)\n\n\n# 录后想法\n\n\n\n卡哥的想法更精炼，没注意到奇数的情况！\n\n根据卡哥的思路，不难写出以下代码，已 AC (✔️)\n\nclass Solution {\npublic:\n    bool isValid(string s) {\n\n        // 排除奇数情况\n        if (s.size() % 2 != 0) return false; \n\n        stack<char> st;\n\n        for(int i = 0; i < s.size(); ++i){\n\n            if(s[i] == '(') st.push(')');\n            else if(s[i] == '[') st.push(']');\n            else if(s[i] == '{') st.push('}');\n            // 若出现') } ] '此时栈为空时 和 栈首不是对应字符时必出错\n            else if(st.empty() || s[i] != st.top()) return false;\n            else st.pop();\n\n        }\n\n        return st.empty();\n    }   \n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n * 时间复杂度: O (n)\n * 空间复杂度: O (n)\n\n\n# 1047. 删除字符串中的所有相邻重复项\n\n * 题目：1047. 删除字符串中的所有相邻重复项\n\n * 讲解：文章讲解、视频讲解\n\n * 建议：要知道栈为什么适合做这种类似于爱消除的操作，因为栈帮助我们记录了 遍历数组当前元素时候，前一个元素是什么。\n\n\n# 录前想法\n\n通过栈来判断前一个元素是否相同\n\n以下是实现代码，未 AC (❌)\n\nclass Solution {\npublic:\n    string removeDuplicates(string s) {\n\n        stack<char> st;\n        int len = s.size();\n\n        if(len == 1){\n            return s;\n        }else{\n            st.push(s[0]);\n        }\n\n        // 使用栈\n        for(int i = 1; i < len; ++i){\n            \n            // 判断前一个元素\n            if(st.top() == s[i]){\n                st.pop();\n            }else{\n                st.push(s[i]);\n                cout << s[i] <<endl;\n            }\n        }\n\n        // 保存结果\n        string result = \"\";\n\n        while(!st.empty()){\n            result += st.top();\n            st.pop();\n        }\n\n        reverse (result.begin(), result.end());\n\n        return result;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n经过一段时间的调试，发现问题在空栈时就去读取栈内元素，应该先判断栈是否为空\n\n修改后，已 AC (✔️)\n\n// 使用栈\nfor(int i = 0; i <  s.size(); ++i){\n\n\t// 判断前一个元素\n\tif(st.empty() || st.top() != s[i]){\n\t\tst.push(s[i]);\n\t}else{\n\t\tst.pop();\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 录后想法\n\n思路一致，在 CPP 语法上可以修改遍历过程\n\nfor (char s : S) {\n    if (st.empty() || s != st.top()) {\n        st.push(s);\n    } else {\n        st.pop(); // s 与 st.top()相等的情况\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 150. 逆波兰表达式求值\n\n * 题目：150. 逆波兰表达式求值\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：先看视频，了解思路再去做题\n\n\n# 录前想法\n\n 1. 遇到数组压入栈\n 2. 遇到符号出栈做相应运算\n 3. 在压入栈\n\n以下是实现代码，已 AC (✔️)\n\nclass Solution {\npublic:\n    int evalRPN(vector<string>& tokens) {\n\n        // 栈\n        stack<string> st;\n        int tmp = 0;\n\n        for(string str : tokens){\n            \n           if (str == \"+\") {\n                tmp = stoi(st.top());\n                st.pop();\n                tmp += stoi(st.top());\n                st.pop();\n                st.push(to_string(tmp));\n            }else if(str == \"-\"){\n                tmp = stoi(st.top());\n                st.pop();\n                tmp = stoi(st.top()) - tmp;\n                st.pop();\n                st.push(to_string(tmp));\n            }else if(str == \"*\"){\n                tmp = stoi(st.top());\n                st.pop();\n                tmp *= stoi(st.top());\n                st.pop();\n                st.push(to_string(tmp));\n            }else if(str == \"/\"){\n                tmp = stoi(st.top());\n                st.pop();\n                tmp = stoi(st.top()) / tmp;\n                st.pop();\n                st.push(to_string(tmp));\n            }else{\n                st.push(str);  \n            }\n        }\n\n        return stoi(st.top());\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 录后想法\n\n * 这就是代码之间的差距嘛😂，卡哥写的确实看的舒服，学习了\n\nclass Solution {\npublic:\n    int evalRPN(vector<string>& tokens) {\n        // 力扣修改了后台测试数据，需要用longlong\n        stack<long long> st; \n        for (int i = 0; i < tokens.size(); i++) {\n            if (tokens[i] == \"+\" || tokens[i] == \"-\" || tokens[i] == \"*\" || tokens[i] == \"/\") {\n                long long num1 = st.top();\n                st.pop();\n                long long num2 = st.top();\n                st.pop();\n                if (tokens[i] == \"+\") st.push(num2 + num1);\n                if (tokens[i] == \"-\") st.push(num2 - num1);\n                if (tokens[i] == \"*\") st.push(num2 * num1);\n                if (tokens[i] == \"/\") st.push(num2 / num1);\n            } else {\n                st.push(stoll(tokens[i]));\n            }\n        }\n\n        int result = st.top();\n        st.pop(); // 把栈里最后一个元素弹出（其实不弹出也没事）\n        return result;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 总结\n\n * CPP 中字符串与数字的转换\n   \n   * stoi： string 型变量转换为 int 型变量\n   \n   * stol： string 型变量转换为 long 型变量\n   \n   * stoul：string 型变量转换为 unsigned long 型变量\n   \n   * stoll： string 型变量转换为 long long 型变量 (常用)\n   \n   * stoull：string 型变量转换为 unsigned long long 型变量\n   \n   * stof： string 型变量转换为 float 型变量\n   \n   * stod： string 型变量转换为 double 型变量 (常用)\n   \n   * stold：string 型变量转换为 long double 型变量",
      "normalizedContent": "> 20. 有效的括号、1047. 删除字符串中的所有相邻重复项、150. 逆波兰表达式求值\n\n\n# 20. 有效的括号\n\n * 题目：20. 有效的括号\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：思考有哪些不匹配的场景\n\n\n# 录前想法\n\n遇到 ([{ 就直接进栈，若遇到 }]) 需要先判断栈是否为空，若为空则直接返回 false，若栈中 top () 不是对应的另一半元素，也直接返回 false\n\n代码实现如下，已 ac (✔️)\n\nclass solution {\npublic:\n    bool isvalid(string str) {\n\n        stack<char> s;\n\n        for(int i = 0; i < str.size(); ++i){\n\n            if(str[i] == '(' || str[i] == '[' || str[i] == '{'){\n                s.push(str[i]);\n                continue;\n            }\n\n            // switch case\n            switch(str[i]){\n                case ')':\n                    if(s.empty() || s.top() != '('){\n                        return false;\n                    }else{\n                        s.pop();\n                    }\n                    break;\n                case ']':\n                    if(s.empty() || s.top() != '['){\n                        return false;\n                    }else{\n                        s.pop();\n                    }\n                    break;\n                case '}':\n                    if(s.empty() || s.top() != '{'){\n                        return false;\n                    }else{\n                        s.pop();\n                    }\n            }\n        }\n\n        return s.empty();\n    }   \n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n * 时间复杂度: o (n)\n * 空间复杂度: o (n)\n\n\n# 录后想法\n\n\n\n卡哥的想法更精炼，没注意到奇数的情况！\n\n根据卡哥的思路，不难写出以下代码，已 ac (✔️)\n\nclass solution {\npublic:\n    bool isvalid(string s) {\n\n        // 排除奇数情况\n        if (s.size() % 2 != 0) return false; \n\n        stack<char> st;\n\n        for(int i = 0; i < s.size(); ++i){\n\n            if(s[i] == '(') st.push(')');\n            else if(s[i] == '[') st.push(']');\n            else if(s[i] == '{') st.push('}');\n            // 若出现') } ] '此时栈为空时 和 栈首不是对应字符时必出错\n            else if(st.empty() || s[i] != st.top()) return false;\n            else st.pop();\n\n        }\n\n        return st.empty();\n    }   \n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n * 时间复杂度: o (n)\n * 空间复杂度: o (n)\n\n\n# 1047. 删除字符串中的所有相邻重复项\n\n * 题目：1047. 删除字符串中的所有相邻重复项\n\n * 讲解：文章讲解、视频讲解\n\n * 建议：要知道栈为什么适合做这种类似于爱消除的操作，因为栈帮助我们记录了 遍历数组当前元素时候，前一个元素是什么。\n\n\n# 录前想法\n\n通过栈来判断前一个元素是否相同\n\n以下是实现代码，未 ac (❌)\n\nclass solution {\npublic:\n    string removeduplicates(string s) {\n\n        stack<char> st;\n        int len = s.size();\n\n        if(len == 1){\n            return s;\n        }else{\n            st.push(s[0]);\n        }\n\n        // 使用栈\n        for(int i = 1; i < len; ++i){\n            \n            // 判断前一个元素\n            if(st.top() == s[i]){\n                st.pop();\n            }else{\n                st.push(s[i]);\n                cout << s[i] <<endl;\n            }\n        }\n\n        // 保存结果\n        string result = \"\";\n\n        while(!st.empty()){\n            result += st.top();\n            st.pop();\n        }\n\n        reverse (result.begin(), result.end());\n\n        return result;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n经过一段时间的调试，发现问题在空栈时就去读取栈内元素，应该先判断栈是否为空\n\n修改后，已 ac (✔️)\n\n// 使用栈\nfor(int i = 0; i <  s.size(); ++i){\n\n\t// 判断前一个元素\n\tif(st.empty() || st.top() != s[i]){\n\t\tst.push(s[i]);\n\t}else{\n\t\tst.pop();\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 录后想法\n\n思路一致，在 cpp 语法上可以修改遍历过程\n\nfor (char s : s) {\n    if (st.empty() || s != st.top()) {\n        st.push(s);\n    } else {\n        st.pop(); // s 与 st.top()相等的情况\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 150. 逆波兰表达式求值\n\n * 题目：150. 逆波兰表达式求值\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：先看视频，了解思路再去做题\n\n\n# 录前想法\n\n 1. 遇到数组压入栈\n 2. 遇到符号出栈做相应运算\n 3. 在压入栈\n\n以下是实现代码，已 ac (✔️)\n\nclass solution {\npublic:\n    int evalrpn(vector<string>& tokens) {\n\n        // 栈\n        stack<string> st;\n        int tmp = 0;\n\n        for(string str : tokens){\n            \n           if (str == \"+\") {\n                tmp = stoi(st.top());\n                st.pop();\n                tmp += stoi(st.top());\n                st.pop();\n                st.push(to_string(tmp));\n            }else if(str == \"-\"){\n                tmp = stoi(st.top());\n                st.pop();\n                tmp = stoi(st.top()) - tmp;\n                st.pop();\n                st.push(to_string(tmp));\n            }else if(str == \"*\"){\n                tmp = stoi(st.top());\n                st.pop();\n                tmp *= stoi(st.top());\n                st.pop();\n                st.push(to_string(tmp));\n            }else if(str == \"/\"){\n                tmp = stoi(st.top());\n                st.pop();\n                tmp = stoi(st.top()) / tmp;\n                st.pop();\n                st.push(to_string(tmp));\n            }else{\n                st.push(str);  \n            }\n        }\n\n        return stoi(st.top());\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 录后想法\n\n * 这就是代码之间的差距嘛😂，卡哥写的确实看的舒服，学习了\n\nclass solution {\npublic:\n    int evalrpn(vector<string>& tokens) {\n        // 力扣修改了后台测试数据，需要用longlong\n        stack<long long> st; \n        for (int i = 0; i < tokens.size(); i++) {\n            if (tokens[i] == \"+\" || tokens[i] == \"-\" || tokens[i] == \"*\" || tokens[i] == \"/\") {\n                long long num1 = st.top();\n                st.pop();\n                long long num2 = st.top();\n                st.pop();\n                if (tokens[i] == \"+\") st.push(num2 + num1);\n                if (tokens[i] == \"-\") st.push(num2 - num1);\n                if (tokens[i] == \"*\") st.push(num2 * num1);\n                if (tokens[i] == \"/\") st.push(num2 / num1);\n            } else {\n                st.push(stoll(tokens[i]));\n            }\n        }\n\n        int result = st.top();\n        st.pop(); // 把栈里最后一个元素弹出（其实不弹出也没事）\n        return result;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 总结\n\n * cpp 中字符串与数字的转换\n   \n   * stoi： string 型变量转换为 int 型变量\n   \n   * stol： string 型变量转换为 long 型变量\n   \n   * stoul：string 型变量转换为 unsigned long 型变量\n   \n   * stoll： string 型变量转换为 long long 型变量 (常用)\n   \n   * stoull：string 型变量转换为 unsigned long long 型变量\n   \n   * stof： string 型变量转换为 float 型变量\n   \n   * stod： string 型变量转换为 double 型变量 (常用)\n   \n   * stold：string 型变量转换为 long double 型变量",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "Day13-二叉树",
      "frontmatter": {
        "title": "Day13-二叉树",
        "date": "2023-06-06T20:47:28.000Z",
        "permalink": "/pages/e1103c/",
        "categories": [
          "算法",
          "算法打卡"
        ],
        "tags": [
          "打卡"
        ]
      },
      "regularPath": "/02.%E7%AE%97%E6%B3%95/01.%E7%AE%97%E6%B3%95%E6%89%93%E5%8D%A1/13.Day13-%E4%BA%8C%E5%8F%89%E6%A0%91.html",
      "relativePath": "02.算法/01.算法打卡/13.Day13-二叉树.md",
      "key": "v-753871f0",
      "path": "/pages/e1103c/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {}
    },
    {
      "title": "字符串",
      "frontmatter": {
        "title": "字符串",
        "date": "2023-06-02T10:19:59.000Z",
        "permalink": "/pages/d1dc4a/",
        "categories": [
          "算法",
          "经典算法"
        ],
        "tags": [
          "经典算法"
        ]
      },
      "regularPath": "/02.%E7%AE%97%E6%B3%95/02.%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/01.%E5%AD%97%E7%AC%A6%E4%B8%B2.html",
      "relativePath": "02.算法/02.经典算法/01.字符串.md",
      "key": "v-56a89b80",
      "path": "/pages/d1dc4a/",
      "headers": [
        {
          "level": 2,
          "title": "KMP",
          "slug": "kmp",
          "normalizedTitle": "kmp",
          "charIndex": 4
        },
        {
          "level": 3,
          "title": "前置知识",
          "slug": "前置知识",
          "normalizedTitle": "前置知识",
          "charIndex": 20
        },
        {
          "level": 3,
          "title": "能解决什么问题？",
          "slug": "能解决什么问题",
          "normalizedTitle": "能解决什么问题？",
          "charIndex": 937
        },
        {
          "level": 3,
          "title": "next数组",
          "slug": "next数组",
          "normalizedTitle": "next 数组",
          "charIndex": 1226
        },
        {
          "level": 3,
          "title": "完整的KMP流程",
          "slug": "完整的kmp流程",
          "normalizedTitle": "完整的 kmp 流程",
          "charIndex": 1928
        }
      ],
      "excerpt": "<div class=\"custom-block tip\"><p class=\"custom-block-title\">提示</p>\n<p>KMP</p>\n</div>\n",
      "lastUpdated": "6/2/2023, 6:34:00 PM",
      "lastUpdatedTimestamp": 1685702040000,
      "headersStr": "KMP 前置知识 能解决什么问题？ next数组 完整的KMP流程",
      "content": "提示\n\nKMP\n\n\n# KMP\n\n\n# 前置知识\n\n * 文本串 ：\"aabaabaaf\"【普通字符串】\n\n * 模式串 ：\"aabaaf\"【待匹配的字符串】\n\n * 前缀（prefix） ：文本串中包含首字符，不包含尾字符的字符串【ex:\"aabaaf\"】\n   \n   * a\n   * aa\n   * aab\n   * aaba\n   * aabaa\n   * aabaaf（❌）\n\n * 后缀（suffix） ：文本串中不包含首字符，包含尾字符的字符串【ex:\"aabaaf\"】\n   \n   * f\n   * af\n   * aaf\n   * baaaf\n   * abaaf\n   * aabaaf（❌）\n\n * 最长相等前后缀 ：就是前缀等于后缀【ex:\"aabaaf\"】\n   \n   字符串      前缀                   后缀                    最长相等前后缀\n   a        无                    无                     0\n   aa       a                    a                     1\n   aab      a aa                 b ab                  0\n   aaba     a aa aab             a ba aba              1\n   aabaa    a aa aab aaba        a aa baa abaa         2\n   aabaaf   aaa aab aaba aabaa   f af aaf baaf abaaf   0\n\n * 前缀表 ：存放字符串中最长相等前后缀的数组，用于匹配失败后跳转到的位置（KMP 核心）‼️\n   \n   内容   A   A   B   A   A   F\n   下标   0   1   0   1   2   0\n\n * 前缀头 ：【ex:\"aabaaf\"】中 \"aabaaf\"\n\n * 后缀尾 ：【ex:\"aabaaf\"】中 \"aabaaf\"\n\n\n# 能解决什么问题？\n\n大段字符串中，匹配某一小段的字符串，类似 Ctrl+F 的搜索功能\n\n普通的比较，需要一段一段的比较完后移在比较...\n\n文本串:\"aabaabaaf\"\n\n模式串:\"aabaaf\"\n\n> a a b a a b a a f 的匹配过程如下：\n> \n>  1. a a b a a f(❌)，整体后移\n>  2. a a b a a f(❌)，整体后移\n>  3. a a b a a f(❌)，整体后移\n>  4. a a b a a f(✔️)，完成匹配\n\n这显然效率非常低，KMP 算法就是解决了这个问题，核心是不像普通算法的只向后移一位，KMP 通过 next 数组，可以一次移多位来提交效率\n\n\n# next 数组\n\n目的 ：求模式串的前缀表\n\n步骤 ：\n\n 1. 初始化\n 2. 处理前缀不相同\n 3. 处理前缀相同\n 4. 更新 next 数组\n\n// next为next数组\n// str为模式串\nvoid getNext(int *next,string str){\n    // 1. 初始化\n    int p = 0;   // 前缀头 和 最长前后缀相同值\n    next[0] = 0; // 第一个字符没有前缀和后缀，故为0\n    \n    // 遍历真个模式串,从1开始因为第一个字符最长前后缀相同值为0\n    for(int s = 1;pos < str.size();++pos){ // s为后缀尾\n        \n        // 2,处理前缀不相同\n        while(str[s] != str[p] && p > 0){\n            // 回退\n            p = next[p - 1]；\n        }\n        \n        // 3. 处理前缀相同\n        if(str[s] == str[p]){\n            ++p;\n        }\n        \n        // 4. 更新next数组\n        next[s] = p;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n最终得到：\n\n\n\n\n# 完整的 KMP 流程\n\n\n\nclass Solution {\npublic:\n    int strStr(string haystack, string needle) {\n\n        int needleLen = needle.size();\n        int haystackLen = haystack.size();\n        int next[needleLen];\n\n        // 求出next数组\n        getNext(next,needle);\n\n        // 遍历\n        // i 控制文本串\n        // j 控制模式串\n        for(int i = 0,j = 0; i < haystackLen; ++i){\n            \n            // 匹配不相等\n            while(haystack[i] != needle[j] && j > 0){\n                j = next[j - 1];\n            }\n\n            // 匹配\n            if(haystack[i] == needle[j]){\n                j++;\n            }\n\n            // 以满足返回\n            if(j == needleLen){\n                // i = 8\n                // needleLen = 6\n                // ans = 3\n\n                return i - needleLen + 1;\n            }\n        }\n\n        return -1;\n    }\n\n    // 求next数组\n    void getNext(int *next,string needle){\n\n        int p = 0; // 定义前缀头和记录最长相等前后缀记录\n        next[0] = 0;\n\n        // 定义后缀表尾和控制整体模式串\n        for(int s = 1;s < needle.size(); ++s){\n            \n            // 不匹配时，回退\n            while(p > 0 && needle[p] != needle[s]){\n                p = next[p-1];\n            }\n\n            // 匹配\n            if(needle[p] == needle[s]){\n                ++p;\n            }\n\n            // 更新\n            next[s] = p;\n        }\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n",
      "normalizedContent": "提示\n\nkmp\n\n\n# kmp\n\n\n# 前置知识\n\n * 文本串 ：\"aabaabaaf\"【普通字符串】\n\n * 模式串 ：\"aabaaf\"【待匹配的字符串】\n\n * 前缀（prefix） ：文本串中包含首字符，不包含尾字符的字符串【ex:\"aabaaf\"】\n   \n   * a\n   * aa\n   * aab\n   * aaba\n   * aabaa\n   * aabaaf（❌）\n\n * 后缀（suffix） ：文本串中不包含首字符，包含尾字符的字符串【ex:\"aabaaf\"】\n   \n   * f\n   * af\n   * aaf\n   * baaaf\n   * abaaf\n   * aabaaf（❌）\n\n * 最长相等前后缀 ：就是前缀等于后缀【ex:\"aabaaf\"】\n   \n   字符串      前缀                   后缀                    最长相等前后缀\n   a        无                    无                     0\n   aa       a                    a                     1\n   aab      a aa                 b ab                  0\n   aaba     a aa aab             a ba aba              1\n   aabaa    a aa aab aaba        a aa baa abaa         2\n   aabaaf   aaa aab aaba aabaa   f af aaf baaf abaaf   0\n\n * 前缀表 ：存放字符串中最长相等前后缀的数组，用于匹配失败后跳转到的位置（kmp 核心）‼️\n   \n   内容   a   a   b   a   a   f\n   下标   0   1   0   1   2   0\n\n * 前缀头 ：【ex:\"aabaaf\"】中 \"aabaaf\"\n\n * 后缀尾 ：【ex:\"aabaaf\"】中 \"aabaaf\"\n\n\n# 能解决什么问题？\n\n大段字符串中，匹配某一小段的字符串，类似 ctrl+f 的搜索功能\n\n普通的比较，需要一段一段的比较完后移在比较...\n\n文本串:\"aabaabaaf\"\n\n模式串:\"aabaaf\"\n\n> a a b a a b a a f 的匹配过程如下：\n> \n>  1. a a b a a f(❌)，整体后移\n>  2. a a b a a f(❌)，整体后移\n>  3. a a b a a f(❌)，整体后移\n>  4. a a b a a f(✔️)，完成匹配\n\n这显然效率非常低，kmp 算法就是解决了这个问题，核心是不像普通算法的只向后移一位，kmp 通过 next 数组，可以一次移多位来提交效率\n\n\n# next 数组\n\n目的 ：求模式串的前缀表\n\n步骤 ：\n\n 1. 初始化\n 2. 处理前缀不相同\n 3. 处理前缀相同\n 4. 更新 next 数组\n\n// next为next数组\n// str为模式串\nvoid getnext(int *next,string str){\n    // 1. 初始化\n    int p = 0;   // 前缀头 和 最长前后缀相同值\n    next[0] = 0; // 第一个字符没有前缀和后缀，故为0\n    \n    // 遍历真个模式串,从1开始因为第一个字符最长前后缀相同值为0\n    for(int s = 1;pos < str.size();++pos){ // s为后缀尾\n        \n        // 2,处理前缀不相同\n        while(str[s] != str[p] && p > 0){\n            // 回退\n            p = next[p - 1]；\n        }\n        \n        // 3. 处理前缀相同\n        if(str[s] == str[p]){\n            ++p;\n        }\n        \n        // 4. 更新next数组\n        next[s] = p;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n最终得到：\n\n\n\n\n# 完整的 kmp 流程\n\n\n\nclass solution {\npublic:\n    int strstr(string haystack, string needle) {\n\n        int needlelen = needle.size();\n        int haystacklen = haystack.size();\n        int next[needlelen];\n\n        // 求出next数组\n        getnext(next,needle);\n\n        // 遍历\n        // i 控制文本串\n        // j 控制模式串\n        for(int i = 0,j = 0; i < haystacklen; ++i){\n            \n            // 匹配不相等\n            while(haystack[i] != needle[j] && j > 0){\n                j = next[j - 1];\n            }\n\n            // 匹配\n            if(haystack[i] == needle[j]){\n                j++;\n            }\n\n            // 以满足返回\n            if(j == needlelen){\n                // i = 8\n                // needlelen = 6\n                // ans = 3\n\n                return i - needlelen + 1;\n            }\n        }\n\n        return -1;\n    }\n\n    // 求next数组\n    void getnext(int *next,string needle){\n\n        int p = 0; // 定义前缀头和记录最长相等前后缀记录\n        next[0] = 0;\n\n        // 定义后缀表尾和控制整体模式串\n        for(int s = 1;s < needle.size(); ++s){\n            \n            // 不匹配时，回退\n            while(p > 0 && needle[p] != needle[s]){\n                p = next[p-1];\n            }\n\n            // 匹配\n            if(needle[p] == needle[s]){\n                ++p;\n            }\n\n            // 更新\n            next[s] = p;\n        }\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "字符串与字符初始化及转换",
      "frontmatter": {
        "title": "字符串与字符初始化及转换",
        "date": "2023-06-01T17:49:35.000Z",
        "permalink": "/pages/cf07c3/",
        "categories": [
          "CPP",
          "误区总结"
        ],
        "tags": [
          "CPP-误区"
        ]
      },
      "regularPath": "/03.CPP/01.%E8%AF%AF%E5%8C%BA%E6%80%BB%E7%BB%93/01.%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E5%AD%97%E7%AC%A6%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%8A%E8%BD%AC%E6%8D%A2.html",
      "relativePath": "03.CPP/01.误区总结/01.字符串与字符初始化及转换.md",
      "key": "v-612aca70",
      "path": "/pages/cf07c3/",
      "headers": [
        {
          "level": 2,
          "title": "char* 和 char[] 的初始化：",
          "slug": "char-和-char-的初始化",
          "normalizedTitle": "char* 和 char [] 的初始化：",
          "charIndex": 47
        }
      ],
      "excerpt": "<div class=\"custom-block tip\"><p class=\"custom-block-title\">提示</p>\n<p>关于 char*、char [] 与 string 的初始化及转换<br>\n<a href=\"https://zhuanlan.zhihu.com/p/110374182\" target=\"_blank\" rel=\"noopener noreferrer\">参考文章<OutboundLink/></a></p>\n</div>\n",
      "lastUpdated": "6/5/2023, 8:30:15 PM",
      "lastUpdatedTimestamp": 1685968215000,
      "headersStr": "char* 和 char[] 的初始化：",
      "content": "提示\n\n关于 char*、char [] 与 string 的初始化及转换\n参考文章\n\n\n# char* 和 char [] 的初始化：\n\nchar* 是指向字符的指针，可以通过指针赋值或使用字符串字面值来初始化。\nchar [] 是字符数组，可以通过字符串字面值或逐个字符赋值来初始化。\n示例：\n\ncpp\nCopy code\nchar* ptr = \"Hello\"; // 使用字符串字面值初始化 char*\nchar arr [] = \"World\"; // 使用字符串字面值初始化 char []\nstring 和 char* 或 char [] 的转换：\n\nstring 可以通过构造函数或赋值运算符将 char* 或 char [] 转换为 string。\nchar* 或 char [] 可以使用 c_str () 方法将其转换为 const char*，以便与接受 C 风格字符串的函数兼容。\n示例：\n\ncpp\nCopy code\nstring str = \"Hello\"; // 使用字符串字面值初始化 string\nconst char* cstr = str.c_str (); // 转换为 const char*\n\nstring newStr = \"World\";\nconst char* newCstr = newStr.c_str (); // 转换为 const char*\n\nchar arr[] = \"Hello\";\nstring arrStr (arr); // 将字符数组转换为 string\n\nchar* ptr = new char[10];\nstrcpy(ptr, \"World\");\nstring ptrStr (ptr); // 将字符指针转换为 string\n\ndelete [] ptr; // 释放内存\n注意字符串的结束符：\n\nchar [] 必须包含字符串结束符 '\\0'，否则会导致字符串操作函数无法正常工作。\nstring 类型会自动处理字符串结束符，不需要手动添加。\n示例：\n\ncpp\nCopy code\nchar arr [] = \"Hello\"; // 包含 '\\0'\nchar arr2 [] = {'H', 'e', 'l', 'l', 'o'}; // 不包含 '\\0'\n\nstring str = \"World\"; // 自动添加 '\\0'\n需要注意的是，在使用 char* 和 char [] 时，要确保正确处理内存分配和释放，以避免出现内存泄漏或访问非法内存的问题。另外，当转换为 string 时，要确保原始字符数组或指针所指向的内容是有效的，否则可能导致未定义行为。",
      "normalizedContent": "提示\n\n关于 char*、char [] 与 string 的初始化及转换\n参考文章\n\n\n# char* 和 char [] 的初始化：\n\nchar* 是指向字符的指针，可以通过指针赋值或使用字符串字面值来初始化。\nchar [] 是字符数组，可以通过字符串字面值或逐个字符赋值来初始化。\n示例：\n\ncpp\ncopy code\nchar* ptr = \"hello\"; // 使用字符串字面值初始化 char*\nchar arr [] = \"world\"; // 使用字符串字面值初始化 char []\nstring 和 char* 或 char [] 的转换：\n\nstring 可以通过构造函数或赋值运算符将 char* 或 char [] 转换为 string。\nchar* 或 char [] 可以使用 c_str () 方法将其转换为 const char*，以便与接受 c 风格字符串的函数兼容。\n示例：\n\ncpp\ncopy code\nstring str = \"hello\"; // 使用字符串字面值初始化 string\nconst char* cstr = str.c_str (); // 转换为 const char*\n\nstring newstr = \"world\";\nconst char* newcstr = newstr.c_str (); // 转换为 const char*\n\nchar arr[] = \"hello\";\nstring arrstr (arr); // 将字符数组转换为 string\n\nchar* ptr = new char[10];\nstrcpy(ptr, \"world\");\nstring ptrstr (ptr); // 将字符指针转换为 string\n\ndelete [] ptr; // 释放内存\n注意字符串的结束符：\n\nchar [] 必须包含字符串结束符 '\\0'，否则会导致字符串操作函数无法正常工作。\nstring 类型会自动处理字符串结束符，不需要手动添加。\n示例：\n\ncpp\ncopy code\nchar arr [] = \"hello\"; // 包含 '\\0'\nchar arr2 [] = {'h', 'e', 'l', 'l', 'o'}; // 不包含 '\\0'\n\nstring str = \"world\"; // 自动添加 '\\0'\n需要注意的是，在使用 char* 和 char [] 时，要确保正确处理内存分配和释放，以避免出现内存泄漏或访问非法内存的问题。另外，当转换为 string 时，要确保原始字符数组或指针所指向的内容是有效的，否则可能导致未定义行为。",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "算法",
      "frontmatter": {
        "pageComponent": {
          "name": "Catalogue",
          "data": {
            "key": "02.算法",
            "imgUrl": "/assets/img/algorithm.jpg",
            "description": "独立做题 -> 视频讲解 -> 文章讲解 -> 重新做题 -> 整理博客"
          }
        },
        "title": "算法",
        "date": "2023-05-24 20:17",
        "permalink": "/algorithm/",
        "sidebar": false,
        "article": false,
        "comment": false,
        "comments": false,
        "editLink": false
      },
      "regularPath": "/02.%E7%AE%97%E6%B3%95/",
      "relativePath": "02.算法/index.md",
      "key": "v-012c6483",
      "path": "/algorithm/",
      "lastUpdated": "5/25/2023, 4:51:09 PM",
      "lastUpdatedTimestamp": 1685004669000,
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {}
    },
    {
      "title": "归档",
      "frontmatter": {
        "archivesPage": true,
        "title": "归档",
        "permalink": "/archives/",
        "article": false
      },
      "regularPath": "/@pages/archivesPage.html",
      "relativePath": "@pages/archivesPage.md",
      "key": "v-7cbb7956",
      "path": "/archives/",
      "lastUpdated": "1/12/2023, 12:10:26 PM",
      "lastUpdatedTimestamp": 1673496626000,
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {}
    },
    {
      "title": "算法",
      "frontmatter": {
        "pageComponent": {
          "name": "Catalogue",
          "data": {
            "key": "03.CPP",
            "imgUrl": "/assets/img/cpp.png",
            "description": "误区和细节的记录"
          }
        },
        "title": "算法",
        "date": "2023-06-01 17:46",
        "permalink": "/cpp/",
        "sidebar": false,
        "article": false,
        "comment": false,
        "comments": false,
        "editLink": false
      },
      "regularPath": "/03.CPP/",
      "relativePath": "03.CPP/index.md",
      "key": "v-3e18dce5",
      "path": "/cpp/",
      "lastUpdated": "6/1/2023, 6:03:48 PM",
      "lastUpdatedTimestamp": 1685613828000,
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {}
    },
    {
      "title": "回溯",
      "frontmatter": {
        "title": "回溯",
        "date": "2023-06-05T18:40:01.000Z",
        "permalink": "/pages/4b1970/",
        "categories": [
          "算法",
          "经典算法"
        ],
        "tags": [
          "经典算法"
        ]
      },
      "regularPath": "/02.%E7%AE%97%E6%B3%95/02.%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/02.%E5%9B%9E%E6%BA%AF.html",
      "relativePath": "02.算法/02.经典算法/02.回溯.md",
      "key": "v-7d4f7e90",
      "path": "/pages/4b1970/",
      "headers": [
        {
          "level": 2,
          "title": "数独",
          "slug": "数独",
          "normalizedTitle": "数独",
          "charIndex": 4
        }
      ],
      "excerpt": "<div class=\"custom-block tip\"><p class=\"custom-block-title\">提示</p>\n<p>数独</p>\n</div>\n",
      "lastUpdated": "6/5/2023, 8:30:15 PM",
      "lastUpdatedTimestamp": 1685968215000,
      "headersStr": "数独",
      "content": "提示\n\n数独\n\n\n# 数独\n\n/* Online C++ Compiler and Editor */\n#include <iostream>\nusing namespace std;\n\n// 定义数独的维度\n#define N 9\n\n// 检查指定的数字是否可以放置在指定的行和列中\nbool isSafe(int grid[N][N], int row, int col, int num) {\n    // 检查行中是否已经存在相同的数字\n    for (int i = 0; i < N; i++) {\n        if (grid[row][i] == num) {\n            return false;\n        }\n    }\n    \n    // 检查列中是否已经存在相同的数字\n    for (int i = 0; i < N; i++) {\n        if (grid[i][col] == num) {\n            return false;\n        }\n    }\n    \n    // 检查3x3的小方格中是否已经存在相同的数字\n    int startRow = row - row % 3;\n    int startCol = col - col % 3;\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            if (grid[i + startRow][j + startCol] == num) {\n                return false;\n            }\n        }\n    }\n    \n    // 如果没有冲突，返回true\n    return true;\n}\n\n// 在数独中查找一个未被分配的位置\nbool findUnassignedLocation(int grid[N][N], int& row, int& col) {\n    for (row = 0; row < N; row++) {\n        for (col = 0; col < N; col++) {\n            if (grid[row][col] == 0) {\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n\n// 使用回溯法解决数独\nbool solveSudoku(int grid[N][N]) {\n    int row, col;\n    \n    // 如果数独已经被解决，则返回true\n    if (!findUnassignedLocation(grid, row, col)) {\n        return true;\n    }\n    \n    // 尝试填充数字1到9\n    for (int num = 1; num <= 9; num++) {\n        // 检查是否可以将数字num放置在当前位置\n        if (isSafe(grid, row, col, num)) {\n            // 放置数字num\n            grid[row][col] = num;\n            \n            // 递归调用solveSudoku，尝试解决剩下的数独\n            if (solveSudoku(grid)) {\n                return true; // 如果数独已经被解决，则返回true\n            }\n            \n            // 如果当前的放置方式无法解决数独，则撤销该放置并尝试下一个数字\n            grid[row][col] = 0;\n        }\n    }\n    \n    return false; // 如果没有找到可行的解决方案，则返回false\n}\n\n// 打印数独\nvoid printSudoku(int grid[N][N]) {\n    for (int row = 0; row < N; row++) {\n        for (int col = 0; col < N; col++) {\n            cout << grid[row][col] << \" \";\n        }\n        cout << endl;\n    }\n}\n\nint main() {\n    int grid[N][N] = {\n        {3, 0, 0, 0, 0, 9, 0, 0, 5},\n        {0, 2, 5, 0, 0, 8, 0, 1, 0},\n        {6, 0, 0, 0, 2, 0, 0, 0, 0},\n        {0, 0, 0, 0, 0, 1, 4, 0, 0},\n        {2, 0, 0, 0, 0, 0, 0, 0, 0},\n        {0, 7, 9, 0, 8, 0, 0, 0, 6},\n        {0, 0, 0, 9, 0, 0, 0,6, 0},\n        {0, 0, 3, 0, 0, 0, 0, 0, 0},\n        {0, 5, 8, 0, 7, 0, 0, 0, 9}\n    };\n\n    if (solveSudoku(grid)) {\n        cout << \"解决方案:\" << endl;\n        printSudoku(grid);\n    } else {\n        cout << \"没有找到解决方案\" << endl;\n    }\n    \n    return 0;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n",
      "normalizedContent": "提示\n\n数独\n\n\n# 数独\n\n/* online c++ compiler and editor */\n#include <iostream>\nusing namespace std;\n\n// 定义数独的维度\n#define n 9\n\n// 检查指定的数字是否可以放置在指定的行和列中\nbool issafe(int grid[n][n], int row, int col, int num) {\n    // 检查行中是否已经存在相同的数字\n    for (int i = 0; i < n; i++) {\n        if (grid[row][i] == num) {\n            return false;\n        }\n    }\n    \n    // 检查列中是否已经存在相同的数字\n    for (int i = 0; i < n; i++) {\n        if (grid[i][col] == num) {\n            return false;\n        }\n    }\n    \n    // 检查3x3的小方格中是否已经存在相同的数字\n    int startrow = row - row % 3;\n    int startcol = col - col % 3;\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            if (grid[i + startrow][j + startcol] == num) {\n                return false;\n            }\n        }\n    }\n    \n    // 如果没有冲突，返回true\n    return true;\n}\n\n// 在数独中查找一个未被分配的位置\nbool findunassignedlocation(int grid[n][n], int& row, int& col) {\n    for (row = 0; row < n; row++) {\n        for (col = 0; col < n; col++) {\n            if (grid[row][col] == 0) {\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n\n// 使用回溯法解决数独\nbool solvesudoku(int grid[n][n]) {\n    int row, col;\n    \n    // 如果数独已经被解决，则返回true\n    if (!findunassignedlocation(grid, row, col)) {\n        return true;\n    }\n    \n    // 尝试填充数字1到9\n    for (int num = 1; num <= 9; num++) {\n        // 检查是否可以将数字num放置在当前位置\n        if (issafe(grid, row, col, num)) {\n            // 放置数字num\n            grid[row][col] = num;\n            \n            // 递归调用solvesudoku，尝试解决剩下的数独\n            if (solvesudoku(grid)) {\n                return true; // 如果数独已经被解决，则返回true\n            }\n            \n            // 如果当前的放置方式无法解决数独，则撤销该放置并尝试下一个数字\n            grid[row][col] = 0;\n        }\n    }\n    \n    return false; // 如果没有找到可行的解决方案，则返回false\n}\n\n// 打印数独\nvoid printsudoku(int grid[n][n]) {\n    for (int row = 0; row < n; row++) {\n        for (int col = 0; col < n; col++) {\n            cout << grid[row][col] << \" \";\n        }\n        cout << endl;\n    }\n}\n\nint main() {\n    int grid[n][n] = {\n        {3, 0, 0, 0, 0, 9, 0, 0, 5},\n        {0, 2, 5, 0, 0, 8, 0, 1, 0},\n        {6, 0, 0, 0, 2, 0, 0, 0, 0},\n        {0, 0, 0, 0, 0, 1, 4, 0, 0},\n        {2, 0, 0, 0, 0, 0, 0, 0, 0},\n        {0, 7, 9, 0, 8, 0, 0, 0, 6},\n        {0, 0, 0, 9, 0, 0, 0,6, 0},\n        {0, 0, 3, 0, 0, 0, 0, 0, 0},\n        {0, 5, 8, 0, 7, 0, 0, 0, 9}\n    };\n\n    if (solvesudoku(grid)) {\n        cout << \"解决方案:\" << endl;\n        printsudoku(grid);\n    } else {\n        cout << \"没有找到解决方案\" << endl;\n    }\n    \n    return 0;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "标签",
      "frontmatter": {
        "tagsPage": true,
        "title": "标签",
        "permalink": "/tags/",
        "article": false
      },
      "regularPath": "/@pages/tagsPage.html",
      "relativePath": "@pages/tagsPage.md",
      "key": "v-bd1f8054",
      "path": "/tags/",
      "lastUpdated": "1/12/2023, 12:10:26 PM",
      "lastUpdatedTimestamp": 1673496626000,
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {}
    },
    {
      "title": "分类",
      "frontmatter": {
        "categoriesPage": true,
        "title": "分类",
        "permalink": "/categories/",
        "article": false
      },
      "regularPath": "/@pages/categoriesPage.html",
      "relativePath": "@pages/categoriesPage.md",
      "key": "v-7cdbb794",
      "path": "/categories/",
      "lastUpdated": "1/12/2023, 12:10:26 PM",
      "lastUpdatedTimestamp": 1673496626000,
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {}
    },
    {
      "title": "Home",
      "frontmatter": {
        "home": true,
        "heroText": "Lido's Blog",
        "tagline": "记录、分享",
        "bannerBg": "none",
        "postList": "detailed"
      },
      "regularPath": "/",
      "relativePath": "index.md",
      "key": "v-ed56897c",
      "path": "/",
      "lastUpdated": "2/2/2023, 11:41:36 PM",
      "lastUpdatedTimestamp": 1675352496000,
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {}
    }
  ],
  "themeConfig": {
    "nav": [
      {
        "text": "Home",
        "link": "/"
      },
      {
        "text": "Golang",
        "link": "/go/",
        "items": [
          {
            "text": "框架",
            "items": [
              {
                "text": "Gin",
                "link": "/pages/3e14ca/"
              }
            ]
          },
          {
            "text": "小工具",
            "items": [
              {
                "text": "文件传输（局域网）",
                "link": "/pages/27351f/"
              },
              {
                "text": "自动提交Github",
                "link": "/pages/27352f/"
              }
            ]
          },
          {
            "text": "深入Go",
            "items": [
              {
                "text": "01.string类型",
                "link": "/pages/b6ba67/"
              },
              {
                "text": "02.slice类型",
                "link": "/pages/5b42f7/"
              },
              {
                "text": "03.结构体和内存对齐",
                "link": "/pages/20d234/"
              }
            ]
          }
        ]
      },
      {
        "text": "CPP",
        "link": "/cpp/",
        "items": [
          {
            "text": "误区总结",
            "items": [
              {
                "text": "字符串与字符初始化及转换",
                "link": "/pages/cf07c3/"
              }
            ]
          }
        ]
      },
      {
        "text": "算法",
        "link": "/algorithm/",
        "items": [
          {
            "text": "算法打卡",
            "items": [
              {
                "text": "Day11-栈与队列",
                "link": "/pages/9f1ed7/"
              },
              {
                "text": "Day12-二叉树",
                "link": "/pages/e42f06/"
              },
              {
                "text": "Day13-二叉树",
                "link": "/pages/e1103c/"
              }
            ]
          },
          {
            "text": "经典算法",
            "items": [
              {
                "text": "字符",
                "link": "/pages/d1dc4a/"
              },
              {
                "text": "回溯",
                "link": "/pages/4b1970/"
              }
            ]
          }
        ]
      },
      {
        "text": "归档",
        "link": "/archives/"
      }
    ],
    "sidebarDepth": 2,
    "logo": "/assets/img/logo.png",
    "repo": "ZhuHR-57",
    "searchMaxSuggestions": 7,
    "lastUpdated": "上次更新",
    "docsDir": "docs",
    "editLinks": false,
    "editLinkText": "编辑",
    "category": true,
    "tag": true,
    "archive": true,
    "sidebarOpen": true,
    "sidebar": {
      "/01.Go/": [
        {
          "title": "框架",
          "collapsable": true,
          "children": [
            {
              "title": "Gin",
              "collapsable": true,
              "children": [
                [
                  "01.框架/01.Gin/01.脚手架.md",
                  "脚手架",
                  "/pages/3e14ca/"
                ]
              ]
            }
          ]
        },
        {
          "title": "tools",
          "collapsable": true,
          "children": [
            [
              "02.tools/01.文件传输（局域网）.md",
              "文件传输（局域网）",
              "/pages/27351f/"
            ],
            [
              "02.tools/02.自动提交Github.md",
              "自动提交Github",
              "/pages/27352f/"
            ]
          ]
        },
        {
          "title": "深入Go",
          "collapsable": true,
          "children": [
            [
              "03.深入Go/01.string类型.md",
              "string类型",
              "/pages/b6ba67/"
            ],
            [
              "03.深入Go/02.slice类型.md",
              "slice类型",
              "/pages/5b42f7/"
            ],
            [
              "03.深入Go/03.结构体和内存对齐.md",
              "结构体和内存对齐",
              "/pages/20d234/"
            ]
          ]
        }
      ],
      "catalogue": {},
      "/02.算法/": [
        {
          "title": "算法打卡",
          "collapsable": true,
          "children": [
            [
              "01.算法打卡/00.Day00-准备.md",
              "Day00-准备",
              "/pages/fc80dd/"
            ],
            [
              "01.算法打卡/01.Day01-数组.md",
              "Day01-数组",
              "/pages/8aab7b/"
            ],
            [
              "01.算法打卡/02.Day02-数组.md",
              "Day02-数组",
              "/pages/f2d3aa/"
            ],
            [
              "01.算法打卡/03.Day03-链表.md",
              "Day03-链表",
              "/pages/2c5009/"
            ],
            [
              "01.算法打卡/04.Day04-链表.md",
              "Day04-链表",
              "/pages/115af7/"
            ],
            [
              "01.算法打卡/05.Day05-哈希.md",
              "Day05-哈希",
              "/pages/311b6b/"
            ],
            [
              "01.算法打卡/06.Day06-哈希.md",
              "Day06-哈希",
              "/pages/5d4a2f/"
            ],
            [
              "01.算法打卡/07.Day07-字符串.md",
              "Day07-字符串",
              "/pages/26eaf0/"
            ],
            [
              "01.算法打卡/08.Day08-字符串.md",
              "Day08-字符串",
              "/pages/8ef17c/"
            ],
            [
              "01.算法打卡/09.Day09-栈与队列.md",
              "Day09-栈与队列",
              "/pages/5b91fa/"
            ],
            [
              "01.算法打卡/10.Day10-栈与队列.md",
              "Day10-栈与队列",
              "/pages/51e036/"
            ],
            [
              "01.算法打卡/11.Day11-栈与队列.md",
              "Day11-栈与队列",
              "/pages/9f1ed7/"
            ],
            [
              "01.算法打卡/12.Day12-二叉树.md",
              "Day12-二叉树",
              "/pages/e42f06/"
            ],
            [
              "01.算法打卡/13.Day13-二叉树.md",
              "Day13-二叉树",
              "/pages/e1103c/"
            ]
          ]
        },
        {
          "title": "经典算法",
          "collapsable": true,
          "children": [
            [
              "02.经典算法/01.字符串.md",
              "字符串",
              "/pages/d1dc4a/"
            ],
            [
              "02.经典算法/02.回溯.md",
              "回溯",
              "/pages/4b1970/"
            ]
          ]
        }
      ],
      "/03.CPP/": [
        {
          "title": "误区总结",
          "collapsable": true,
          "children": [
            [
              "01.误区总结/01.字符串与字符初始化及转换.md",
              "字符串与字符初始化及转换",
              "/pages/cf07c3/"
            ]
          ]
        }
      ]
    },
    "updateBar": {
      "showToArticle": false,
      "moreArticle": "/archives"
    },
    "author": {
      "name": "Lido",
      "link": "https://zhuhr-57.github.io/blog/"
    },
    "blogger": {
      "avatar": "https://s3.bmp.ovh/imgs/2023/02/04/fce81e73038738f0.jpg",
      "name": "Lido",
      "slogan": "慢慢一点一点做的更好"
    },
    "social": {
      "icons": [
        {
          "iconClass": "icon-github",
          "title": "GitHub",
          "link": "https://github.com/ZhuHR-57"
        }
      ]
    },
    "footer": {
      "createYear": 2022,
      "copyrightInfo": "\n      <a href='https://github.com/ZhuHR-57' target='_blank'>Lido</a>\n    "
    }
  }
}