/**
 * Generated by "@vuepress/internal-site-data"
 */
export const siteData = {
  "title": "Blog",
  "description": "Hello Bugs!",
  "base": "/blog/",
  "headTags": [
    [
      "link",
      {
        "rel": "icon",
        "href": "/blog/favicon.ico"
      }
    ],
    [
      "meta",
      {
        "name": "viewport",
        "content": "width=device-width,initial-scale=1,user-scalable=no"
      }
    ]
  ],
  "pages": [
    {
      "title": "脚手架",
      "frontmatter": {
        "title": "脚手架",
        "date": "2023-02-03T20:38:02.000Z",
        "permalink": "/pages/3e14ca/",
        "categories": [
          "Go",
          "框架",
          "Gin"
        ],
        "tags": [
          "go"
        ]
      },
      "regularPath": "/01.Go/01.%E6%A1%86%E6%9E%B6/01.Gin/01.%E8%84%9A%E6%89%8B%E6%9E%B6.html",
      "relativePath": "01.Go/01.框架/01.Gin/01.脚手架.md",
      "key": "v-7be915d8",
      "path": "/pages/3e14ca/",
      "headers": [
        {
          "level": 2,
          "title": "2",
          "slug": "_2",
          "normalizedTitle": "2",
          "charIndex": 58
        }
      ],
      "excerpt": "<div class=\"custom-block tip\"><p class=\"custom-block-title\">提示</p>\n<p>Gin+Mysql+Redis+Viper+Zap+sals</p>\n</div>\n<p>Gin 项目的脚手架</p>\n",
      "lastUpdated": "2/4/2023, 9:33:04 AM",
      "lastUpdatedTimestamp": 1675474384000,
      "headersStr": "2",
      "content": "提示\n\nGin+Mysql+Redis+Viper+Zap+sals\n\nGin 项目的脚手架\n\n\n\n# 1\n\n\n# 2",
      "normalizedContent": "提示\n\ngin+mysql+redis+viper+zap+sals\n\ngin 项目的脚手架\n\n\n\n# 1\n\n\n# 2",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "字符串",
      "frontmatter": {
        "title": "字符串",
        "date": "2023-05-31T14:28:36.000Z",
        "permalink": "/pages/b6ba67/",
        "categories": [
          "Go",
          "深入Go"
        ],
        "tags": [
          "探索"
        ]
      },
      "regularPath": "/01.Go/03.%E6%B7%B1%E5%85%A5Go/01.%E5%AD%97%E7%AC%A6%E4%B8%B2.html",
      "relativePath": "01.Go/03.深入Go/01.字符串.md",
      "key": "v-e2c73d7c",
      "path": "/pages/b6ba67/",
      "headers": [
        {
          "level": 2,
          "title": "字符咋存❓",
          "slug": "字符咋存",
          "normalizedTitle": "字符咋存❓",
          "charIndex": 48
        },
        {
          "level": 2,
          "title": "utf8咋编码❓",
          "slug": "utf8咋编码",
          "normalizedTitle": "utf8 咋编码❓",
          "charIndex": 112
        },
        {
          "level": 3,
          "title": "定长编码",
          "slug": "定长编码",
          "normalizedTitle": "定长编码",
          "charIndex": 174
        },
        {
          "level": 3,
          "title": "变成编码",
          "slug": "变成编码",
          "normalizedTitle": "变成编码",
          "charIndex": 185
        },
        {
          "level": 3,
          "title": "总结",
          "slug": "总结",
          "normalizedTitle": "总结",
          "charIndex": 407
        },
        {
          "level": 2,
          "title": "string啥结构❓",
          "slug": "string啥结构",
          "normalizedTitle": "string 啥结构❓",
          "charIndex": 473
        }
      ],
      "excerpt": "<blockquote>\n<p>字符咋存？utf8 咋编码？string 啥结构？</p>\n<p>form：<a href=\"https://space.bilibili.com/567195437\" target=\"_blank\" rel=\"noopener noreferrer\">幼麟实验室<OutboundLink/></a></p>\n</blockquote>\n",
      "headersStr": "字符咋存❓ utf8咋编码❓ 定长编码 变成编码 总结 string啥结构❓",
      "content": "> 字符咋存？utf8 咋编码？string 啥结构？\n> \n> form：幼麟实验室\n\n\n# 字符咋存❓\n\n同样是二进制存储，通过编码（指定特定 01 排列顺序为某一字符）如常见的 ASCII、GBK、UTF-8\n\n\n# utf8 咋编码❓\n\n由上面的的问题我们知道了，存储字符本质就是保存编码\n\n> 常见的两种保存编码的方式\n> \n>  1. 定长编码\n>  2. 变成编码\n\n\n# 定长编码\n\n不管长短都都按最长的编码，可以看出非常的浪费内存，如下图\n\n\n\n\n# 变成编码\n\n根据特定的前缀编号来存储，如下图\n\n\n\n小练习\n\n字符   十进制     二进制                最终存储\ne    101     1100101            01100101\n世    19990   0100111000010110   11100100 10111000 10010110\n\n\n# 总结\n\n * 在 Go 语言中默认采用的就是 UTF-8 的编解码方式。\n\n * 字符集 + 编码方式 => 正确存储字符\n\n\n# string 啥结构❓\n\n核心问题就是：“如何判断字符结束”？\n\n * C 语言是有 '\\0' 的特定标识符\n\n * Go 语言中采用的是：data + len\n   \n   type StringHeader struct {\n       Data uintptr\n       Len  int\n   }\n   \n   \n   1\n   2\n   3\n   4\n   \n\n注意\n\n 1. 在 Go 语言中，编译器会将字符串内容放入只读内存段，所以不允许修改\n\n 2. 字符串变量可以共用底层字符串内容\n\n\n\n 3. 非要修改\n    \n    1. 可以重新赋值\n    \n    s1 = \"hello\"\n    \n    \n    1\n    \n    2. 强制类型转换为 slice，原理是重新分配内存并拷贝原来字符串内容\n    \n    bs := ([]byte)(s1)\n    bs[2] = 'o'\n    fmt.Printf(\"%c\\n\",bs[2])\n    \n    \n    1\n    2\n    3\n    ",
      "normalizedContent": "> 字符咋存？utf8 咋编码？string 啥结构？\n> \n> form：幼麟实验室\n\n\n# 字符咋存❓\n\n同样是二进制存储，通过编码（指定特定 01 排列顺序为某一字符）如常见的 ascii、gbk、utf-8\n\n\n# utf8 咋编码❓\n\n由上面的的问题我们知道了，存储字符本质就是保存编码\n\n> 常见的两种保存编码的方式\n> \n>  1. 定长编码\n>  2. 变成编码\n\n\n# 定长编码\n\n不管长短都都按最长的编码，可以看出非常的浪费内存，如下图\n\n\n\n\n# 变成编码\n\n根据特定的前缀编号来存储，如下图\n\n\n\n小练习\n\n字符   十进制     二进制                最终存储\ne    101     1100101            01100101\n世    19990   0100111000010110   11100100 10111000 10010110\n\n\n# 总结\n\n * 在 go 语言中默认采用的就是 utf-8 的编解码方式。\n\n * 字符集 + 编码方式 => 正确存储字符\n\n\n# string 啥结构❓\n\n核心问题就是：“如何判断字符结束”？\n\n * c 语言是有 '\\0' 的特定标识符\n\n * go 语言中采用的是：data + len\n   \n   type stringheader struct {\n       data uintptr\n       len  int\n   }\n   \n   \n   1\n   2\n   3\n   4\n   \n\n注意\n\n 1. 在 go 语言中，编译器会将字符串内容放入只读内存段，所以不允许修改\n\n 2. 字符串变量可以共用底层字符串内容\n\n\n\n 3. 非要修改\n    \n    1. 可以重新赋值\n    \n    s1 = \"hello\"\n    \n    \n    1\n    \n    2. 强制类型转换为 slice，原理是重新分配内存并拷贝原来字符串内容\n    \n    bs := ([]byte)(s1)\n    bs[2] = 'o'\n    fmt.printf(\"%c\\n\",bs[2])\n    \n    \n    1\n    2\n    3\n    ",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "自动提交Github",
      "frontmatter": {
        "title": "自动提交Github",
        "date": "2023-05-22T20:41:38.000Z",
        "permalink": "/pages/27352f/",
        "categories": [
          "Go",
          "tools"
        ],
        "tags": [
          "go-tools"
        ]
      },
      "regularPath": "/01.Go/02.tools/02.%E8%87%AA%E5%8A%A8%E6%8F%90%E4%BA%A4Github.html",
      "relativePath": "01.Go/02.tools/02.自动提交Github.md",
      "key": "v-0a0e56be",
      "path": "/pages/27352f/",
      "headers": [
        {
          "level": 2,
          "title": "完整代码如下",
          "slug": "完整代码如下",
          "normalizedTitle": "完整代码如下",
          "charIndex": 30
        },
        {
          "level": 3,
          "title": "文件",
          "slug": "文件",
          "normalizedTitle": "文件",
          "charIndex": 41
        },
        {
          "level": 3,
          "title": "代码",
          "slug": "代码",
          "normalizedTitle": "代码",
          "charIndex": 32
        },
        {
          "level": 2,
          "title": "编译（Windos）",
          "slug": "编译-windos",
          "normalizedTitle": "编译（windos）",
          "charIndex": 1160
        },
        {
          "level": 2,
          "title": "任务计划",
          "slug": "任务计划",
          "normalizedTitle": "任务计划",
          "charIndex": 19
        }
      ],
      "excerpt": "<blockquote>\n<p>Go build + Git + 任务计划程序</p>\n</blockquote>\n",
      "lastUpdated": "5/22/2023, 8:42:57 PM",
      "lastUpdatedTimestamp": 1684759377000,
      "headersStr": "完整代码如下 文件 代码 编译（Windos） 任务计划",
      "content": "> Go build + Git + 任务计划程序\n\n\n# 完整代码如下\n\n\n# 文件\n\n * main.go\n\n\n# 代码\n\n/**\n  @Go version: 1.17.6\n  @project: Hello\n  @ide: GoLand\n  @file: main.go\n  @author: Lido\n  @time: 2023-05-22 20:08\n  @description: 提交Github\n*/\npackage main\n\nimport (\n\t\"log\"\n\t\"os\"\n\t\"os/exec\"\n)\n\n// 执行自动提交代码和推送到远程仓库\nfunc commitAndPush() error {\n\t// 切换到项目目录\n\tprojectPath := \"F:/Blog/Blog_Home_New/\"\n\tif err := os.Chdir(projectPath); err != nil {\n\t\treturn err\n\t}\n\n\t// 创建 git add 命令\n\taddCmd := exec.Command(\"git\", \"add\", \".\")\n\n\t// 执行 git add 命令\n\tif err := addCmd.Run(); err != nil {\n\t\treturn err\n\t}\n\n\t// 创建 git commit 命令\n\tcommitCmd := exec.Command(\"git\", \"commit\", \"-m\", \"Auto commit\")\n\n\t// 执行 git commit 命令\n\tif err := commitCmd.Run(); err != nil {\n\t\treturn err\n\t}\n\n\t// 创建 git push 命令\n\tpushCmd := exec.Command(\"git\", \"push\",\"-u\",\"origin\",\"master\")\n\n\t// 执行 git push 命令\n\tif err := pushCmd.Run(); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc main() {\n\tcommitAndPush()\n\n\tlog.Println(\"Code committed and pushed to GitHub.\")\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n\n\n# 编译（Windos）\n\n提示\n\n其他系统编译在上一篇文中有提\n\ngo build filename.go \n\n\n1\n\n\n\n# 任务计划\n\n 1. 打开任务计划程序。可以在开始菜单中搜索 \"任务计划程序\" 来找到它。\n 2. 在任务计划程序中，点击 \"创建基本任务\"。\n 3. 输入任务的名称和描述，然后点击 \"下一步\"。\n 4. 选择触发器类型为 \"每周\"，并选择每周的周一。\n 5. 选择操作类型为 \"启动程序\"。\n 6. 在程序 / 脚本字段中，输入 Go 程序的可执行文件路径。\n 7. 点击 \"完成\" 来创建计划任务。",
      "normalizedContent": "> go build + git + 任务计划程序\n\n\n# 完整代码如下\n\n\n# 文件\n\n * main.go\n\n\n# 代码\n\n/**\n  @go version: 1.17.6\n  @project: hello\n  @ide: goland\n  @file: main.go\n  @author: lido\n  @time: 2023-05-22 20:08\n  @description: 提交github\n*/\npackage main\n\nimport (\n\t\"log\"\n\t\"os\"\n\t\"os/exec\"\n)\n\n// 执行自动提交代码和推送到远程仓库\nfunc commitandpush() error {\n\t// 切换到项目目录\n\tprojectpath := \"f:/blog/blog_home_new/\"\n\tif err := os.chdir(projectpath); err != nil {\n\t\treturn err\n\t}\n\n\t// 创建 git add 命令\n\taddcmd := exec.command(\"git\", \"add\", \".\")\n\n\t// 执行 git add 命令\n\tif err := addcmd.run(); err != nil {\n\t\treturn err\n\t}\n\n\t// 创建 git commit 命令\n\tcommitcmd := exec.command(\"git\", \"commit\", \"-m\", \"auto commit\")\n\n\t// 执行 git commit 命令\n\tif err := commitcmd.run(); err != nil {\n\t\treturn err\n\t}\n\n\t// 创建 git push 命令\n\tpushcmd := exec.command(\"git\", \"push\",\"-u\",\"origin\",\"master\")\n\n\t// 执行 git push 命令\n\tif err := pushcmd.run(); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc main() {\n\tcommitandpush()\n\n\tlog.println(\"code committed and pushed to github.\")\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n\n\n# 编译（windos）\n\n提示\n\n其他系统编译在上一篇文中有提\n\ngo build filename.go \n\n\n1\n\n\n\n# 任务计划\n\n 1. 打开任务计划程序。可以在开始菜单中搜索 \"任务计划程序\" 来找到它。\n 2. 在任务计划程序中，点击 \"创建基本任务\"。\n 3. 输入任务的名称和描述，然后点击 \"下一步\"。\n 4. 选择触发器类型为 \"每周\"，并选择每周的周一。\n 5. 选择操作类型为 \"启动程序\"。\n 6. 在程序 / 脚本字段中，输入 go 程序的可执行文件路径。\n 7. 点击 \"完成\" 来创建计划任务。",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "文件传输（局域网）",
      "frontmatter": {
        "title": "文件传输（局域网）",
        "date": "2023-03-01T20:46:35.000Z",
        "permalink": "/pages/27351f/",
        "categories": [
          "Go",
          "tools"
        ],
        "tags": [
          "go-tools"
        ]
      },
      "regularPath": "/01.Go/02.tools/01.%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%EF%BC%88%E5%B1%80%E5%9F%9F%E7%BD%91%EF%BC%89.html",
      "relativePath": "01.Go/02.tools/01.文件传输（局域网）.md",
      "key": "v-8af7b2a4",
      "path": "/pages/27351f/",
      "headers": [
        {
          "level": 2,
          "title": "完整代码如下",
          "slug": "完整代码如下",
          "normalizedTitle": "完整代码如下",
          "charIndex": 30
        },
        {
          "level": 3,
          "title": "文件",
          "slug": "文件",
          "normalizedTitle": "文件",
          "charIndex": 13
        },
        {
          "level": 3,
          "title": "代码",
          "slug": "代码",
          "normalizedTitle": "代码",
          "charIndex": 32
        },
        {
          "level": 2,
          "title": "打包",
          "slug": "打包",
          "normalizedTitle": "打包",
          "charIndex": 2426
        },
        {
          "level": 2,
          "title": "编译(windows)",
          "slug": "编译-windows",
          "normalizedTitle": "编译 (windows)",
          "charIndex": 2533
        },
        {
          "level": 3,
          "title": "运行测试",
          "slug": "运行测试",
          "normalizedTitle": "运行测试",
          "charIndex": 2649
        },
        {
          "level": 2,
          "title": "交叉编译",
          "slug": "交叉编译",
          "normalizedTitle": "交叉编译",
          "charIndex": 3040
        },
        {
          "level": 3,
          "title": "Mac下编译Linux, Windows",
          "slug": "mac下编译linux-windows",
          "normalizedTitle": "mac 下编译 linux, windows",
          "charIndex": 3049
        },
        {
          "level": 3,
          "title": "Linux下编译Mac, Windows",
          "slug": "linux下编译mac-windows",
          "normalizedTitle": "linux 下编译 mac, windows",
          "charIndex": 3320
        },
        {
          "level": 3,
          "title": "Windows下编译Mac, Linux",
          "slug": "windows下编译mac-linux",
          "normalizedTitle": "windows 下编译 mac, linux",
          "charIndex": 3500
        },
        {
          "level": 2,
          "title": "说明",
          "slug": "说明",
          "normalizedTitle": "说明",
          "charIndex": 1036
        }
      ],
      "excerpt": "<blockquote>\n<p>Go build + 文件传输 + 命令行参数</p>\n</blockquote>\n",
      "lastUpdated": "5/22/2023, 8:42:57 PM",
      "lastUpdatedTimestamp": 1684759377000,
      "headersStr": "完整代码如下 文件 代码 打包 编译(windows) 运行测试 交叉编译 Mac下编译Linux, Windows Linux下编译Mac, Windows Windows下编译Mac, Linux 说明",
      "content": "> Go build + 文件传输 + 命令行参数\n\n\n# 完整代码如下\n\n\n# 文件\n\n * main.go\n * main.rc\n * mian.ico\n * mian.syso\n\n\n# 代码\n\n/**\n* @program: Hello\n* @filename: main.go\n* @author: Lido\n* @create: 2022-02-03 11:30\n* @description: 文件传输（局域网）\n**/\n\npackage main\n\nimport (\n\t\"errors\"\n\t\"flag\"\n\t\"log\"\n\t\"net\"\n\t\"net/http\"\n)\n\nvar isUsefunc bool = false\n\nfunc logRequest(handler http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tlog.Printf(\"%s %s %s\\n\", r.RemoteAddr, r.Method, r.URL)\n\t\thandler.ServeHTTP(w, r)\n\t})\n}\n\nfunc main() {\n\t//当前文件夹\n\tfs := http.FileServer(http.Dir(\"\"))\n\t/**\n\t解析命令行参数\n\t*/\n\t//默认值设置\n\tflag.Func(\"gip\", \"-gip ip/mac/im\", getIpAndMacAddress)\n\tip := flag.String(\"ip\", \"127.0.0.1\", \"ip\")\n\tport := flag.String(\"port\", \"8089\", \"port\")\n\t//解析\n\tflag.Parse()\n\n\tif isUsefunc {\n\t\treturn\n\t}\n\n\t//字符串拼接\n\turl := *ip+\":\"+*port\n\turl_full := \"http://\"+url\n\n\tlog.Println(\"running server at \"+url_full)\n\t//监听\n\tlog.Fatal(http.ListenAndServe(url, logRequest(fs)))\n}\n\nfunc getIpAndMacAddress(str string) error{\n\tlog.Println(\"说明：\")\n\tlog.Println(\"一般最后一个是本机的WIFI的本地IP\\n\")\n\n\tlog.Println(\"案例：\")\n\tlog.Println(\"file-web.exe -ip 192.168.xxx.xxx -port xxxx\\n\")\n\n\tifaces, err := net.Interfaces()\n\tif err != nil {\n\t\tlog.Println(err)\n\t}\n\n\tfor _, iface := range ifaces {\n\t\tif iface.Flags&net.FlagUp == 0 {\n\t\t\tcontinue // interface down\n\t\t}\n\t\tif iface.Flags&net.FlagLoopback != 0 {\n\t\t\tcontinue // loopback interface\n\t\t}\n\t\taddrs, err := iface.Addrs()\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t}\n\n\t\tfor _, addr := range addrs {\n\t\t\tvar ip net.IP\n\t\t\tswitch v := addr.(type) {\n\t\t\tcase *net.IPNet:\n\t\t\t\tip = v.IP\n\t\t\tcase *net.IPAddr:\n\t\t\t\tip = v.IP\n\t\t\t}\n\t\t\tif ip == nil || ip.IsLoopback() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tip = ip.To4()\n\t\t\tif ip == nil {\n\t\t\t\tcontinue // not an ipv4 address\n\t\t\t}\n\n\t\t\tif str == \"ip\" {\n\t\t\t\tlog.Println(\"ip: \", ip.String())\n\t\t\t}else if str == \"mac\"{\n\t\t\t\tlog.Println(\"mac: \", iface.HardwareAddr.String())\n\t\t\t}else if str  == \"im\"{\n\t\t\t\tlog.Println(\"ip: \", ip.String(), \"mac: \", iface.HardwareAddr.String())\n\t\t\t}else {\n\t\t\t\treturn errors.New(\"-1\")\n\t\t\t}\n\t\t}\n\t}\n\n\tisUsefunc = true\n\treturn nil\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n\n\n\n# 打包\n\n提示\n\n 1. 创建 main.rc 文件\n\nIDI_ICON1 ICON \"main.ico\"\n\n\n1\n\n\n提示\n\n 2. 找好 ioc 图标（128*128），将图形名称改为 main.ico\n\n\n# 编译 (windows)\n\n提示\n\n将上面两个文件和 go 源文件放在一起\n\n打开终端\n\nwindres -o main.syso main.rc\n\n\n1\n\n\ngo build  -ldflags \"-w -s\"\n\n\n1\n\n\n\n# 运行测试\n\nF:\\GOCODE\\Hello\\file-web>file-web.exe -gip ip\n2022/02/03 14:22:14 说明：\n2022/02/03 14:22:14 一般最后一个是本机的WIFI的本地IP\n\n2022/02/03 14:22:14 案例：\n2022/02/03 14:22:14 file-web.exe -ip 192.168.xxx.xxx -port xxxx\n\n2022/02/03 14:22:14 ip:  192.168.137.1\n2022/02/03 14:22:14 ip:  192.168.195.1\n2022/02/03 14:22:14 ip:  192.168.134.1\n2022/02/03 14:22:14 ip:  192.168.3.9\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 交叉编译\n\n\n# Mac 下编译 Linux, Windows\n\n# Linux\nCGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build filename.go\n \n# Windows\nCGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build filename.go\n如: CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build -o helloworld-windows helloworld.go\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# Linux 下编译 Mac, Windows\n\n# Mac\nCGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build filename.go\n \n# Windows\nCGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build filename.go\n\n\n1\n2\n3\n4\n5\n\n\n\n# Windows 下编译 Mac, Linux\n\n# Mac\nSET CGO_ENABLED=0\nSET GOOS=darwin\nSET GOARCH=amd64\ngo build filename.go\n \n# Linux\nSET CGO_ENABLED=0\nSET GOOS=linux\nSET GOARCH=amd64\ngo build filename.go -ldflags \"-w -s\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nchomd 777 xxx\n\n\n1\n\n\n\n# 说明\n\n 1. 以上两种解决方法只能临时修改 go 的环境变量，重启 Goland 或者重启 cmd 终端后失效。\n\n 2. 执行 go env -w GOOS=linux 可以修改 go 的环境变量 GOOS，且当重启 Goland 后或者打开其他项目后都有效。但是在 Git Bash 下执行 chmod 777 xx 赋予文件 xx 可执行权限失败。\n\n 3. 如果按上述方式永久修改了 GOOS，使用 Goland 的 run 命令直接运行程序会失败，即使临时设置 export GOOS=windows 也不起作用，只能通过 go env -w GOOS=windows 修改 GOOS 后才能在 Goland 中直接运行程序。\n\n终上所述，在 windows 系统的 Goland 中编译 Linux 的可执行程序时，建议临时修改 export GOOS=linux，而不是使用 go env -w GOOS=linux 永久修改。",
      "normalizedContent": "> go build + 文件传输 + 命令行参数\n\n\n# 完整代码如下\n\n\n# 文件\n\n * main.go\n * main.rc\n * mian.ico\n * mian.syso\n\n\n# 代码\n\n/**\n* @program: hello\n* @filename: main.go\n* @author: lido\n* @create: 2022-02-03 11:30\n* @description: 文件传输（局域网）\n**/\n\npackage main\n\nimport (\n\t\"errors\"\n\t\"flag\"\n\t\"log\"\n\t\"net\"\n\t\"net/http\"\n)\n\nvar isusefunc bool = false\n\nfunc logrequest(handler http.handler) http.handler {\n\treturn http.handlerfunc(func(w http.responsewriter, r *http.request) {\n\t\tlog.printf(\"%s %s %s\\n\", r.remoteaddr, r.method, r.url)\n\t\thandler.servehttp(w, r)\n\t})\n}\n\nfunc main() {\n\t//当前文件夹\n\tfs := http.fileserver(http.dir(\"\"))\n\t/**\n\t解析命令行参数\n\t*/\n\t//默认值设置\n\tflag.func(\"gip\", \"-gip ip/mac/im\", getipandmacaddress)\n\tip := flag.string(\"ip\", \"127.0.0.1\", \"ip\")\n\tport := flag.string(\"port\", \"8089\", \"port\")\n\t//解析\n\tflag.parse()\n\n\tif isusefunc {\n\t\treturn\n\t}\n\n\t//字符串拼接\n\turl := *ip+\":\"+*port\n\turl_full := \"http://\"+url\n\n\tlog.println(\"running server at \"+url_full)\n\t//监听\n\tlog.fatal(http.listenandserve(url, logrequest(fs)))\n}\n\nfunc getipandmacaddress(str string) error{\n\tlog.println(\"说明：\")\n\tlog.println(\"一般最后一个是本机的wifi的本地ip\\n\")\n\n\tlog.println(\"案例：\")\n\tlog.println(\"file-web.exe -ip 192.168.xxx.xxx -port xxxx\\n\")\n\n\tifaces, err := net.interfaces()\n\tif err != nil {\n\t\tlog.println(err)\n\t}\n\n\tfor _, iface := range ifaces {\n\t\tif iface.flags&net.flagup == 0 {\n\t\t\tcontinue // interface down\n\t\t}\n\t\tif iface.flags&net.flagloopback != 0 {\n\t\t\tcontinue // loopback interface\n\t\t}\n\t\taddrs, err := iface.addrs()\n\t\tif err != nil {\n\t\t\tlog.println(err)\n\t\t}\n\n\t\tfor _, addr := range addrs {\n\t\t\tvar ip net.ip\n\t\t\tswitch v := addr.(type) {\n\t\t\tcase *net.ipnet:\n\t\t\t\tip = v.ip\n\t\t\tcase *net.ipaddr:\n\t\t\t\tip = v.ip\n\t\t\t}\n\t\t\tif ip == nil || ip.isloopback() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tip = ip.to4()\n\t\t\tif ip == nil {\n\t\t\t\tcontinue // not an ipv4 address\n\t\t\t}\n\n\t\t\tif str == \"ip\" {\n\t\t\t\tlog.println(\"ip: \", ip.string())\n\t\t\t}else if str == \"mac\"{\n\t\t\t\tlog.println(\"mac: \", iface.hardwareaddr.string())\n\t\t\t}else if str  == \"im\"{\n\t\t\t\tlog.println(\"ip: \", ip.string(), \"mac: \", iface.hardwareaddr.string())\n\t\t\t}else {\n\t\t\t\treturn errors.new(\"-1\")\n\t\t\t}\n\t\t}\n\t}\n\n\tisusefunc = true\n\treturn nil\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n\n\n\n# 打包\n\n提示\n\n 1. 创建 main.rc 文件\n\nidi_icon1 icon \"main.ico\"\n\n\n1\n\n\n提示\n\n 2. 找好 ioc 图标（128*128），将图形名称改为 main.ico\n\n\n# 编译 (windows)\n\n提示\n\n将上面两个文件和 go 源文件放在一起\n\n打开终端\n\nwindres -o main.syso main.rc\n\n\n1\n\n\ngo build  -ldflags \"-w -s\"\n\n\n1\n\n\n\n# 运行测试\n\nf:\\gocode\\hello\\file-web>file-web.exe -gip ip\n2022/02/03 14:22:14 说明：\n2022/02/03 14:22:14 一般最后一个是本机的wifi的本地ip\n\n2022/02/03 14:22:14 案例：\n2022/02/03 14:22:14 file-web.exe -ip 192.168.xxx.xxx -port xxxx\n\n2022/02/03 14:22:14 ip:  192.168.137.1\n2022/02/03 14:22:14 ip:  192.168.195.1\n2022/02/03 14:22:14 ip:  192.168.134.1\n2022/02/03 14:22:14 ip:  192.168.3.9\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 交叉编译\n\n\n# mac 下编译 linux, windows\n\n# linux\ncgo_enabled=0 goos=linux goarch=amd64 go build filename.go\n \n# windows\ncgo_enabled=0 goos=windows goarch=amd64 go build filename.go\n如: cgo_enabled=0 goos=windows goarch=amd64 go build -o helloworld-windows helloworld.go\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# linux 下编译 mac, windows\n\n# mac\ncgo_enabled=0 goos=darwin goarch=amd64 go build filename.go\n \n# windows\ncgo_enabled=0 goos=windows goarch=amd64 go build filename.go\n\n\n1\n2\n3\n4\n5\n\n\n\n# windows 下编译 mac, linux\n\n# mac\nset cgo_enabled=0\nset goos=darwin\nset goarch=amd64\ngo build filename.go\n \n# linux\nset cgo_enabled=0\nset goos=linux\nset goarch=amd64\ngo build filename.go -ldflags \"-w -s\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nchomd 777 xxx\n\n\n1\n\n\n\n# 说明\n\n 1. 以上两种解决方法只能临时修改 go 的环境变量，重启 goland 或者重启 cmd 终端后失效。\n\n 2. 执行 go env -w goos=linux 可以修改 go 的环境变量 goos，且当重启 goland 后或者打开其他项目后都有效。但是在 git bash 下执行 chmod 777 xx 赋予文件 xx 可执行权限失败。\n\n 3. 如果按上述方式永久修改了 goos，使用 goland 的 run 命令直接运行程序会失败，即使临时设置 export goos=windows 也不起作用，只能通过 go env -w goos=windows 修改 goos 后才能在 goland 中直接运行程序。\n\n终上所述，在 windows 系统的 goland 中编译 linux 的可执行程序时，建议临时修改 export goos=linux，而不是使用 go env -w goos=linux 永久修改。",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "G0",
      "frontmatter": {
        "pageComponent": {
          "name": "Catalogue",
          "data": {
            "key": "01.Go",
            "imgUrl": "/assets/img/go.png",
            "description": "Go Go Go"
          }
        },
        "title": "G0",
        "date": "2023-02-03 20:17",
        "permalink": "/go/",
        "sidebar": false,
        "article": false,
        "comment": false,
        "comments": false,
        "editLink": false
      },
      "regularPath": "/01.Go/",
      "relativePath": "01.Go/index.md",
      "key": "v-274e5b96",
      "path": "/go/",
      "lastUpdated": "2/4/2023, 9:33:04 AM",
      "lastUpdatedTimestamp": 1675474384000,
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {}
    },
    {
      "title": "Day01-数组",
      "frontmatter": {
        "title": "Day01-数组",
        "date": "2023-05-24T16:20:33.000Z",
        "permalink": "/pages/8aab7b/",
        "categories": [
          "算法",
          "算法打卡"
        ],
        "tags": [
          "打卡"
        ]
      },
      "regularPath": "/02.%E7%AE%97%E6%B3%95/01.%E7%AE%97%E6%B3%95%E6%89%93%E5%8D%A1/01.Day01-%E6%95%B0%E7%BB%84.html",
      "relativePath": "02.算法/01.算法打卡/01.Day01-数组.md",
      "key": "v-6f10ee50",
      "path": "/pages/8aab7b/",
      "headers": [
        {
          "level": 2,
          "title": "704.二分查找",
          "slug": "_704-二分查找",
          "normalizedTitle": "704. 二分查找",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "录前想法",
          "slug": "录前想法",
          "normalizedTitle": "录前想法",
          "charIndex": 92
        },
        {
          "level": 3,
          "title": "录后想法",
          "slug": "录后想法",
          "normalizedTitle": "录后想法",
          "charIndex": 1265
        },
        {
          "level": 3,
          "title": "困难点",
          "slug": "困难点",
          "normalizedTitle": "困难点",
          "charIndex": 1428
        },
        {
          "level": 2,
          "title": "27. 移除元素",
          "slug": "_27-移除元素",
          "normalizedTitle": "27. 移除元素",
          "charIndex": 12
        },
        {
          "level": 3,
          "title": "录前想法",
          "slug": "录前想法-2",
          "normalizedTitle": "录前想法",
          "charIndex": 92
        },
        {
          "level": 3,
          "title": "录后想法",
          "slug": "录后想法-2",
          "normalizedTitle": "录后想法",
          "charIndex": 1265
        },
        {
          "level": 3,
          "title": "困难点",
          "slug": "困难点-2",
          "normalizedTitle": "困难点",
          "charIndex": 1428
        },
        {
          "level": 2,
          "title": "拓展",
          "slug": "拓展",
          "normalizedTitle": "拓展",
          "charIndex": 4067
        },
        {
          "level": 3,
          "title": "35.搜索插入位置",
          "slug": "_35-搜索插入位置",
          "normalizedTitle": "35. 搜索插入位置",
          "charIndex": 4074
        },
        {
          "level": 3,
          "title": "34. 在排序数组中查找元素的第一个和最后一个位置",
          "slug": "_34-在排序数组中查找元素的第一个和最后一个位置",
          "normalizedTitle": "34. 在排序数组中查找元素的第一个和最后一个位置",
          "charIndex": 4089
        },
        {
          "level": 2,
          "title": "总结",
          "slug": "总结",
          "normalizedTitle": "总结",
          "charIndex": 4119
        }
      ],
      "excerpt": "<blockquote>\n<p>704. 二分查找、27. 移除元素</p>\n</blockquote>\n",
      "lastUpdated": "5/25/2023, 1:19:01 AM",
      "lastUpdatedTimestamp": 1684948741000,
      "headersStr": "704.二分查找 录前想法 录后想法 困难点 27. 移除元素 录前想法 录后想法 困难点 拓展 35.搜索插入位置 34. 在排序数组中查找元素的第一个和最后一个位置 总结",
      "content": "> 704. 二分查找、27. 移除元素\n\n\n# 704. 二分查找\n\n * 题目：704. 二分查找\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：熟悉左闭右开，左闭右闭\n\n\n# 录前想法\n\n * 首先二分查找的前置条件是已排序。\n\n * 其次为什么会有左闭右开与左开右闭的区分，我认为是奇数个数除 2 后偏左与偏右的问题\n\n * 😢不明白为什么 mid = l + (r - l) >> 1 会超时？\n   \n   * 因为少了括号【 ((r - l) >> 1) 】\n\n> 左闭右开\n\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int l = 0,r = nums.size(),mid = 0;\n\n        while( l < r){\n            mid = l + (r - l) / 2;\n            //mid = l + ((r - l) >> 1);\n            if (nums[mid] > target){\n                r = mid;\n            }else if(nums[mid] < target){\n                l = mid + 1;\n            }else{\n                return mid;\n            }\n        }\n        return -1;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n> 左闭右闭\n\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int l = 0,r = nums.size()-1,mid = 0;\n\n        while( l <= r ){\n            mid = l + (r - l) / 2;\n            //mid = l + ((r - l) >> 1);\n            if (nums[mid] > target){\n                r = mid - 1;\n            }else if(nums[mid] < target){\n                l = mid + 1;\n            }else{\n                return mid;\n            }\n        }\n        return -1;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 录后想法\n\n 1. 对右开和右闭理解的更深刻了，我是这么理解的\n    \n    1. 右闭说明取得到 right, 如果 mid 取不到，则 right = mid - 1\n    2. 右开说明取不到 right, 如果 mid 取不到，则 right = mid\n\n 2. 时间复杂度，写完一个算法要表明复杂度\n\n\n# 困难点\n\n> 为什么 mid = l + (r - l) >> 1 会超时，而 mid = l + (r - l) / 2 不会？\n\n因为，mid = l + (r - l) >> 1 需要加上括号： mid = l + ((r - l) >> 1)\n\n\n# 27. 移除元素\n\n * 题目：27. 移除元素\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：先暴力后双指针\n\n\n# 录前想法\n\n暴力解法，移动元素，问题卡在出现重复元素时，一直会留着一个元素，以下是我的代码（错误代码❌）\n\nclass Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        int size = nums.size();\n\n        for (int i = 0;i < size;++i){\n            if (nums[i] == val){\n                for (int j = i;j < size - 1;++j){\n                    nums[j] = nums[j+1];\n                }\n                --size;\n            }\n        }\n        return size;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 录后想法\n\n 1. 暴力解法\n\n看过讲解后发先是让 i 直接前进了，没有考虑到覆盖上来的元素可能是待删除的值，(正确代码✅)\n\nclass Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        int size = nums.size();\n\n        for (int i = 0;i < size;++i){\n            if (nums[i] == val){\n                for (int j = i;j < size - 1;++j){\n                    nums[j] = nums[j+1];\n                }\n                --size;\n                --i;\n            }\n        }\n\n        return size;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n * 时间复杂度：O (n^2)\n * 空间复杂度：O (1)\n\n 2. 双指针\n\n双指针法（快慢指针法）： 通过一个快指针和慢指针在一个 for 循环下完成两个 for 循环的工作。\n\n定义快慢指针\n\n * 快指针：用于更新\n * 慢指针：被更新\n\nclass Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        int size = nums.size();\n        int slow = 0;\n\n        for (int fast = 0; fast < size; ++fast){\n            // 这个 != 可以写的这么简洁！\n            if (nums[fast] != val){\n               nums[slow++] = nums[fast];\n            }\n        }\n\n        return slow;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n * 时间复杂度：O (n)\n * 空间复杂度：O (1)\n\n 3. 相向双指针方法\n\n基于元素顺序可以改变的题目描述改变了元素相对位置，确保了移动最少元素。\n\n操作如下：\n\n * 找左边等于 val 的元素\n * 找右边不等于 val 的元素\n * 将右边不等于 val 的元素覆盖左边等于 val 的元素\n\nclass Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        int size = nums.size();\n        int right = size - 1,left = 0;\n\n        while(left <= right){\n            // 找左边等于val的元素\n            while(left <= right && nums[left] != val){ \n                ++left; \n            }\n            // 找右边不等于val的元素\n            while(left <= right && nums[right] == val){\n                --right;\n            }\n            // 将右边不等于val的元素覆盖左边等于val的元素\n            if(left <= right){\n                nums[left++] = nums[right--];\n            }\n       }\n\n       return left; // nums[left++],刚好指向了下一个元素，下标 = 元素个数\n        \t\t\t// right指向上一个元素，需要+1\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 困难点\n\n 1. 暴力移动元素时考虑不完善，没有考虑到挨着的重复元素，直接 ++i 跳过了。\n 2. 双指针中！= 写法很简洁，没有想到\n\n\n# 拓展\n\n\n# 35. 搜索插入位置\n\n\n# 34. 在排序数组中查找元素的第一个和最后一个位置\n\n\n# 总结\n\n 1. 数组的元素是不能删的，只能覆盖。\n 2. 细节考虑不周。",
      "normalizedContent": "> 704. 二分查找、27. 移除元素\n\n\n# 704. 二分查找\n\n * 题目：704. 二分查找\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：熟悉左闭右开，左闭右闭\n\n\n# 录前想法\n\n * 首先二分查找的前置条件是已排序。\n\n * 其次为什么会有左闭右开与左开右闭的区分，我认为是奇数个数除 2 后偏左与偏右的问题\n\n * 😢不明白为什么 mid = l + (r - l) >> 1 会超时？\n   \n   * 因为少了括号【 ((r - l) >> 1) 】\n\n> 左闭右开\n\nclass solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int l = 0,r = nums.size(),mid = 0;\n\n        while( l < r){\n            mid = l + (r - l) / 2;\n            //mid = l + ((r - l) >> 1);\n            if (nums[mid] > target){\n                r = mid;\n            }else if(nums[mid] < target){\n                l = mid + 1;\n            }else{\n                return mid;\n            }\n        }\n        return -1;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n> 左闭右闭\n\nclass solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int l = 0,r = nums.size()-1,mid = 0;\n\n        while( l <= r ){\n            mid = l + (r - l) / 2;\n            //mid = l + ((r - l) >> 1);\n            if (nums[mid] > target){\n                r = mid - 1;\n            }else if(nums[mid] < target){\n                l = mid + 1;\n            }else{\n                return mid;\n            }\n        }\n        return -1;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 录后想法\n\n 1. 对右开和右闭理解的更深刻了，我是这么理解的\n    \n    1. 右闭说明取得到 right, 如果 mid 取不到，则 right = mid - 1\n    2. 右开说明取不到 right, 如果 mid 取不到，则 right = mid\n\n 2. 时间复杂度，写完一个算法要表明复杂度\n\n\n# 困难点\n\n> 为什么 mid = l + (r - l) >> 1 会超时，而 mid = l + (r - l) / 2 不会？\n\n因为，mid = l + (r - l) >> 1 需要加上括号： mid = l + ((r - l) >> 1)\n\n\n# 27. 移除元素\n\n * 题目：27. 移除元素\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：先暴力后双指针\n\n\n# 录前想法\n\n暴力解法，移动元素，问题卡在出现重复元素时，一直会留着一个元素，以下是我的代码（错误代码❌）\n\nclass solution {\npublic:\n    int removeelement(vector<int>& nums, int val) {\n        int size = nums.size();\n\n        for (int i = 0;i < size;++i){\n            if (nums[i] == val){\n                for (int j = i;j < size - 1;++j){\n                    nums[j] = nums[j+1];\n                }\n                --size;\n            }\n        }\n        return size;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 录后想法\n\n 1. 暴力解法\n\n看过讲解后发先是让 i 直接前进了，没有考虑到覆盖上来的元素可能是待删除的值，(正确代码✅)\n\nclass solution {\npublic:\n    int removeelement(vector<int>& nums, int val) {\n        int size = nums.size();\n\n        for (int i = 0;i < size;++i){\n            if (nums[i] == val){\n                for (int j = i;j < size - 1;++j){\n                    nums[j] = nums[j+1];\n                }\n                --size;\n                --i;\n            }\n        }\n\n        return size;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n * 时间复杂度：o (n^2)\n * 空间复杂度：o (1)\n\n 2. 双指针\n\n双指针法（快慢指针法）： 通过一个快指针和慢指针在一个 for 循环下完成两个 for 循环的工作。\n\n定义快慢指针\n\n * 快指针：用于更新\n * 慢指针：被更新\n\nclass solution {\npublic:\n    int removeelement(vector<int>& nums, int val) {\n        int size = nums.size();\n        int slow = 0;\n\n        for (int fast = 0; fast < size; ++fast){\n            // 这个 != 可以写的这么简洁！\n            if (nums[fast] != val){\n               nums[slow++] = nums[fast];\n            }\n        }\n\n        return slow;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n * 时间复杂度：o (n)\n * 空间复杂度：o (1)\n\n 3. 相向双指针方法\n\n基于元素顺序可以改变的题目描述改变了元素相对位置，确保了移动最少元素。\n\n操作如下：\n\n * 找左边等于 val 的元素\n * 找右边不等于 val 的元素\n * 将右边不等于 val 的元素覆盖左边等于 val 的元素\n\nclass solution {\npublic:\n    int removeelement(vector<int>& nums, int val) {\n        int size = nums.size();\n        int right = size - 1,left = 0;\n\n        while(left <= right){\n            // 找左边等于val的元素\n            while(left <= right && nums[left] != val){ \n                ++left; \n            }\n            // 找右边不等于val的元素\n            while(left <= right && nums[right] == val){\n                --right;\n            }\n            // 将右边不等于val的元素覆盖左边等于val的元素\n            if(left <= right){\n                nums[left++] = nums[right--];\n            }\n       }\n\n       return left; // nums[left++],刚好指向了下一个元素，下标 = 元素个数\n        \t\t\t// right指向上一个元素，需要+1\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 困难点\n\n 1. 暴力移动元素时考虑不完善，没有考虑到挨着的重复元素，直接 ++i 跳过了。\n 2. 双指针中！= 写法很简洁，没有想到\n\n\n# 拓展\n\n\n# 35. 搜索插入位置\n\n\n# 34. 在排序数组中查找元素的第一个和最后一个位置\n\n\n# 总结\n\n 1. 数组的元素是不能删的，只能覆盖。\n 2. 细节考虑不周。",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "Day02-数组",
      "frontmatter": {
        "title": "Day02-数组",
        "date": "2023-05-25T01:28:41.000Z",
        "permalink": "/pages/f2d3aa/",
        "categories": [
          "算法",
          "算法打卡"
        ],
        "tags": [
          "打卡"
        ]
      },
      "regularPath": "/02.%E7%AE%97%E6%B3%95/01.%E7%AE%97%E6%B3%95%E6%89%93%E5%8D%A1/02.Day02-%E6%95%B0%E7%BB%84.html",
      "relativePath": "02.算法/01.算法打卡/02.Day02-数组.md",
      "key": "v-21be97d0",
      "path": "/pages/f2d3aa/",
      "headers": [
        {
          "level": 2,
          "title": "977.有序数组的平方",
          "slug": "_977-有序数组的平方",
          "normalizedTitle": "977. 有序数组的平方",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "录前想法",
          "slug": "录前想法",
          "normalizedTitle": "录前想法",
          "charIndex": 120
        },
        {
          "level": 3,
          "title": "录后想法",
          "slug": "录后想法",
          "normalizedTitle": "录后想法",
          "charIndex": 1382
        },
        {
          "level": 3,
          "title": "困难点",
          "slug": "困难点",
          "normalizedTitle": "困难点",
          "charIndex": 2110
        },
        {
          "level": 2,
          "title": "209.长度最小的子数组",
          "slug": "_209-长度最小的子数组",
          "normalizedTitle": "209. 长度最小的子数组",
          "charIndex": 16
        },
        {
          "level": 3,
          "title": "录前想法",
          "slug": "录前想法-2",
          "normalizedTitle": "录前想法",
          "charIndex": 120
        },
        {
          "level": 3,
          "title": "录后想法",
          "slug": "录后想法-2",
          "normalizedTitle": "录后想法",
          "charIndex": 1382
        },
        {
          "level": 3,
          "title": "困难点",
          "slug": "困难点-2",
          "normalizedTitle": "困难点",
          "charIndex": 2110
        },
        {
          "level": 2,
          "title": "59.螺旋矩阵II",
          "slug": "_59-螺旋矩阵ii",
          "normalizedTitle": "59. 螺旋矩阵 ii",
          "charIndex": 31
        },
        {
          "level": 3,
          "title": "录前想法",
          "slug": "录前想法-3",
          "normalizedTitle": "录前想法",
          "charIndex": 120
        },
        {
          "level": 3,
          "title": "录后想法",
          "slug": "录后想法-3",
          "normalizedTitle": "录后想法",
          "charIndex": 1382
        },
        {
          "level": 3,
          "title": "困难点",
          "slug": "困难点-3",
          "normalizedTitle": "困难点",
          "charIndex": 2110
        },
        {
          "level": 2,
          "title": "总结",
          "slug": "总结",
          "normalizedTitle": "总结",
          "charIndex": 44
        }
      ],
      "excerpt": "<blockquote>\n<p>977. 有序数组的平方 ，209. 长度最小的子数组 ，59. 螺旋矩阵 II ，总结</p>\n</blockquote>\n",
      "lastUpdated": "5/25/2023, 4:51:09 PM",
      "lastUpdatedTimestamp": 1685004669000,
      "headersStr": "977.有序数组的平方 录前想法 录后想法 困难点 209.长度最小的子数组 录前想法 录后想法 困难点 59.螺旋矩阵II 录前想法 录后想法 困难点 总结",
      "content": "> 977. 有序数组的平方 ，209. 长度最小的子数组 ，59. 螺旋矩阵 II ，总结\n\n\n# 977. 有序数组的平方\n\n * 题目：977. 有序数组的平方\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：理解双指针思想\n\n\n# 录前想法\n\n我的思路是用双指针，找到负数的最大值，正数的最小值，然后交换，不额外申请新的空间【未实现❌】\n\n类似冒牌排序，将大的元素冒泡上去。\n\nclass Solution {\npublic:\n    vector<int> sortedSquares(vector<int>& nums) {\n        int fast = 0,slow = 0;\n        int size = nums.size();\n        int tmp = 0;\n\n        if (nums[fast] >= 0){\n            return plus(nums,size);\n        }else{\n            // 找到第一个正数，包括0\n            while(nums[fast] < 0){++fast;}\n        }\n\n        for(;fast < size,slow > 0;){\n            // -4 -1 0 3 10\n            // -4  0 1 3 10 \n            // 0   4 1 3 10\n            // 0   1 4 3 10\n            // 0   1 3 4 10\n            // 平方\n            if(nums[fast] < -nums[slow]){\n                tmp = nums[fast];\n                nums[fast] = -nums[slow];\n                nums[slow] = tmp;\n                --slow;\n            }else{\n                tmp = nums[fast];\n                nums[fast] = -nums[slow];\n                nums[slow] = tmp;\n            }\n        }\n\n        return plus(nums,size);\n    }\n\n    vector<int> plus(vector<int>& nums,int size){\n\n        for(int i = 0;i < size;++i){\n            nums[i] = nums[i]*nums[i];\n        }\n\n        return nums;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n# 录后想法\n\n看完卡哥的题解后发现自己写的有点画蛇添足，冒泡不如暴力自带的排序时间复杂度低😥\n\n发现随想录里的双指针是用了额外空间的，下次练习要先考虑 AC 再考虑优化。\n\n\n\nclass Solution {\npublic:\n    vector<int> sortedSquares(vector<int>& nums) {\n       \n       int size = nums.size();\n       // 额外空间\n       vector<int> ans(size,0);\n       // 指向最大元素\n       int p = size - 1;\n\n       for(int left = 0,right = p;left <= right;){\n           if(nums[left]*nums[left] < nums[right]*nums[right]){\n               ans[p--] = nums[right]*nums[right];\n               --right;\n           }else{\n                ans[p--] = nums[left]*nums[left];\n                ++left;\n           }\n       }\n\n       return ans;\n    }\n\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n * 时间复杂度：O (n)\n * 空间复杂度：O (n)\n\n\n# 困难点\n\n * 想不到双指针的移动\n\n\n# 209. 长度最小的子数组\n\n * 题目：209. 长度最小的子数组\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：理解滑动窗口\n\n\n# 录前想法\n\n我的思路：先排序然后从小到大不断缩小范围找到最小子数组\n\nclass Solution {\npublic:\n    int minSubArrayLen(int target, vector<int>& nums) {\n\n        int size = nums.size();\n        \n        // 排序\n        sort(nums.begin(), nums.end());\n\n        // 双指针\n        int ans = size + 1,sum = 0;\n\n        for (int left = 0,right = 0; right < nums.size(); ++right){\n            sum += nums[right]; \n            while(sum >= target){\n                ans = min(right - left + 1,ans);\n                sum -= nums[left++];\n            }\n        }\n\n        if (ans == size + 1){\n            return 0;\n        }else{\n            return ans;\n        }\n        \n    }\n\n    int min(int a,int b){\n        return a > b ? b : a;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n * 时间复杂度：O (n)\n * 空间复杂度：O (1)\n\n没有通过，卡在了第 17 个测试用例\n\n213\n[12,28,83,4,25,26,25,2,25,25,25,12]\n// 正确 8\n// 我的 7\n\n\n1\n2\n3\n4\n\n\n经过排查，发现是因为排序导致了顺序出错了，不能排序\n\n将 sort 注释即通过\n\n\n# 录后想法\n\n和卡哥的思路相同，在写法有不同，主要是在三目运算。\n\n修改后代码如下\n\nclass Solution {\npublic:\n    int minSubArrayLen(int target, vector<int>& nums) {\n\n        int size = nums.size();\n        int ans = size + 1,sum = 0,tmpSub = 0;\n\n        // 双指针\n        for (int left = 0,right = 0; right < nums.size(); ++right){\n            sum += nums[right]; \n            while(sum >= target){\n                // 窗口内元素\n                tmpSub = right - left + 1;\n                ans = tmpSub > ans ? ans : tmpSub;\n                sum -= nums[left++];\n            }\n        }\n\n        return ans == size + 1 ? 0 : ans;        \n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n * 时间复杂度：O (n)\n * 空间复杂度：O (1)\n\n\n# 困难点\n\n * 顺序是否可以被打乱（排序）\n\n\n# 59. 螺旋矩阵 II\n\n * 题目：59. 螺旋矩阵 II\n * 讲解：文章讲解、视频讲解\n * 要求：转圈的逻辑和区间定义\n\n\n# 录前想法\n\n分为四部，然后通过判断需要循环的圈数为 n/2 ，直接 AC\n\nclass Solution {\npublic:\n    vector<vector<int>> generateMatrix(int n) {\n        // 定义结果集\n        vector<vector<int>> ans(n, vector<int>(n, 0));\n        int left = 0, up = 0,sum = 1;\n\n        for(int j = 0; j <= n/2; j++){\n            // 左 -> 右\n            for(int i = left; i < n - left; ++i ){\n                ans[left][i] = sum++;\n            }\n            ++left;\n\n            // 上 -> 下\n            for(int i = up + 1; i < n - up; ++i ){\n                ans[i][n - up - 1] = sum++;\n            }\n            ++up;\n\n            // 右 -> 左\n            for(int i = n - left - 1; i >= left - 1; --i){\n                ans[n - left][i] = sum++;\n            }\n\n            // 下 -> 上\n            for(int i = n - up - 1; i >= up; --i){\n                ans[i][up - 1] = sum++;\n            }\n        }\n\n        return ans;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n * 时间复杂度 O (n^2)\n * 空间复杂度 O (1)\n\n\n# 录后想法\n\n和卡哥思路差不多🆗\n\n\n# 困难点\n\n * 需要仔细判断从哪开始到哪结束\n\n\n# 总结\n\n 1. 先考虑完成题目\n 2. 双指针需要灵活使用，不能死板\n 3. 注意条件中顺序是否能被打乱（排序）",
      "normalizedContent": "> 977. 有序数组的平方 ，209. 长度最小的子数组 ，59. 螺旋矩阵 ii ，总结\n\n\n# 977. 有序数组的平方\n\n * 题目：977. 有序数组的平方\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：理解双指针思想\n\n\n# 录前想法\n\n我的思路是用双指针，找到负数的最大值，正数的最小值，然后交换，不额外申请新的空间【未实现❌】\n\n类似冒牌排序，将大的元素冒泡上去。\n\nclass solution {\npublic:\n    vector<int> sortedsquares(vector<int>& nums) {\n        int fast = 0,slow = 0;\n        int size = nums.size();\n        int tmp = 0;\n\n        if (nums[fast] >= 0){\n            return plus(nums,size);\n        }else{\n            // 找到第一个正数，包括0\n            while(nums[fast] < 0){++fast;}\n        }\n\n        for(;fast < size,slow > 0;){\n            // -4 -1 0 3 10\n            // -4  0 1 3 10 \n            // 0   4 1 3 10\n            // 0   1 4 3 10\n            // 0   1 3 4 10\n            // 平方\n            if(nums[fast] < -nums[slow]){\n                tmp = nums[fast];\n                nums[fast] = -nums[slow];\n                nums[slow] = tmp;\n                --slow;\n            }else{\n                tmp = nums[fast];\n                nums[fast] = -nums[slow];\n                nums[slow] = tmp;\n            }\n        }\n\n        return plus(nums,size);\n    }\n\n    vector<int> plus(vector<int>& nums,int size){\n\n        for(int i = 0;i < size;++i){\n            nums[i] = nums[i]*nums[i];\n        }\n\n        return nums;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n# 录后想法\n\n看完卡哥的题解后发现自己写的有点画蛇添足，冒泡不如暴力自带的排序时间复杂度低😥\n\n发现随想录里的双指针是用了额外空间的，下次练习要先考虑 ac 再考虑优化。\n\n\n\nclass solution {\npublic:\n    vector<int> sortedsquares(vector<int>& nums) {\n       \n       int size = nums.size();\n       // 额外空间\n       vector<int> ans(size,0);\n       // 指向最大元素\n       int p = size - 1;\n\n       for(int left = 0,right = p;left <= right;){\n           if(nums[left]*nums[left] < nums[right]*nums[right]){\n               ans[p--] = nums[right]*nums[right];\n               --right;\n           }else{\n                ans[p--] = nums[left]*nums[left];\n                ++left;\n           }\n       }\n\n       return ans;\n    }\n\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n * 时间复杂度：o (n)\n * 空间复杂度：o (n)\n\n\n# 困难点\n\n * 想不到双指针的移动\n\n\n# 209. 长度最小的子数组\n\n * 题目：209. 长度最小的子数组\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：理解滑动窗口\n\n\n# 录前想法\n\n我的思路：先排序然后从小到大不断缩小范围找到最小子数组\n\nclass solution {\npublic:\n    int minsubarraylen(int target, vector<int>& nums) {\n\n        int size = nums.size();\n        \n        // 排序\n        sort(nums.begin(), nums.end());\n\n        // 双指针\n        int ans = size + 1,sum = 0;\n\n        for (int left = 0,right = 0; right < nums.size(); ++right){\n            sum += nums[right]; \n            while(sum >= target){\n                ans = min(right - left + 1,ans);\n                sum -= nums[left++];\n            }\n        }\n\n        if (ans == size + 1){\n            return 0;\n        }else{\n            return ans;\n        }\n        \n    }\n\n    int min(int a,int b){\n        return a > b ? b : a;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n * 时间复杂度：o (n)\n * 空间复杂度：o (1)\n\n没有通过，卡在了第 17 个测试用例\n\n213\n[12,28,83,4,25,26,25,2,25,25,25,12]\n// 正确 8\n// 我的 7\n\n\n1\n2\n3\n4\n\n\n经过排查，发现是因为排序导致了顺序出错了，不能排序\n\n将 sort 注释即通过\n\n\n# 录后想法\n\n和卡哥的思路相同，在写法有不同，主要是在三目运算。\n\n修改后代码如下\n\nclass solution {\npublic:\n    int minsubarraylen(int target, vector<int>& nums) {\n\n        int size = nums.size();\n        int ans = size + 1,sum = 0,tmpsub = 0;\n\n        // 双指针\n        for (int left = 0,right = 0; right < nums.size(); ++right){\n            sum += nums[right]; \n            while(sum >= target){\n                // 窗口内元素\n                tmpsub = right - left + 1;\n                ans = tmpsub > ans ? ans : tmpsub;\n                sum -= nums[left++];\n            }\n        }\n\n        return ans == size + 1 ? 0 : ans;        \n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n * 时间复杂度：o (n)\n * 空间复杂度：o (1)\n\n\n# 困难点\n\n * 顺序是否可以被打乱（排序）\n\n\n# 59. 螺旋矩阵 ii\n\n * 题目：59. 螺旋矩阵 ii\n * 讲解：文章讲解、视频讲解\n * 要求：转圈的逻辑和区间定义\n\n\n# 录前想法\n\n分为四部，然后通过判断需要循环的圈数为 n/2 ，直接 ac\n\nclass solution {\npublic:\n    vector<vector<int>> generatematrix(int n) {\n        // 定义结果集\n        vector<vector<int>> ans(n, vector<int>(n, 0));\n        int left = 0, up = 0,sum = 1;\n\n        for(int j = 0; j <= n/2; j++){\n            // 左 -> 右\n            for(int i = left; i < n - left; ++i ){\n                ans[left][i] = sum++;\n            }\n            ++left;\n\n            // 上 -> 下\n            for(int i = up + 1; i < n - up; ++i ){\n                ans[i][n - up - 1] = sum++;\n            }\n            ++up;\n\n            // 右 -> 左\n            for(int i = n - left - 1; i >= left - 1; --i){\n                ans[n - left][i] = sum++;\n            }\n\n            // 下 -> 上\n            for(int i = n - up - 1; i >= up; --i){\n                ans[i][up - 1] = sum++;\n            }\n        }\n\n        return ans;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n * 时间复杂度 o (n^2)\n * 空间复杂度 o (1)\n\n\n# 录后想法\n\n和卡哥思路差不多🆗\n\n\n# 困难点\n\n * 需要仔细判断从哪开始到哪结束\n\n\n# 总结\n\n 1. 先考虑完成题目\n 2. 双指针需要灵活使用，不能死板\n 3. 注意条件中顺序是否能被打乱（排序）",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "Day03-链表",
      "frontmatter": {
        "title": "Day03-链表",
        "date": "2023-05-26T00:55:34.000Z",
        "permalink": "/pages/2c5009/",
        "categories": [
          "算法",
          "算法打卡"
        ],
        "tags": [
          "打卡"
        ]
      },
      "regularPath": "/02.%E7%AE%97%E6%B3%95/01.%E7%AE%97%E6%B3%95%E6%89%93%E5%8D%A1/03.Day03-%E9%93%BE%E8%A1%A8.html",
      "relativePath": "02.算法/01.算法打卡/03.Day03-链表.md",
      "key": "v-c042b388",
      "path": "/pages/2c5009/",
      "headers": [
        {
          "level": 2,
          "title": "链表理论基础",
          "slug": "链表理论基础",
          "normalizedTitle": "链表理论基础",
          "charIndex": 51
        },
        {
          "level": 2,
          "title": "203.移除链表元素",
          "slug": "_203-移除链表元素",
          "normalizedTitle": "203. 移除链表元素",
          "charIndex": 98
        },
        {
          "level": 3,
          "title": "录前想法",
          "slug": "录前想法",
          "normalizedTitle": "录前想法",
          "charIndex": 166
        },
        {
          "level": 3,
          "title": "录后想法",
          "slug": "录后想法",
          "normalizedTitle": "录后想法",
          "charIndex": 852
        },
        {
          "level": 3,
          "title": "总结",
          "slug": "总结",
          "normalizedTitle": "总结",
          "charIndex": 44
        },
        {
          "level": 2,
          "title": "707.设计链表",
          "slug": "_707-设计链表",
          "normalizedTitle": "707. 设计链表",
          "charIndex": 1609
        },
        {
          "level": 3,
          "title": "录前想法",
          "slug": "录前想法-2",
          "normalizedTitle": "录前想法",
          "charIndex": 166
        },
        {
          "level": 3,
          "title": "录后想法",
          "slug": "录后想法-2",
          "normalizedTitle": "录后想法",
          "charIndex": 852
        },
        {
          "level": 3,
          "title": "总结",
          "slug": "总结-2",
          "normalizedTitle": "总结",
          "charIndex": 44
        },
        {
          "level": 2,
          "title": "206.反转链表",
          "slug": "_206-反转链表",
          "normalizedTitle": "206. 反转链表",
          "charIndex": 6752
        },
        {
          "level": 3,
          "title": "录前想法",
          "slug": "录前想法-3",
          "normalizedTitle": "录前想法",
          "charIndex": 166
        },
        {
          "level": 3,
          "title": "录后想法",
          "slug": "录后想法-3",
          "normalizedTitle": "录后想法",
          "charIndex": 852
        },
        {
          "level": 3,
          "title": "总结",
          "slug": "总结-3",
          "normalizedTitle": "总结",
          "charIndex": 44
        },
        {
          "level": 2,
          "title": "总结",
          "slug": "总结-4",
          "normalizedTitle": "总结",
          "charIndex": 44
        }
      ],
      "excerpt": "<blockquote>\n<p>977. 有序数组的平方 ，209. 长度最小的子数组 ，59. 螺旋矩阵 II ，总结</p>\n</blockquote>\n",
      "lastUpdated": "5/26/2023, 11:40:05 PM",
      "lastUpdatedTimestamp": 1685115605000,
      "headersStr": "链表理论基础 203.移除链表元素 录前想法 录后想法 总结 707.设计链表 录前想法 录后想法 总结 206.反转链表 录前想法 录后想法 总结 总结",
      "content": "> 977. 有序数组的平方 ，209. 长度最小的子数组 ，59. 螺旋矩阵 II ，总结\n\n\n# 链表理论基础\n\n * 讲解：文章讲解\n * 要求：了解链接基础，以及链表和数组的区别\n\n\n# 203. 移除链表元素\n\n * 题目：203. 移除链表元素\n * 讲解：文章讲解、视频讲解\n * 要求：虚拟头结点的使用技巧\n\n\n# 录前想法\n\n我想的是判断空，通过虚拟头节点比对下一个节点来删除元素（未通过❌）\n\nclass Solution {\npublic:\n    ListNode* removeElements(ListNode* head, int val) {\n\n        // 判断空\n        if (head == NULL){\n            return head;\n        }\n\n        // 虚拟头节点\n        ListNode* newHead = new ListNode(0);\n        newHead->next = head;\n        // 操作指针\n        ListNode* cur = newHead;\n\n        while(cur->next != NULL){\n            if(cur->next->val == val){\n                cur->next = cur->next->next;\n            }\n            cur = cur->next;\n        } \n\n        return newHead->next;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n错在空指针，\n\n在删除节点后，如果下一个节点也需要被删除，那么当前指针 cur 应该保持不变，以便检查下一个节点\n\n\n# 录后想法\n\n看过卡哥思路后发现\n\n 1. 做了删除节点判断\n 2. 内存管理（销毁删除节点内存）\n\nclass Solution {\npublic:\n    ListNode* removeElements(ListNode* head, int val) {\n\n        // 判断空\n        if (head == NULL){\n            return head;\n        }\n\n        // 虚拟头节点\n        ListNode* newHead = new ListNode(0);\n        newHead->next = head;\n        // 操作指针\n        ListNode* cur = newHead;\n\n        while(cur->next != NULL){\n            if(cur->next->val == val){\n                ListNode* tmp = cur->next;\n                cur->next = cur->next->next;\n                delete tmp; // 销毁内存\n            }else{\n                cur = cur->next;\n            }  \n        } \n\n        return newHead->next;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 总结\n\n\n# 707. 设计链表\n\n * 题目：707. 设计链表\n * 讲解：文章讲解、视频讲解\n * 要求：掌握链表综合操作\n\n\n# 录前想法\n\n坎坎坷坷的，没有写出来，不知道从何下手\n\n看了一眼卡哥的代码，发现要自己定义结构体，自己写构造函数😓\n\n下面是第一次提交的错误代码（❌）\n\nclass MyLinkedList {\npublic:\n    // 定义链表节点结构体\n    struct LinkedNode {\n        int val;\n        LinkedNode* next;\n        LinkedNode(int val):val(val), next(nullptr){}\n    };\n\n    MyLinkedList() {\n        head = new LinkedNode(0);\n        size = 0;\n    }\n\n    int get(int index) {\n        // index表示下标从0开始\n        if(index > size - 1 || index < 0){\n            return -1;\n        }\n\n        LinkedNode* cur = head->next;\n        while(index--){\n            cur = cur->next;\n        }\n        return cur->val;\n    }\n    \n    void addAtHead(int val) {\n        LinkedNode* node = new LinkedNode(val);\n        node->next = head->next;\n        head->next = node;\n        ++size;\n    }\n    \n    void addAtTail(int val) {\n        LinkedNode* node = new LinkedNode(val);\n        LinkedNode* cur = head->next;\n        while(cur->next){\n            cur = cur->next;\n        }\n        cur->next = node;\n        ++size;\n    }\n    \n    void addAtIndex(int index, int val) {\n        // index表示下标从0开始\n        if(index > size){\n            return;\n        }\n        if(index < 0){\n            addAtHead(val);\n            return;\n        }\n\n        LinkedNode* cur = head;\n        while(index--){\n            cur = cur->next;\n        }\n\n        // 1->2\n        LinkedNode* node = new LinkedNode(val);\n        // 2->3\n        node->next = cur->next;\n        // 1->2->3\n        cur->next = node;\n        size++;\n    }\n    \n    void deleteAtIndex(int index) {\n        // index表示下标从0开始\n        if(index >= size - 1 || index < 0){return;}\n\n        // 获取待删除元素的前一个元素\n        LinkedNode* cur = head;\n        while(index--){\n            cur = cur->next;\n        }\n\n        LinkedNode* tmp = cur->next;\n        cur->next = cur->next->next;\n        delete tmp;\n        tmp = nullptr;\n\n        size--;\n    }\nprivate:\n    int size;\n    LinkedNode* head;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n\n\n经过调试喝排查，发现\n\nint get(int index) {\n    // index表示下标从0开始\n    if(index > (size - 1) || index < 0){ // 应该要加上括号！！！\n        return -1;\n    }\n\n    ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nvoid deleteAtIndex(int index) {\n    // index表示下标从0开始\n    if(index >= (size - 1) || index < 0){return;} // 应该要加上括号！！！\n\n    ...\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 录后想法\n\n一些内存管理还不熟，比如删除元素时 tmp 的处理，只单纯的 delete，没有置为空。\n\n    // 删除第index个节点，如果index 大于等于链表的长度，直接return，注意index是从0开始的\n    void deleteAtIndex(int index) {\n        ...\n        delete tmp;\n        //delete命令指示释放了tmp指针原本所指的那部分内存，\n        //被delete后的指针tmp的值（地址）并非就是NULL，而是随机值。也就是被delete后，\n        //如果不再加上一句tmp=nullptr,tmp会成为乱指的野指针\n        //如果之后的程序不小心使用了tmp，会指向难以预想的内存空间\n        tmp=nullptr;\n        _size--;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n以下是后面结合卡哥讲解后的代码（✅）\n\nclass MyLinkedList {\npublic:\n    // 定义链表节点结构体\n    struct LinkedNode {\n        int val;\n        LinkedNode* next;\n        LinkedNode(int val):val(val), next(nullptr){}\n    };\n\n    MyLinkedList() {\n        head = new LinkedNode(0);\n        size = 0;\n    }\n\n    int get(int index) {\n        // index表示下标从0开始\n        if(index > (size - 1) || index < 0){\n            return -1;\n        }\n\n        LinkedNode* cur = head->next;\n        while(index--){\n            cur = cur->next;\n        }\n        return cur->val;\n    }\n    \n    void addAtHead(int val) {\n        LinkedNode* node = new LinkedNode(val);\n        node->next = head->next;\n        head->next = node;\n        ++size;\n    }\n    \n    void addAtTail(int val) {\n        LinkedNode* node = new LinkedNode(val);\n        LinkedNode* cur = head;\n        while(cur->next){\n            cur = cur->next;\n        }\n        cur->next = node;\n        ++size;\n    }\n    \n    void addAtIndex(int index, int val) {\n        // index表示下标从0开始\n        if(index > size){\n            return;\n        }\n        if(index < 0){\n            index = 0;\n        }\n\n        LinkedNode* cur = head;\n        while(index--){\n            cur = cur->next;\n        }\n\n        // 1->2\n        LinkedNode* node = new LinkedNode(val);\n        // 2->3\n        node->next = cur->next;\n        // 1->2->3\n        cur->next = node;\n        size++;\n    }\n    \n    void deleteAtIndex(int index) {\n        // index表示下标从0开始\n        if(index > (size - 1) || index < 0){return;}\n\n        // 获取待删除元素的前一个元素\n        LinkedNode* cur = head;\n        while(index--){\n            cur = cur->next;\n        }\n\n        LinkedNode* tmp = cur->next;\n        cur->next = cur->next->next;\n        delete tmp;\n        tmp = nullptr;\n\n        size--;\n    }\nprivate:\n    int size;\n    LinkedNode* head;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n\n\n\n# 总结\n\n 1. 判断元素越界时，若要做运算要加上括号\n 2. 虚拟头节点很方便\n    1. 可以找到元素的前一个节点，方便删除和插入\n    2. 可以直接到指定元素结点\n\n\n# 206. 反转链表\n\n * 题目：206. 反转链表\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：双指针应用\n\n\n# 录前想法\n\n双指针反转，全部后指前，下面代码（❌）\n\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n\n        // 虚拟头节点\n        ListNode* newHead = new ListNode(0);\n        newHead->next = head;\n\n        ListNode* pre = newHead;\n        ListNode* cur = newHead->next;\n        while(cur && cur->next){\n            ListNode* tmp = cur->next;\n            cur->next = pre;\n            pre = cur;\n            cur = tmp; \n        }\n\n        return newHead->next;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n经过调试检查后发现以下几点错误：\n\n 1. 虚拟头节点多余\n 2. pre 初始值不正确\n 3. 返回值错误\n\n\n# 录后想法\n\n>  1. 双指针\n\n看过卡哥的讲解后，优化了上面的代码（✅）\n\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n\n        ListNode* pre = NULL;\n        ListNode* cur = head;\n        ListNode* tmp;\n\n        while(cur){\n            tmp = cur->next;\n            cur->next = pre;\n            pre = cur;\n            cur = tmp; \n        }\n\n        return pre;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n * 时间复杂度：O（n）\n * 空间复杂度：O（1）\n\n>  2. 递归\n\n核心思路没变，利用递归巧妙的对应了双指针 while 循环。\n\nclass Solution {\npublic:\n    ListNode* reverse(ListNode* pre,ListNode* cur) {\n\n        // 对应双指针的return pre;\n        if(cur == NULL){return pre;}\n        \n        ListNode* tmp = cur->next;\n        cur->next = pre;\n        \n        // 巧妙的对应\n        // pre = cur;\n        // cur = tmp;\n        return reverse(cur,tmp);\n\n    }\n\n    ListNode* reverseList(ListNode* head) {\n\n        return reverse(NULL,head);\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n * 时间复杂度: O (n)\n * 空间复杂度: O (n)\n\n\n# 总结\n\n * 反转：后 -> 前\n\n\n# 总结\n\n这次写的时间比较久，在中间设计链表部分卡的时间长，看似链表的那些基础操作容易，自己上手写大大小小的错误就出来了。\n\n容易错的点：\n\n 1. 忘记删除完元素要 delete，且置为空\n 2. 是否需要虚拟头节点？",
      "normalizedContent": "> 977. 有序数组的平方 ，209. 长度最小的子数组 ，59. 螺旋矩阵 ii ，总结\n\n\n# 链表理论基础\n\n * 讲解：文章讲解\n * 要求：了解链接基础，以及链表和数组的区别\n\n\n# 203. 移除链表元素\n\n * 题目：203. 移除链表元素\n * 讲解：文章讲解、视频讲解\n * 要求：虚拟头结点的使用技巧\n\n\n# 录前想法\n\n我想的是判断空，通过虚拟头节点比对下一个节点来删除元素（未通过❌）\n\nclass solution {\npublic:\n    listnode* removeelements(listnode* head, int val) {\n\n        // 判断空\n        if (head == null){\n            return head;\n        }\n\n        // 虚拟头节点\n        listnode* newhead = new listnode(0);\n        newhead->next = head;\n        // 操作指针\n        listnode* cur = newhead;\n\n        while(cur->next != null){\n            if(cur->next->val == val){\n                cur->next = cur->next->next;\n            }\n            cur = cur->next;\n        } \n\n        return newhead->next;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n错在空指针，\n\n在删除节点后，如果下一个节点也需要被删除，那么当前指针 cur 应该保持不变，以便检查下一个节点\n\n\n# 录后想法\n\n看过卡哥思路后发现\n\n 1. 做了删除节点判断\n 2. 内存管理（销毁删除节点内存）\n\nclass solution {\npublic:\n    listnode* removeelements(listnode* head, int val) {\n\n        // 判断空\n        if (head == null){\n            return head;\n        }\n\n        // 虚拟头节点\n        listnode* newhead = new listnode(0);\n        newhead->next = head;\n        // 操作指针\n        listnode* cur = newhead;\n\n        while(cur->next != null){\n            if(cur->next->val == val){\n                listnode* tmp = cur->next;\n                cur->next = cur->next->next;\n                delete tmp; // 销毁内存\n            }else{\n                cur = cur->next;\n            }  \n        } \n\n        return newhead->next;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 总结\n\n\n# 707. 设计链表\n\n * 题目：707. 设计链表\n * 讲解：文章讲解、视频讲解\n * 要求：掌握链表综合操作\n\n\n# 录前想法\n\n坎坎坷坷的，没有写出来，不知道从何下手\n\n看了一眼卡哥的代码，发现要自己定义结构体，自己写构造函数😓\n\n下面是第一次提交的错误代码（❌）\n\nclass mylinkedlist {\npublic:\n    // 定义链表节点结构体\n    struct linkednode {\n        int val;\n        linkednode* next;\n        linkednode(int val):val(val), next(nullptr){}\n    };\n\n    mylinkedlist() {\n        head = new linkednode(0);\n        size = 0;\n    }\n\n    int get(int index) {\n        // index表示下标从0开始\n        if(index > size - 1 || index < 0){\n            return -1;\n        }\n\n        linkednode* cur = head->next;\n        while(index--){\n            cur = cur->next;\n        }\n        return cur->val;\n    }\n    \n    void addathead(int val) {\n        linkednode* node = new linkednode(val);\n        node->next = head->next;\n        head->next = node;\n        ++size;\n    }\n    \n    void addattail(int val) {\n        linkednode* node = new linkednode(val);\n        linkednode* cur = head->next;\n        while(cur->next){\n            cur = cur->next;\n        }\n        cur->next = node;\n        ++size;\n    }\n    \n    void addatindex(int index, int val) {\n        // index表示下标从0开始\n        if(index > size){\n            return;\n        }\n        if(index < 0){\n            addathead(val);\n            return;\n        }\n\n        linkednode* cur = head;\n        while(index--){\n            cur = cur->next;\n        }\n\n        // 1->2\n        linkednode* node = new linkednode(val);\n        // 2->3\n        node->next = cur->next;\n        // 1->2->3\n        cur->next = node;\n        size++;\n    }\n    \n    void deleteatindex(int index) {\n        // index表示下标从0开始\n        if(index >= size - 1 || index < 0){return;}\n\n        // 获取待删除元素的前一个元素\n        linkednode* cur = head;\n        while(index--){\n            cur = cur->next;\n        }\n\n        linkednode* tmp = cur->next;\n        cur->next = cur->next->next;\n        delete tmp;\n        tmp = nullptr;\n\n        size--;\n    }\nprivate:\n    int size;\n    linkednode* head;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n\n\n经过调试喝排查，发现\n\nint get(int index) {\n    // index表示下标从0开始\n    if(index > (size - 1) || index < 0){ // 应该要加上括号！！！\n        return -1;\n    }\n\n    ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nvoid deleteatindex(int index) {\n    // index表示下标从0开始\n    if(index >= (size - 1) || index < 0){return;} // 应该要加上括号！！！\n\n    ...\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 录后想法\n\n一些内存管理还不熟，比如删除元素时 tmp 的处理，只单纯的 delete，没有置为空。\n\n    // 删除第index个节点，如果index 大于等于链表的长度，直接return，注意index是从0开始的\n    void deleteatindex(int index) {\n        ...\n        delete tmp;\n        //delete命令指示释放了tmp指针原本所指的那部分内存，\n        //被delete后的指针tmp的值（地址）并非就是null，而是随机值。也就是被delete后，\n        //如果不再加上一句tmp=nullptr,tmp会成为乱指的野指针\n        //如果之后的程序不小心使用了tmp，会指向难以预想的内存空间\n        tmp=nullptr;\n        _size--;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n以下是后面结合卡哥讲解后的代码（✅）\n\nclass mylinkedlist {\npublic:\n    // 定义链表节点结构体\n    struct linkednode {\n        int val;\n        linkednode* next;\n        linkednode(int val):val(val), next(nullptr){}\n    };\n\n    mylinkedlist() {\n        head = new linkednode(0);\n        size = 0;\n    }\n\n    int get(int index) {\n        // index表示下标从0开始\n        if(index > (size - 1) || index < 0){\n            return -1;\n        }\n\n        linkednode* cur = head->next;\n        while(index--){\n            cur = cur->next;\n        }\n        return cur->val;\n    }\n    \n    void addathead(int val) {\n        linkednode* node = new linkednode(val);\n        node->next = head->next;\n        head->next = node;\n        ++size;\n    }\n    \n    void addattail(int val) {\n        linkednode* node = new linkednode(val);\n        linkednode* cur = head;\n        while(cur->next){\n            cur = cur->next;\n        }\n        cur->next = node;\n        ++size;\n    }\n    \n    void addatindex(int index, int val) {\n        // index表示下标从0开始\n        if(index > size){\n            return;\n        }\n        if(index < 0){\n            index = 0;\n        }\n\n        linkednode* cur = head;\n        while(index--){\n            cur = cur->next;\n        }\n\n        // 1->2\n        linkednode* node = new linkednode(val);\n        // 2->3\n        node->next = cur->next;\n        // 1->2->3\n        cur->next = node;\n        size++;\n    }\n    \n    void deleteatindex(int index) {\n        // index表示下标从0开始\n        if(index > (size - 1) || index < 0){return;}\n\n        // 获取待删除元素的前一个元素\n        linkednode* cur = head;\n        while(index--){\n            cur = cur->next;\n        }\n\n        linkednode* tmp = cur->next;\n        cur->next = cur->next->next;\n        delete tmp;\n        tmp = nullptr;\n\n        size--;\n    }\nprivate:\n    int size;\n    linkednode* head;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n\n\n\n# 总结\n\n 1. 判断元素越界时，若要做运算要加上括号\n 2. 虚拟头节点很方便\n    1. 可以找到元素的前一个节点，方便删除和插入\n    2. 可以直接到指定元素结点\n\n\n# 206. 反转链表\n\n * 题目：206. 反转链表\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：双指针应用\n\n\n# 录前想法\n\n双指针反转，全部后指前，下面代码（❌）\n\nclass solution {\npublic:\n    listnode* reverselist(listnode* head) {\n\n        // 虚拟头节点\n        listnode* newhead = new listnode(0);\n        newhead->next = head;\n\n        listnode* pre = newhead;\n        listnode* cur = newhead->next;\n        while(cur && cur->next){\n            listnode* tmp = cur->next;\n            cur->next = pre;\n            pre = cur;\n            cur = tmp; \n        }\n\n        return newhead->next;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n经过调试检查后发现以下几点错误：\n\n 1. 虚拟头节点多余\n 2. pre 初始值不正确\n 3. 返回值错误\n\n\n# 录后想法\n\n>  1. 双指针\n\n看过卡哥的讲解后，优化了上面的代码（✅）\n\nclass solution {\npublic:\n    listnode* reverselist(listnode* head) {\n\n        listnode* pre = null;\n        listnode* cur = head;\n        listnode* tmp;\n\n        while(cur){\n            tmp = cur->next;\n            cur->next = pre;\n            pre = cur;\n            cur = tmp; \n        }\n\n        return pre;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n * 时间复杂度：o（n）\n * 空间复杂度：o（1）\n\n>  2. 递归\n\n核心思路没变，利用递归巧妙的对应了双指针 while 循环。\n\nclass solution {\npublic:\n    listnode* reverse(listnode* pre,listnode* cur) {\n\n        // 对应双指针的return pre;\n        if(cur == null){return pre;}\n        \n        listnode* tmp = cur->next;\n        cur->next = pre;\n        \n        // 巧妙的对应\n        // pre = cur;\n        // cur = tmp;\n        return reverse(cur,tmp);\n\n    }\n\n    listnode* reverselist(listnode* head) {\n\n        return reverse(null,head);\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n * 时间复杂度: o (n)\n * 空间复杂度: o (n)\n\n\n# 总结\n\n * 反转：后 -> 前\n\n\n# 总结\n\n这次写的时间比较久，在中间设计链表部分卡的时间长，看似链表的那些基础操作容易，自己上手写大大小小的错误就出来了。\n\n容易错的点：\n\n 1. 忘记删除完元素要 delete，且置为空\n 2. 是否需要虚拟头节点？",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "Day00-准备",
      "frontmatter": {
        "title": "Day00-准备",
        "date": "2023-05-26T23:35:49.000Z",
        "permalink": "/pages/fc80dd/",
        "categories": [
          "算法",
          "算法打卡"
        ],
        "tags": [
          null
        ]
      },
      "regularPath": "/02.%E7%AE%97%E6%B3%95/01.%E7%AE%97%E6%B3%95%E6%89%93%E5%8D%A1/00.Day00-%E5%87%86%E5%A4%87.html",
      "relativePath": "02.算法/01.算法打卡/00.Day00-准备.md",
      "key": "v-2ee9027a",
      "path": "/pages/fc80dd/",
      "headers": [
        {
          "level": 2,
          "title": "格式",
          "slug": "格式",
          "normalizedTitle": "格式",
          "charIndex": 11
        },
        {
          "level": 3,
          "title": "录前想法",
          "slug": "录前想法",
          "normalizedTitle": "录前想法",
          "charIndex": 60
        },
        {
          "level": 3,
          "title": "录后想法",
          "slug": "录后想法",
          "normalizedTitle": "录后想法",
          "charIndex": 69
        },
        {
          "level": 3,
          "title": "总结",
          "slug": "总结",
          "normalizedTitle": "总结",
          "charIndex": 78
        },
        {
          "level": 2,
          "title": "常用表情",
          "slug": "常用表情",
          "normalizedTitle": "常用表情",
          "charIndex": 85
        }
      ],
      "excerpt": "<blockquote>\n<p>前置准备</p>\n</blockquote>\n",
      "lastUpdated": "5/30/2023, 1:15:52 AM",
      "lastUpdatedTimestamp": 1685380552000,
      "headersStr": "格式 录前想法 录后想法 总结 常用表情",
      "content": "> 前置准备\n\n\n# 格式\n\n * 题目：704. 二分查找\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：\n\n\n# 录前想法\n\n\n# 录后想法\n\n\n# 总结\n\n\n# 常用表情\n\n❌\n\n✔️\n\n😂\n\n😰\n\n😓\n\n✌️",
      "normalizedContent": "> 前置准备\n\n\n# 格式\n\n * 题目：704. 二分查找\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：\n\n\n# 录前想法\n\n\n# 录后想法\n\n\n# 总结\n\n\n# 常用表情\n\n❌\n\n✔️\n\n😂\n\n😰\n\n😓\n\n✌️",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "Day04-链表",
      "frontmatter": {
        "title": "Day04-链表",
        "date": "2023-05-27T00:19:58.000Z",
        "permalink": "/pages/115af7/",
        "categories": [
          "算法",
          "算法打卡"
        ],
        "tags": [
          "打卡"
        ]
      },
      "regularPath": "/02.%E7%AE%97%E6%B3%95/01.%E7%AE%97%E6%B3%95%E6%89%93%E5%8D%A1/04.Day04-%E9%93%BE%E8%A1%A8.html",
      "relativePath": "02.算法/01.算法打卡/04.Day04-链表.md",
      "key": "v-72f05d08",
      "path": "/pages/115af7/",
      "headers": [
        {
          "level": 2,
          "title": "24. 两两交换链表中的节点",
          "slug": "_24-两两交换链表中的节点",
          "normalizedTitle": "24. 两两交换链表中的节点",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "录前想法",
          "slug": "录前想法",
          "normalizedTitle": "录前想法",
          "charIndex": 140
        },
        {
          "level": 3,
          "title": "录后想法",
          "slug": "录后想法",
          "normalizedTitle": "录后想法",
          "charIndex": 1882
        },
        {
          "level": 3,
          "title": "总结",
          "slug": "总结",
          "normalizedTitle": "总结",
          "charIndex": 964
        },
        {
          "level": 2,
          "title": "19.删除链表的倒数第N个节点",
          "slug": "_19-删除链表的倒数第n个节点",
          "normalizedTitle": "19. 删除链表的倒数第 n 个节点",
          "charIndex": 17
        },
        {
          "level": 3,
          "title": "录前想法",
          "slug": "录前想法-2",
          "normalizedTitle": "录前想法",
          "charIndex": 140
        },
        {
          "level": 3,
          "title": "录后想法",
          "slug": "录后想法-2",
          "normalizedTitle": "录后想法",
          "charIndex": 1882
        },
        {
          "level": 3,
          "title": "总结",
          "slug": "总结-2",
          "normalizedTitle": "总结",
          "charIndex": 964
        },
        {
          "level": 2,
          "title": "面试题 02.07. 链表相交",
          "slug": "面试题-02-07-链表相交",
          "normalizedTitle": "面试题 02.07. 链表相交",
          "charIndex": 36
        },
        {
          "level": 3,
          "title": "录前想法",
          "slug": "录前想法-3",
          "normalizedTitle": "录前想法",
          "charIndex": 140
        },
        {
          "level": 3,
          "title": "录后想法",
          "slug": "录后想法-3",
          "normalizedTitle": "录后想法",
          "charIndex": 1882
        },
        {
          "level": 3,
          "title": "总结",
          "slug": "总结-3",
          "normalizedTitle": "总结",
          "charIndex": 964
        },
        {
          "level": 2,
          "title": "142.环形链表II",
          "slug": "_142-环形链表ii",
          "normalizedTitle": "142. 环形链表 ii",
          "charIndex": 52
        },
        {
          "level": 3,
          "title": "录前想法",
          "slug": "录前想法-4",
          "normalizedTitle": "录前想法",
          "charIndex": 140
        },
        {
          "level": 3,
          "title": "录后想法",
          "slug": "录后想法-4",
          "normalizedTitle": "录后想法",
          "charIndex": 1882
        },
        {
          "level": 3,
          "title": "总结",
          "slug": "总结-4",
          "normalizedTitle": "总结",
          "charIndex": 964
        },
        {
          "level": 2,
          "title": "总结",
          "slug": "总结-5",
          "normalizedTitle": "总结",
          "charIndex": 964
        }
      ],
      "excerpt": "<blockquote>\n<p>24. 两两交换链表中的节点 19. 删除链表的倒数第 N 个节点  面试题 02.07. 链表相交 142. 环形链表 II</p>\n</blockquote>\n",
      "lastUpdated": "5/30/2023, 1:15:52 AM",
      "lastUpdatedTimestamp": 1685380552000,
      "headersStr": "24. 两两交换链表中的节点 录前想法 录后想法 总结 19.删除链表的倒数第N个节点 录前想法 录后想法 总结 面试题 02.07. 链表相交 录前想法 录后想法 总结 142.环形链表II 录前想法 录后想法 总结 总结",
      "content": "> 24. 两两交换链表中的节点 19. 删除链表的倒数第 N 个节点 面试题 02.07. 链表相交 142. 环形链表 II\n\n\n# 24. 两两交换链表中的节点\n\n * 题目：24. 两两交换链表中的节点\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：虚拟头结点\n\n\n# 录前想法\n\n开始时的思路：\n\npre -> 1 -> 2 -> 3 -> 4\n\n 1. 1 -> 3\n\n 2. 2 -> 1\n\n 3. pre -> 2\n\npre -> 2 -> 1 -> 3 -> 4\n\n以下代码未通过 (❌)\n\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n\n        // 虚拟头节点\n        ListNode* newHead = new ListNode(0);\n        newHead->next = head;\n\n        // 双指针\n        ListNode* pre = newHead;\n        ListNode* cur = newHead->next;\n        ListNode* tmp = cur->next;\n\n        while(cur->next){\n    \n            // 1 -> 3\n            cur->next = cur->next->next;\n            // 2 -> 1\n            tmp->next = cur;\n            // pre -> 2\n            pre->next = tmp;\n\n            pre = cur;\n            tmp = cur->next;\n            cur = tmp->next;\n        }\n\n        return newHead->next;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n经过一段时间的调试总结了以下问题：\n\n 1. 如果一开始就使用 cur -> next 需要考虑空的情况\n 2. 循环时要先定值、后变值，不然循环的条件就失效了\n\n以下代码已 AC (✔️)\n\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n\n        if(!head){return head;}\n\n        // 虚拟头节点\n        ListNode* newHead = new ListNode(0);\n        newHead->next = head;\n\n        // 双指针\n        ListNode* pre = newHead;\n        ListNode* cur = newHead->next;\n        // 需要判断空\n        ListNode* tmp = cur->next;\n\n        // 循环判断，先定值，后变值，不然无法判断\n        while(pre->next && pre->next->next){\n\n            cur = pre->next;\n            tmp = cur->next;\n    \n            // 1 -> 3\n            cur->next = cur->next->next;\n            // 2 -> 1\n            tmp->next = cur;\n            // pre -> 2\n            pre->next = tmp;\n\n            pre = pre->next->next;\n        }\n\n        return newHead->next;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 录后想法\n\n看了卡哥的思路后，可以再进行优化：\n\n 1. 一开始的赋值操作可以放入循环中\n 2. 统一的 pre 指针使用观感上舒服很多\n\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n\n        // 虚拟头节点\n        ListNode *newHead = new ListNode(0);\n        newHead->next = head;\n\n        // 双指针\n        ListNode *pre = newHead;\n        ListNode *tmp1,*tmp2;\n\n        while(pre->next && pre->next->next){\n            \n            tmp1 = pre->next;\n            tmp2 = pre->next->next->next;\n\n            pre->next = pre->next->next;\n            pre->next->next = tmp1;\n            pre->next->next->next = tmp2;\n            \n            pre = pre->next->next;\n\n        }\n\n        return newHead->next;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 总结\n\n其实没有那么死板，重在理解交换的步骤顺序\n\n\n\n\n# 19. 删除链表的倒数第 N 个节点\n\n * 题目：19. 删除链表的倒数第 N 个节点\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：双指针的操作（删除第 N 个节点，要指向 第 N 个节点的前一个节点）\n\n\n# 录前想法\n\n双指针隔 n+1 个元素前进，直接 AC (✔️)\n\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n\n        // 虚拟头节点\n        ListNode *newHead = new ListNode(0);\n        newHead->next = head;\n        // 快慢指针\n        ListNode *slow = newHead;\n        ListNode *fast = newHead;\n        // 间隔\n        while(n--){\n            fast = fast->next;\n        }\n        // 同时移动\n        while(fast->next){\n            fast = fast->next;\n            slow = slow->next;\n        }\n\n        slow->next = slow->next->next;\n\n        return newHead->next; \n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n * 时间复杂度: O (n)\n * 空间复杂度: O (1)\n\n\n# 录后想法\n\n和卡哥思路一致✌️\n\n\n# 总结\n\n无\n\n\n# 面试题 02.07. 链表相交\n\n * 题目：面试题 02.07. 链表相交\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：注意数值相同，不代表指针相同\n\n\n# 录前想法\n\n 1. 分别计算出链表 A 和 B 的长度\n\n 2. 移动长链表\n\n 3. 同时移动\n\n 4. 返回相同或空\n\n以下代码，已 AC (✔️)\n\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        \n        // 1.分别计算出链表A和B的长度\n        int sizeA = 0,sizeB = 0;\n        ListNode *tmpA = headA;\n        ListNode *tmpB = headB;\n        while(tmpA){\n            tmpA = tmpA->next;\n            ++sizeA;\n        }\n        while(tmpB){\n            tmpB = tmpB->next;\n            ++sizeB;\n        }\n\n        // 2. 移动长链表\n        tmpA = headA;\n        tmpB = headB;\n\n        if (sizeA > sizeB){\n            for(int i = sizeA - sizeB;i > 0;--i){\n                tmpA = tmpA->next;\n            }\n        }else{\n            for(int i = sizeB - sizeA;i > 0;--i){\n                tmpB = tmpB->next;\n            }\n        }\n\n        // 3. 同时移动\n        while(tmpB && tmpA){\n            if(tmpB == tmpA){\n                return tmpA;\n            }\n\n            tmpA = tmpA->next;\n            tmpB = tmpB->next;\n        }\n\n        // 4. 返回空\n        return NULL;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n * 时间复杂度: O (n)\n * 空间复杂度: O (1)\n\n\n# 录后想法\n\n思路与卡哥一致，写法上参考后有改进的地方：\n\n * 在循环上可以控制一个，交换另一个\n\n// 原代码\nif (sizeA > sizeB){\n\tfor(int i = sizeA - sizeB;i > 0;--i){\n\t\ttmpA = tmpA->next;\n\t}\n}else{\n\tfor(int i = sizeB - sizeA;i > 0;--i){\n\t\ttmpB = tmpB->next;\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n// 改进后\nif (sizeA < sizeB){\n    swap(sizeA,sizeB);\n    swap(tmpA,tmpB);\n}\n\nfor(int i = sizeA - sizeB;i > 0;--i){\n    tmpA = tmpA->next;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 总结\n\n * 循环的写法可以控制一个修改另一个\n\n\n# 142. 环形链表 II\n\n * 题目：142. 环形链表 II\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：确定环和找环入口\n\n\n# 录前想法\n\n 1. 快慢指针找到环\n 2. 慢指针回原位，同时和快指针往前走，相遇点就是入口（之前写过，记得结论）\n\n以下代码，超时了，估计是哪里死循环了（❌）\n\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n\n        if(!head){return head;}\n\n        // 虚拟头节点\n        ListNode *newHead = new ListNode(0);\n        newHead->next = head;\n        // 快慢指针\n        ListNode *fast = newHead;\n        ListNode *slow = newHead;\n        // 找到相遇点\n        while(fast->next && fast->next->next){\n            \n            // 先赋值\n            fast = fast->next->next;\n            slow = slow->next;\n\n            if(fast == slow){\n                // slow归原位\n                slow = newHead->next;\n                // 共同前进\n                while(fast != slow){\n                    fast = fast->next;\n                    slow = slow->next;\n                }\n                return fast;\n            }\n        }\n\n        return NULL;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n暂时没有找到错在哪，去看看卡哥的讲解。\n\n\n# 录后想法\n\n经过比对发现，思路是一致的，不同的地方在虚拟头节点的使用，删除虚拟头节点后就 AC (✔️)\n\n// 改进后\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n\n        if(!head){return head;}\n\n        // 快慢指针\n        ListNode *fast = head;\n        ListNode *slow = head;\n        \n        // 找到相遇点\n        while(fast && fast->next){\n            \n            // 先赋值\n            fast = fast->next->next;\n            slow = slow->next;\n\n            if(slow == fast){\n\n                fast =  head;\n                if(!fast){return nullptr;}\n\n                while(fast != slow){\n                    fast = fast->next;\n                    slow = slow->next;\n                }\n\n                return fast;\n            }\n\n        }\n\n        return nullptr;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# 总结\n\n * 虚拟头节点不能乱用，哪些情况下需要使用虚拟头节点呢？\n\n\n# 总结\n\n 1. 虚拟头节点是否该使用？\n 2. 双指针\n    1. 快慢指针（一个每次都走的比另一个快）\n    2. 滑动窗口",
      "normalizedContent": "> 24. 两两交换链表中的节点 19. 删除链表的倒数第 n 个节点 面试题 02.07. 链表相交 142. 环形链表 ii\n\n\n# 24. 两两交换链表中的节点\n\n * 题目：24. 两两交换链表中的节点\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：虚拟头结点\n\n\n# 录前想法\n\n开始时的思路：\n\npre -> 1 -> 2 -> 3 -> 4\n\n 1. 1 -> 3\n\n 2. 2 -> 1\n\n 3. pre -> 2\n\npre -> 2 -> 1 -> 3 -> 4\n\n以下代码未通过 (❌)\n\nclass solution {\npublic:\n    listnode* swappairs(listnode* head) {\n\n        // 虚拟头节点\n        listnode* newhead = new listnode(0);\n        newhead->next = head;\n\n        // 双指针\n        listnode* pre = newhead;\n        listnode* cur = newhead->next;\n        listnode* tmp = cur->next;\n\n        while(cur->next){\n    \n            // 1 -> 3\n            cur->next = cur->next->next;\n            // 2 -> 1\n            tmp->next = cur;\n            // pre -> 2\n            pre->next = tmp;\n\n            pre = cur;\n            tmp = cur->next;\n            cur = tmp->next;\n        }\n\n        return newhead->next;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n经过一段时间的调试总结了以下问题：\n\n 1. 如果一开始就使用 cur -> next 需要考虑空的情况\n 2. 循环时要先定值、后变值，不然循环的条件就失效了\n\n以下代码已 ac (✔️)\n\nclass solution {\npublic:\n    listnode* swappairs(listnode* head) {\n\n        if(!head){return head;}\n\n        // 虚拟头节点\n        listnode* newhead = new listnode(0);\n        newhead->next = head;\n\n        // 双指针\n        listnode* pre = newhead;\n        listnode* cur = newhead->next;\n        // 需要判断空\n        listnode* tmp = cur->next;\n\n        // 循环判断，先定值，后变值，不然无法判断\n        while(pre->next && pre->next->next){\n\n            cur = pre->next;\n            tmp = cur->next;\n    \n            // 1 -> 3\n            cur->next = cur->next->next;\n            // 2 -> 1\n            tmp->next = cur;\n            // pre -> 2\n            pre->next = tmp;\n\n            pre = pre->next->next;\n        }\n\n        return newhead->next;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 录后想法\n\n看了卡哥的思路后，可以再进行优化：\n\n 1. 一开始的赋值操作可以放入循环中\n 2. 统一的 pre 指针使用观感上舒服很多\n\nclass solution {\npublic:\n    listnode* swappairs(listnode* head) {\n\n        // 虚拟头节点\n        listnode *newhead = new listnode(0);\n        newhead->next = head;\n\n        // 双指针\n        listnode *pre = newhead;\n        listnode *tmp1,*tmp2;\n\n        while(pre->next && pre->next->next){\n            \n            tmp1 = pre->next;\n            tmp2 = pre->next->next->next;\n\n            pre->next = pre->next->next;\n            pre->next->next = tmp1;\n            pre->next->next->next = tmp2;\n            \n            pre = pre->next->next;\n\n        }\n\n        return newhead->next;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 总结\n\n其实没有那么死板，重在理解交换的步骤顺序\n\n\n\n\n# 19. 删除链表的倒数第 n 个节点\n\n * 题目：19. 删除链表的倒数第 n 个节点\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：双指针的操作（删除第 n 个节点，要指向 第 n 个节点的前一个节点）\n\n\n# 录前想法\n\n双指针隔 n+1 个元素前进，直接 ac (✔️)\n\nclass solution {\npublic:\n    listnode* removenthfromend(listnode* head, int n) {\n\n        // 虚拟头节点\n        listnode *newhead = new listnode(0);\n        newhead->next = head;\n        // 快慢指针\n        listnode *slow = newhead;\n        listnode *fast = newhead;\n        // 间隔\n        while(n--){\n            fast = fast->next;\n        }\n        // 同时移动\n        while(fast->next){\n            fast = fast->next;\n            slow = slow->next;\n        }\n\n        slow->next = slow->next->next;\n\n        return newhead->next; \n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n * 时间复杂度: o (n)\n * 空间复杂度: o (1)\n\n\n# 录后想法\n\n和卡哥思路一致✌️\n\n\n# 总结\n\n无\n\n\n# 面试题 02.07. 链表相交\n\n * 题目：面试题 02.07. 链表相交\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：注意数值相同，不代表指针相同\n\n\n# 录前想法\n\n 1. 分别计算出链表 a 和 b 的长度\n\n 2. 移动长链表\n\n 3. 同时移动\n\n 4. 返回相同或空\n\n以下代码，已 ac (✔️)\n\nclass solution {\npublic:\n    listnode *getintersectionnode(listnode *heada, listnode *headb) {\n        \n        // 1.分别计算出链表a和b的长度\n        int sizea = 0,sizeb = 0;\n        listnode *tmpa = heada;\n        listnode *tmpb = headb;\n        while(tmpa){\n            tmpa = tmpa->next;\n            ++sizea;\n        }\n        while(tmpb){\n            tmpb = tmpb->next;\n            ++sizeb;\n        }\n\n        // 2. 移动长链表\n        tmpa = heada;\n        tmpb = headb;\n\n        if (sizea > sizeb){\n            for(int i = sizea - sizeb;i > 0;--i){\n                tmpa = tmpa->next;\n            }\n        }else{\n            for(int i = sizeb - sizea;i > 0;--i){\n                tmpb = tmpb->next;\n            }\n        }\n\n        // 3. 同时移动\n        while(tmpb && tmpa){\n            if(tmpb == tmpa){\n                return tmpa;\n            }\n\n            tmpa = tmpa->next;\n            tmpb = tmpb->next;\n        }\n\n        // 4. 返回空\n        return null;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n * 时间复杂度: o (n)\n * 空间复杂度: o (1)\n\n\n# 录后想法\n\n思路与卡哥一致，写法上参考后有改进的地方：\n\n * 在循环上可以控制一个，交换另一个\n\n// 原代码\nif (sizea > sizeb){\n\tfor(int i = sizea - sizeb;i > 0;--i){\n\t\ttmpa = tmpa->next;\n\t}\n}else{\n\tfor(int i = sizeb - sizea;i > 0;--i){\n\t\ttmpb = tmpb->next;\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n// 改进后\nif (sizea < sizeb){\n    swap(sizea,sizeb);\n    swap(tmpa,tmpb);\n}\n\nfor(int i = sizea - sizeb;i > 0;--i){\n    tmpa = tmpa->next;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 总结\n\n * 循环的写法可以控制一个修改另一个\n\n\n# 142. 环形链表 ii\n\n * 题目：142. 环形链表 ii\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：确定环和找环入口\n\n\n# 录前想法\n\n 1. 快慢指针找到环\n 2. 慢指针回原位，同时和快指针往前走，相遇点就是入口（之前写过，记得结论）\n\n以下代码，超时了，估计是哪里死循环了（❌）\n\nclass solution {\npublic:\n    listnode *detectcycle(listnode *head) {\n\n        if(!head){return head;}\n\n        // 虚拟头节点\n        listnode *newhead = new listnode(0);\n        newhead->next = head;\n        // 快慢指针\n        listnode *fast = newhead;\n        listnode *slow = newhead;\n        // 找到相遇点\n        while(fast->next && fast->next->next){\n            \n            // 先赋值\n            fast = fast->next->next;\n            slow = slow->next;\n\n            if(fast == slow){\n                // slow归原位\n                slow = newhead->next;\n                // 共同前进\n                while(fast != slow){\n                    fast = fast->next;\n                    slow = slow->next;\n                }\n                return fast;\n            }\n        }\n\n        return null;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n暂时没有找到错在哪，去看看卡哥的讲解。\n\n\n# 录后想法\n\n经过比对发现，思路是一致的，不同的地方在虚拟头节点的使用，删除虚拟头节点后就 ac (✔️)\n\n// 改进后\nclass solution {\npublic:\n    listnode *detectcycle(listnode *head) {\n\n        if(!head){return head;}\n\n        // 快慢指针\n        listnode *fast = head;\n        listnode *slow = head;\n        \n        // 找到相遇点\n        while(fast && fast->next){\n            \n            // 先赋值\n            fast = fast->next->next;\n            slow = slow->next;\n\n            if(slow == fast){\n\n                fast =  head;\n                if(!fast){return nullptr;}\n\n                while(fast != slow){\n                    fast = fast->next;\n                    slow = slow->next;\n                }\n\n                return fast;\n            }\n\n        }\n\n        return nullptr;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# 总结\n\n * 虚拟头节点不能乱用，哪些情况下需要使用虚拟头节点呢？\n\n\n# 总结\n\n 1. 虚拟头节点是否该使用？\n 2. 双指针\n    1. 快慢指针（一个每次都走的比另一个快）\n    2. 滑动窗口",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "Day07-字符串",
      "frontmatter": {
        "title": "Day07-字符串",
        "date": "2023-05-31T10:04:29.000Z",
        "permalink": "/pages/26eaf0/",
        "categories": [
          "算法",
          "算法打卡"
        ],
        "tags": [
          "打卡"
        ]
      },
      "regularPath": "/02.%E7%AE%97%E6%B3%95/01.%E7%AE%97%E6%B3%95%E6%89%93%E5%8D%A1/07.Day07-%E5%AD%97%E7%AC%A6%E4%B8%B2.html",
      "relativePath": "02.算法/01.算法打卡/07.Day07-字符串.md",
      "key": "v-3bb075f0",
      "path": "/pages/26eaf0/",
      "headers": [
        {
          "level": 2,
          "title": "344.反转字符串",
          "slug": "_344-反转字符串",
          "normalizedTitle": "344. 反转字符串",
          "charIndex": 2
        }
      ],
      "excerpt": "<blockquote>\n<p>344. 反转字符串 541. 反转字符串 II 剑指 Offer 05. 替换空格 151. 翻转字符串里的单词 剑指 Offer58-II. 左旋转字符串</p>\n</blockquote>\n",
      "headersStr": "344.反转字符串",
      "content": "> 344. 反转字符串 541. 反转字符串 II 剑指 Offer 05. 替换空格 151. 翻转字符串里的单词 剑指 Offer58-II. 左旋转字符串\n\n\n# 344. 反转字符串",
      "normalizedContent": "> 344. 反转字符串 541. 反转字符串 ii 剑指 offer 05. 替换空格 151. 翻转字符串里的单词 剑指 offer58-ii. 左旋转字符串\n\n\n# 344. 反转字符串",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "Day05-哈希",
      "frontmatter": {
        "title": "Day05-哈希",
        "date": "2023-05-29T16:34:30.000Z",
        "permalink": "/pages/311b6b/",
        "categories": [
          "算法",
          "算法打卡"
        ],
        "tags": [
          "打卡"
        ]
      },
      "regularPath": "/02.%E7%AE%97%E6%B3%95/01.%E7%AE%97%E6%B3%95%E6%89%93%E5%8D%A1/05.Day05-%E5%93%88%E5%B8%8C.html",
      "relativePath": "02.算法/01.算法打卡/05.Day05-哈希.md",
      "key": "v-72465a38",
      "path": "/pages/311b6b/",
      "headers": [
        {
          "level": 2,
          "title": "哈希表理论基础",
          "slug": "哈希表理论基础",
          "normalizedTitle": "哈希表理论基础",
          "charIndex": 2
        },
        {
          "level": 2,
          "title": "242.有效的字母异位词",
          "slug": "_242-有效的字母异位词",
          "normalizedTitle": "242. 有效的字母异位词",
          "charIndex": 10
        },
        {
          "level": 3,
          "title": "录前想法",
          "slug": "录前想法",
          "normalizedTitle": "录前想法",
          "charIndex": 920
        },
        {
          "level": 3,
          "title": "录后想法",
          "slug": "录后想法",
          "normalizedTitle": "录后想法",
          "charIndex": 1703
        },
        {
          "level": 3,
          "title": "总结",
          "slug": "总结",
          "normalizedTitle": "总结",
          "charIndex": 128
        },
        {
          "level": 2,
          "title": "349.两个数组的交集",
          "slug": "_349-两个数组的交集",
          "normalizedTitle": "349. 两个数组的交集",
          "charIndex": 24
        },
        {
          "level": 3,
          "title": "录前想法",
          "slug": "录前想法-2",
          "normalizedTitle": "录前想法",
          "charIndex": 920
        },
        {
          "level": 3,
          "title": "录后想法",
          "slug": "录后想法-2",
          "normalizedTitle": "录后想法",
          "charIndex": 1703
        },
        {
          "level": 3,
          "title": "总结",
          "slug": "总结-2",
          "normalizedTitle": "总结",
          "charIndex": 128
        },
        {
          "level": 2,
          "title": "202.快乐数",
          "slug": "_202-快乐数",
          "normalizedTitle": "202. 快乐数",
          "charIndex": 37
        },
        {
          "level": 3,
          "title": "录前想法",
          "slug": "录前想法-3",
          "normalizedTitle": "录前想法",
          "charIndex": 920
        },
        {
          "level": 3,
          "title": "录后想法",
          "slug": "录后想法-3",
          "normalizedTitle": "录后想法",
          "charIndex": 1703
        },
        {
          "level": 3,
          "title": "总结",
          "slug": "总结-3",
          "normalizedTitle": "总结",
          "charIndex": 128
        },
        {
          "level": 2,
          "title": "1.两数之和",
          "slug": "_1-两数之和",
          "normalizedTitle": "1. 两数之和",
          "charIndex": 46
        },
        {
          "level": 3,
          "title": "录前想法",
          "slug": "录前想法-4",
          "normalizedTitle": "录前想法",
          "charIndex": 920
        },
        {
          "level": 3,
          "title": "录后想法",
          "slug": "录后想法-4",
          "normalizedTitle": "录后想法",
          "charIndex": 1703
        },
        {
          "level": 3,
          "title": "总结",
          "slug": "总结-4",
          "normalizedTitle": "总结",
          "charIndex": 128
        },
        {
          "level": 2,
          "title": "总结",
          "slug": "总结-5",
          "normalizedTitle": "总结",
          "charIndex": 128
        }
      ],
      "excerpt": "<blockquote>\n<p>哈希表理论基础 242. 有效的字母异位词 349. 两个数组的交集 202. 快乐数 1. 两数之和</p>\n</blockquote>\n",
      "lastUpdated": "5/30/2023, 2:25:28 PM",
      "lastUpdatedTimestamp": 1685427928000,
      "headersStr": "哈希表理论基础 242.有效的字母异位词 录前想法 录后想法 总结 349.两个数组的交集 录前想法 录后想法 总结 202.快乐数 录前想法 录后想法 总结 1.两数之和 录前想法 录后想法 总结 总结",
      "content": "> 哈希表理论基础 242. 有效的字母异位词 349. 两个数组的交集 202. 快乐数 1. 两数之和\n\n\n# 哈希表理论基础\n\n * 讲解\n\n * 要求：了解哈希表的内部实现原理，哈希函数，哈希碰撞，以及常见哈希表的区别，数组，set 和 map\n\n总结：\n\n 1. 当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法\n 2. 牺牲了空间换取了时间\n\n集合                       底层实现   是否有序   数值是否可以重复   能否更改数值   查询效率       增删效率\nstd::set                 红黑树    有序     否          否        O(log n)   O(log n)\nstd::multiset            红黑树    有序     是          否        O(logn)    O(logn)\nstd::unordered_set(✔️)   哈希表    无序     否          否        O(1)       O(1)\n\n----------------------------------------\n\n映射                   底层实现   是否有序     数值是否可以重复   能否更改数值     查询效率       增删效率\nstd::map             红黑树    key 有序   key 不可重复   key 不可修改   O(logn)    O(logn)\nstd::multimap        红黑树    key 有序   key 可重复    key 不可修改   O(log n)   O(log n)\nstd::unordered_map   哈希表    key 无序   key 不可重复   key 不可修改   O(1)       O(1)\n\n\n# 242. 有效的字母异位词\n\n * 题目：242. 有效的字母异位词\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：数组用来做哈希表\n\n\n# 录前想法\n\n按要求，数组作为哈希表来记录每个字符，s 字符串的字符 ++，t 字符串的字符 --，若最后 tmp 数组中都为 0 则为有效的字母异位词。\n\n以下代码已 AC (✔️)\n\nclass Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        \n        if(s.size() != t.size()){return false;}\n\n        // 初始化数组\n        int tmp[26] = {0};\n\n        // s.size() == t.size()\n        for(int i = 0; i < s.size();++i){\n            // 记录s字符串\n            tmp[s[i] - 'a']++;\n            // 从tmp中删除t字符串字符\n            tmp[t[i] - 'a']--;\n        }\n\n        // 查看tmp是否全为0\n        for(int i = 0; i < 26;++i){\n            cout<<tmp[i]<<endl;\n            if(tmp[i] != 0){\n                return false;\n            }\n        }\n\n        return true;\n \n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n * 时间复杂度: O (n)\n * 空间复杂度: O (1)\n\n\n# 录后想法\n\n思路一致✌️\n\n\n# 总结\n\n无\n\n\n# 349. 两个数组的交集\n\n * 题目：349. 两个数组的交集\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：使用数组和 set 两种解法\n\n\n# 录前想法\n\n> 数组\n\n 1. 定义 set 数据结构，防止结果重复\n 2. 定义 1000 数组\n 3. 记录 nums1 并判断 nums2 是否存在\n 4. 类型转换并返回\n\n已 AC (✔️)\n\nclass Solution {\npublic:\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\n        // 去重结果集\n        unordered_set<int> result;\n\n        // 使用数组\n        int tmp[1000] = {0};\n\n        // 记录nums1\n        for(int i = 0;i < nums1.size();++i){\n            tmp[nums1[i]] = 1;\n        }\n\n        // 判断nums2元素是否存在\n        for(int i = 0;i < nums2.size();++i){\n            if(tmp[nums2[i]] == 1){\n                result.insert(nums2[i]);\n            }\n        }\n\n        return vector<int>(result.begin(), result.end());;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n> set 数据结构\n\n写出来和上面数组差不多，对 SET 数据结构操作不熟练。\n\n\n# 录后想法\n\n主要是迭代器的使用，AC (✔️)\n\nclass Solution {\npublic:\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\n        // 去重结果集\n        unordered_set<int> result;\n        unordered_set<int> tmp(nums1.begin(),nums1.end());\n\n        // 使用SET\n        for(int num : nums2){\n            // tmp.find(num) 未找到则返回tmp.end()\n            if(tmp.find(num) != tmp.end()){\n                result.insert(num);\n            }\n        }\n\n        return vector<int>(result.begin(), result.end());;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 总结\n\n * SET 数据结构的无重复\n * 迭代器的使用\n\n\n# 202. 快乐数\n\n * 题目：202. 快乐数\n\n * 讲解：文章讲解\n\n * 要求：set 的应用\n\n\n# 录前想法\n\n暴力求和判断是否为 1，若出现和为个位数且不为 1 就是 false\n\n下面是代码实现，未通过 (❌)\n\nclass Solution {\npublic:\n    bool isHappy(int n) {\n\n        if(n == 1){return true;}\n\n        // 备份n\n        int tmp;\n        int len = 0,sum = 0,p;\n\n        while(1){\n\n            // 备份n\n            tmp = n;\n            // 初始化、归零\n            len = 0;\n            p = 10;\n            sum = 0;\n\n            // 判断n有几位\n            while(tmp != 0){\n                tmp /= 10;\n                ++len;\n            }\n\n            // 若出现个位则直接返回false\n            if(len == 1){\n                return false;\n            }\n\n            tmp = n;\n\n            // 循环记录平方和\n            while(len--){\n\n                // 取数\n                tmp = n%p;\n                // 记录和\n                sum += tmp * tmp;\n\n                if(len == 1){\n                    tmp = n/p;\n                    sum += tmp * tmp;\n                    break;\n                }\n                \n                p *= 10; \n            }\n\n            // 判断是否为1\n            if(sum == 1){\n                return true;\n            }else{\n                n = sum;\n            }\n        }\n\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n\n\n应该是思路错了，且并没有用上 set\n\n\n# 录后想法\n\n * 会 无限循环，那么也就是说求和的过程中，sum 会重复出现，这对解题很重要！\n\n看了卡哥的讲解后发现是思路错了，不是出现 sum 为个位数时返回 false，而是出现了重复的 sum\n\n根据这个思路可以写出以下代码：AC (✔️)\n\nclass Solution {\npublic:\n    bool isHappy(int n) {\n\n        int sum;\n        unordered_set<int> tmp;\n\n        while(1){\n\n            // 循环记录平方和\n            sum = 0;\n            while(n){\n                // 取个数数并平方和\n                sum += (n%10)*(n%10);\n                // 缩短位数（剔除个位）\n                n /= 10;\n            }\n\n            // 判断是否为1\n            if(sum == 1){\n                return true;\n            }else{\n                n = sum;\n            }\n\n            // sum曾经出现过\n            if(tmp.find(sum) != tmp.end()){\n                return false;\n            }else{\n                tmp.insert(sum);\n            }\n\n        }\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 总结\n\n * 无限循环 = 会重复出现值\n\n * 分解正数的个位数\n   \n   while(n){\n       // 取个数数并平方和\n       sum += (n%10)*(n%10);\n       // 缩短位数（剔除个位）\n       n /= 10;\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n\n# 1. 两数之和\n\n * 题目：1. 两数之和\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：map 解决哈希问题\n\n\n# 录前想法\n\n 1. 可以暴力的循环比对\n 2. 利用相加，使用 MAP 数据结构保存值，快速匹配\n\nMAP 的掌握不熟，下面代码为暴力解法，已 AC (✔️)\n\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        \n       for(int i = 0; i < nums.size();++i){\n            for(int j = i + 1; j < nums.size();++j){\n                if(nums[i]+nums[j] == target){\n                    return {i,j};\n                }\n            }\n       }\n\n        return {};\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 录后想法\n\n思路正确，顺便学习以下 map 用法，AC (✔️)\n\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        \n        // 将nums装入map中\n        std::unordered_map <int,int> map;\n        for(int i = 0; i < nums.size(); ++i){\n            auto iter = map.find(target - nums[i]); \n            if(iter != map.end()){\n                // iter->second 下标\n                // iter->frist  值\n                return {iter->second, i};\n            }\n            map.insert(pair<int, int>(nums[i], i)); \n        }\n\n        return {};\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 总结\n\n * 判断 key 有序无序选择使用 MAP\n\n映射                   底层实现   是否有序     数值是否可以重复   能否更改数值     查询效率       增删效率\nstd::map             红黑树    key 有序   key 不可重复   key 不可修改   O(log n)   O(log n)\nstd::multimap        红黑树    key 有序   key 可重复    key 不可修改   O(log n)   O(log n)\nstd::unordered_map   哈希表    key 无序   key 不可重复   key 不可修改   O(1)       O(1)\n\n\n# 总结\n\n 1. 数组、SET 集合、MAP 的应用\n\n * SET 集合：查元素、保存不重复\n * MAP：查元素，需要下标\n\n集合                       底层实现   是否有序   数值是否可以重复   能否更改数值   查询效率       增删效率\nstd::set                 红黑树    有序     否          否        O(log n)   O(log n)\nstd::multiset            红黑树    有序     是          否        O(logn)    O(logn)\nstd::unordered_set(✔️)   哈希表    无序     否          否        O(1)       O(1)\n\n----------------------------------------\n\n映射                   底层实现   是否有序     数值是否可以重复   能否更改数值     查询效率       增删效率\nstd::map             红黑树    key 有序   key 不可重复   key 不可修改   O(logn)    O(logn)\nstd::multimap        红黑树    key 有序   key 可重复    key 不可修改   O(log n)   O(log n)\nstd::unordered_map   哈希表    key 无序   key 不可重复   key 不可修改   O(1)       O(1)\n\n 2. 迭代器的使用\n\n// 判断元素是否出现过\nif(tmp.find(sum) != tmp.end()){}\n\n\n1\n2\n\n 3. 个位运算\n\nwhile(n){\n\tsum += n%10; // n%10个位\n\tn /= 10;     // 剔除已使用个位\n}\n\n\n1\n2\n3\n4\n",
      "normalizedContent": "> 哈希表理论基础 242. 有效的字母异位词 349. 两个数组的交集 202. 快乐数 1. 两数之和\n\n\n# 哈希表理论基础\n\n * 讲解\n\n * 要求：了解哈希表的内部实现原理，哈希函数，哈希碰撞，以及常见哈希表的区别，数组，set 和 map\n\n总结：\n\n 1. 当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法\n 2. 牺牲了空间换取了时间\n\n集合                       底层实现   是否有序   数值是否可以重复   能否更改数值   查询效率       增删效率\nstd::set                 红黑树    有序     否          否        o(log n)   o(log n)\nstd::multiset            红黑树    有序     是          否        o(logn)    o(logn)\nstd::unordered_set(✔️)   哈希表    无序     否          否        o(1)       o(1)\n\n----------------------------------------\n\n映射                   底层实现   是否有序     数值是否可以重复   能否更改数值     查询效率       增删效率\nstd::map             红黑树    key 有序   key 不可重复   key 不可修改   o(logn)    o(logn)\nstd::multimap        红黑树    key 有序   key 可重复    key 不可修改   o(log n)   o(log n)\nstd::unordered_map   哈希表    key 无序   key 不可重复   key 不可修改   o(1)       o(1)\n\n\n# 242. 有效的字母异位词\n\n * 题目：242. 有效的字母异位词\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：数组用来做哈希表\n\n\n# 录前想法\n\n按要求，数组作为哈希表来记录每个字符，s 字符串的字符 ++，t 字符串的字符 --，若最后 tmp 数组中都为 0 则为有效的字母异位词。\n\n以下代码已 ac (✔️)\n\nclass solution {\npublic:\n    bool isanagram(string s, string t) {\n        \n        if(s.size() != t.size()){return false;}\n\n        // 初始化数组\n        int tmp[26] = {0};\n\n        // s.size() == t.size()\n        for(int i = 0; i < s.size();++i){\n            // 记录s字符串\n            tmp[s[i] - 'a']++;\n            // 从tmp中删除t字符串字符\n            tmp[t[i] - 'a']--;\n        }\n\n        // 查看tmp是否全为0\n        for(int i = 0; i < 26;++i){\n            cout<<tmp[i]<<endl;\n            if(tmp[i] != 0){\n                return false;\n            }\n        }\n\n        return true;\n \n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n * 时间复杂度: o (n)\n * 空间复杂度: o (1)\n\n\n# 录后想法\n\n思路一致✌️\n\n\n# 总结\n\n无\n\n\n# 349. 两个数组的交集\n\n * 题目：349. 两个数组的交集\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：使用数组和 set 两种解法\n\n\n# 录前想法\n\n> 数组\n\n 1. 定义 set 数据结构，防止结果重复\n 2. 定义 1000 数组\n 3. 记录 nums1 并判断 nums2 是否存在\n 4. 类型转换并返回\n\n已 ac (✔️)\n\nclass solution {\npublic:\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\n        // 去重结果集\n        unordered_set<int> result;\n\n        // 使用数组\n        int tmp[1000] = {0};\n\n        // 记录nums1\n        for(int i = 0;i < nums1.size();++i){\n            tmp[nums1[i]] = 1;\n        }\n\n        // 判断nums2元素是否存在\n        for(int i = 0;i < nums2.size();++i){\n            if(tmp[nums2[i]] == 1){\n                result.insert(nums2[i]);\n            }\n        }\n\n        return vector<int>(result.begin(), result.end());;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n> set 数据结构\n\n写出来和上面数组差不多，对 set 数据结构操作不熟练。\n\n\n# 录后想法\n\n主要是迭代器的使用，ac (✔️)\n\nclass solution {\npublic:\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\n        // 去重结果集\n        unordered_set<int> result;\n        unordered_set<int> tmp(nums1.begin(),nums1.end());\n\n        // 使用set\n        for(int num : nums2){\n            // tmp.find(num) 未找到则返回tmp.end()\n            if(tmp.find(num) != tmp.end()){\n                result.insert(num);\n            }\n        }\n\n        return vector<int>(result.begin(), result.end());;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 总结\n\n * set 数据结构的无重复\n * 迭代器的使用\n\n\n# 202. 快乐数\n\n * 题目：202. 快乐数\n\n * 讲解：文章讲解\n\n * 要求：set 的应用\n\n\n# 录前想法\n\n暴力求和判断是否为 1，若出现和为个位数且不为 1 就是 false\n\n下面是代码实现，未通过 (❌)\n\nclass solution {\npublic:\n    bool ishappy(int n) {\n\n        if(n == 1){return true;}\n\n        // 备份n\n        int tmp;\n        int len = 0,sum = 0,p;\n\n        while(1){\n\n            // 备份n\n            tmp = n;\n            // 初始化、归零\n            len = 0;\n            p = 10;\n            sum = 0;\n\n            // 判断n有几位\n            while(tmp != 0){\n                tmp /= 10;\n                ++len;\n            }\n\n            // 若出现个位则直接返回false\n            if(len == 1){\n                return false;\n            }\n\n            tmp = n;\n\n            // 循环记录平方和\n            while(len--){\n\n                // 取数\n                tmp = n%p;\n                // 记录和\n                sum += tmp * tmp;\n\n                if(len == 1){\n                    tmp = n/p;\n                    sum += tmp * tmp;\n                    break;\n                }\n                \n                p *= 10; \n            }\n\n            // 判断是否为1\n            if(sum == 1){\n                return true;\n            }else{\n                n = sum;\n            }\n        }\n\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n\n\n应该是思路错了，且并没有用上 set\n\n\n# 录后想法\n\n * 会 无限循环，那么也就是说求和的过程中，sum 会重复出现，这对解题很重要！\n\n看了卡哥的讲解后发现是思路错了，不是出现 sum 为个位数时返回 false，而是出现了重复的 sum\n\n根据这个思路可以写出以下代码：ac (✔️)\n\nclass solution {\npublic:\n    bool ishappy(int n) {\n\n        int sum;\n        unordered_set<int> tmp;\n\n        while(1){\n\n            // 循环记录平方和\n            sum = 0;\n            while(n){\n                // 取个数数并平方和\n                sum += (n%10)*(n%10);\n                // 缩短位数（剔除个位）\n                n /= 10;\n            }\n\n            // 判断是否为1\n            if(sum == 1){\n                return true;\n            }else{\n                n = sum;\n            }\n\n            // sum曾经出现过\n            if(tmp.find(sum) != tmp.end()){\n                return false;\n            }else{\n                tmp.insert(sum);\n            }\n\n        }\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 总结\n\n * 无限循环 = 会重复出现值\n\n * 分解正数的个位数\n   \n   while(n){\n       // 取个数数并平方和\n       sum += (n%10)*(n%10);\n       // 缩短位数（剔除个位）\n       n /= 10;\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n\n# 1. 两数之和\n\n * 题目：1. 两数之和\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：map 解决哈希问题\n\n\n# 录前想法\n\n 1. 可以暴力的循环比对\n 2. 利用相加，使用 map 数据结构保存值，快速匹配\n\nmap 的掌握不熟，下面代码为暴力解法，已 ac (✔️)\n\nclass solution {\npublic:\n    vector<int> twosum(vector<int>& nums, int target) {\n        \n       for(int i = 0; i < nums.size();++i){\n            for(int j = i + 1; j < nums.size();++j){\n                if(nums[i]+nums[j] == target){\n                    return {i,j};\n                }\n            }\n       }\n\n        return {};\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 录后想法\n\n思路正确，顺便学习以下 map 用法，ac (✔️)\n\nclass solution {\npublic:\n    vector<int> twosum(vector<int>& nums, int target) {\n        \n        // 将nums装入map中\n        std::unordered_map <int,int> map;\n        for(int i = 0; i < nums.size(); ++i){\n            auto iter = map.find(target - nums[i]); \n            if(iter != map.end()){\n                // iter->second 下标\n                // iter->frist  值\n                return {iter->second, i};\n            }\n            map.insert(pair<int, int>(nums[i], i)); \n        }\n\n        return {};\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 总结\n\n * 判断 key 有序无序选择使用 map\n\n映射                   底层实现   是否有序     数值是否可以重复   能否更改数值     查询效率       增删效率\nstd::map             红黑树    key 有序   key 不可重复   key 不可修改   o(log n)   o(log n)\nstd::multimap        红黑树    key 有序   key 可重复    key 不可修改   o(log n)   o(log n)\nstd::unordered_map   哈希表    key 无序   key 不可重复   key 不可修改   o(1)       o(1)\n\n\n# 总结\n\n 1. 数组、set 集合、map 的应用\n\n * set 集合：查元素、保存不重复\n * map：查元素，需要下标\n\n集合                       底层实现   是否有序   数值是否可以重复   能否更改数值   查询效率       增删效率\nstd::set                 红黑树    有序     否          否        o(log n)   o(log n)\nstd::multiset            红黑树    有序     是          否        o(logn)    o(logn)\nstd::unordered_set(✔️)   哈希表    无序     否          否        o(1)       o(1)\n\n----------------------------------------\n\n映射                   底层实现   是否有序     数值是否可以重复   能否更改数值     查询效率       增删效率\nstd::map             红黑树    key 有序   key 不可重复   key 不可修改   o(logn)    o(logn)\nstd::multimap        红黑树    key 有序   key 可重复    key 不可修改   o(log n)   o(log n)\nstd::unordered_map   哈希表    key 无序   key 不可重复   key 不可修改   o(1)       o(1)\n\n 2. 迭代器的使用\n\n// 判断元素是否出现过\nif(tmp.find(sum) != tmp.end()){}\n\n\n1\n2\n\n 3. 个位运算\n\nwhile(n){\n\tsum += n%10; // n%10个位\n\tn /= 10;     // 剔除已使用个位\n}\n\n\n1\n2\n3\n4\n",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "Day06-哈希",
      "frontmatter": {
        "title": "Day06-哈希",
        "date": "2023-05-30T01:13:06.000Z",
        "permalink": "/pages/5d4a2f/",
        "categories": [
          "算法",
          "算法打卡"
        ],
        "tags": [
          "打卡"
        ]
      },
      "regularPath": "/02.%E7%AE%97%E6%B3%95/01.%E7%AE%97%E6%B3%95%E6%89%93%E5%8D%A1/06.Day06-%E5%93%88%E5%B8%8C.html",
      "relativePath": "02.算法/01.算法打卡/06.Day06-哈希.md",
      "key": "v-24f403b8",
      "path": "/pages/5d4a2f/",
      "headers": [
        {
          "level": 2,
          "title": "454.四数相加II",
          "slug": "_454-四数相加ii",
          "normalizedTitle": "454. 四数相加 ii",
          "charIndex": 4
        },
        {
          "level": 3,
          "title": "录前想法",
          "slug": "录前想法",
          "normalizedTitle": "录前想法",
          "charIndex": 126
        },
        {
          "level": 3,
          "title": "录后想法",
          "slug": "录后想法",
          "normalizedTitle": "录后想法",
          "charIndex": 846
        },
        {
          "level": 3,
          "title": "总结",
          "slug": "总结",
          "normalizedTitle": "总结",
          "charIndex": 861
        },
        {
          "level": 2,
          "title": "383. 赎金信",
          "slug": "_383-赎金信",
          "normalizedTitle": "383. 赎金信",
          "charIndex": 17
        },
        {
          "level": 3,
          "title": "录前想法",
          "slug": "录前想法-2",
          "normalizedTitle": "录前想法",
          "charIndex": 126
        },
        {
          "level": 3,
          "title": "录后想法",
          "slug": "录后想法-2",
          "normalizedTitle": "录后想法",
          "charIndex": 846
        },
        {
          "level": 3,
          "title": "总结",
          "slug": "总结-2",
          "normalizedTitle": "总结",
          "charIndex": 861
        },
        {
          "level": 2,
          "title": "15. 三数之和",
          "slug": "_15-三数之和",
          "normalizedTitle": "15. 三数之和",
          "charIndex": 26
        },
        {
          "level": 3,
          "title": "录前想法",
          "slug": "录前想法-3",
          "normalizedTitle": "录前想法",
          "charIndex": 126
        },
        {
          "level": 3,
          "title": "录后想法",
          "slug": "录后想法-3",
          "normalizedTitle": "录后想法",
          "charIndex": 846
        },
        {
          "level": 3,
          "title": "总结",
          "slug": "总结-3",
          "normalizedTitle": "总结",
          "charIndex": 861
        },
        {
          "level": 2,
          "title": "18. 四数之和",
          "slug": "_18-四数之和",
          "normalizedTitle": "18. 四数之和",
          "charIndex": 40
        },
        {
          "level": 3,
          "title": "录前想法",
          "slug": "录前想法-4",
          "normalizedTitle": "录前想法",
          "charIndex": 126
        },
        {
          "level": 3,
          "title": "录后想法",
          "slug": "录后想法-4",
          "normalizedTitle": "录后想法",
          "charIndex": 846
        },
        {
          "level": 3,
          "title": "总结",
          "slug": "总结-4",
          "normalizedTitle": "总结",
          "charIndex": 861
        },
        {
          "level": 2,
          "title": "总结",
          "slug": "总结-5",
          "normalizedTitle": "总结",
          "charIndex": 861
        }
      ],
      "excerpt": "<div class=\"custom-block tip\"><p class=\"custom-block-title\">提示</p>\n<p>454. 四数相加 II 383. 赎金信 15. 三数之和 <code>【很难】</code>   18. 四数之和 <code>【很难】</code></p>\n</div>\n",
      "lastUpdated": "5/30/2023, 2:25:28 PM",
      "lastUpdatedTimestamp": 1685427928000,
      "headersStr": "454.四数相加II 录前想法 录后想法 总结 383. 赎金信 录前想法 录后想法 总结 15. 三数之和 录前想法 录后想法 总结 18. 四数之和 录前想法 录后想法 总结 总结",
      "content": "提示\n\n454. 四数相加 II 383. 赎金信 15. 三数之和 【很难】 18. 四数之和 【很难】\n\n\n# 454. 四数相加 II\n\n * 题目：454. 四数相加 II\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：map 巧解\n\n\n# 录前想法\n\n做过，记得思路，两个为一组记录为 MAP 的 Key，再两个一组记录为 MAP 的 - Key\n\n下面是实现代码，已 AC (✔️)\n\nclass Solution {\npublic:\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\n\n        // 创建map\n        unordered_map<int,int> map;\n        \n        int ans = 0;\n\n        // 第一组循环\n        for(int num1 : nums1){\n            for(int num2 : nums2){\n                map[num1+num2]++;\n            }\n        }\n\n        // 第二组循环\n        for(int num3 : nums3){\n            for(int num4 : nums4){\n                ans += map[-(num3+num4)];\n            }\n        }\n\n        return ans;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n * 时间复杂度: O (n^2)\n * 空间复杂度: O (n^2)\n\n\n# 录后想法\n\n一致✌️\n\n\n# 总结\n\n无\n\n\n# 383. 赎金信\n\n * 题目：383. 赎金信\n\n * 讲解：文章讲解\n\n * 要求：和上一题同思路\n\n\n# 录前想法\n\n与上一题思路一致，已 AC (✔️)\n\nclass Solution {\npublic:\n    bool canConstruct(string ransomNote, string magazine) {\n\n        // 创建map\n        unordered_map<char,int> map;\n\n        // 放入ransomNote\n        for(int i = 0; i < ransomNote.size(); ++i){\n            map[ransomNote[i]]++;\n        }\n\n        // 出magazine\n        for(int i = 0; i < magazine.size(); ++i){\n            map[magazine[i]]--;\n        }\n\n        for(int i = 0; i < ransomNote.size(); ++i){\n            if(map[ransomNote[i]] > 0){\n                return false;\n            }\n        }\n\n        // 判断是否全部出完\n        return true;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n * 时间复杂度: O (n)\n * 空间复杂度: O (1)\n\n\n# 录后想法\n\nmap 的空间消耗要比数组大一些的，因为 map 要维护红黑树或者哈希表，而且还要做哈希函数，是费时的\n\n使用数组会节省空间\n\nclass Solution {\npublic:\n    bool canConstruct(string ransomNote, string magazine) {\n\n        // 创建map\n        int arr[26] = {0};\n\n        // 放入ransomNote\n        for(int i = 0; i < magazine.size(); ++i){\n            arr[magazine[i] - 'a']++;\n        }\n\n        // 出magazine\n        for(int i = 0; i < ransomNote.size(); ++i){\n            arr[ransomNote[i] - 'a']--;\n\n            if(arr[ransomNote[i] - 'a'] < 0){\n                return false;\n            }\n        }\n\n        // 判断是否全部出完\n        return true;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n * 时间复杂度: O (n)\n * 空间复杂度: O (1)\n\n\n# 总结\n\nmap 固然好，但也开销大\n\n\n# 15. 三数之和\n\n * 题目：15. 三数之和\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：双指针\n\n\n# 录前想法\n\n只想到了暴力的解法，双指针没想法\n\n\n# 录后想法\n\n看过卡哥的讲解视频后，整理出以下实现思路\n\n 1. 开始时的排序\n\n 2. 对 i、left、right 的去重❗️❗️❗️\n    \n    // nums[i] == nums[i+1]\n    // or\n    // nums[i] == nums[i-1]时去重呢？\n    \n    // 如果是 nums[i] == nums[i+1]\n    if(nums[i] == nums[i+1]){\n        continue;//那么当结果集为{-1 -1 2}时会直接跳过\n    }\n    \n    // 如果是 nums[i] == nums[i-1]\n    if(i > 0 && nums[i] == nums[i-1]){\n        continue;// 当结果集为{-1 -1 2}时会跳过，会保留{-1 -1 2},跳过{-1 2 x}\n    }   \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    \n    \n    // 对left 和 right去重也同理\n    \n    \n    1\n    \n\nclass Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        \n        // 创建二位数组结果集合\n\n        // 排序\n\n        // 遍历\n\n            // 对i去重\n\n            // 三数之和 > 0\n                // right--\n\n            // 三数之和 < 0\n                // left++\n\n            // 三数之和 = 0\n                // 收集结果\n\n                // 对left去重\n\n                // 对right去重\n            \n        // 返回结果集合\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n以下是最终实现的代码，已 AC (✔️)：\n\nclass Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        \n        // 创建二位数组结果集合\n        vector<vector<int>> result;\n        int left,right;\n\n        // 排序\n        sort(nums.begin(), nums.end());\n\n        // 遍历\n        for(int i = 0; i < nums.size(); ++i){\n\n            if(nums[i] > 0){return result;}\n\n            // 对i去重\n            if(i > 0 && nums[i] == nums[i-1]){continue;}\n\n            // 创建双指针\n            left = i + 1;\n            right = nums.size() - 1;\n\n            while(left < right){\n                \n                // 求和\n                int tmp = nums[i] + nums[left] + nums[right];\n                \n                if(tmp > 0){// 三数之和 > 0\n                    // right--\n                    right--;\n                }else if(tmp < 0){// 三数之和 < 0\n                    // left++\n                    left++;\n                }else{// 三数之和 = 0\n                    // 收集结果\n                    result.push_back(vector<int>{nums[i],nums[left],nums[right]});\n\n                    // 对left去重\n                    while(left < right && nums[left] == nums[left + 1]){\n                        left++;\n                    }\n\n                    // 对right去重\n                    while(left < right && nums[right] == nums[right - 1]){\n                        right--;\n                    }\n\n                    // 同时缩小\n                    left++;\n                    right--;\n                } \n            }\n        }\n            \n        // 返回结果集合\n        return result;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n\n\n\n# 总结\n\n\n# 18. 四数之和\n\n * 题目：18. 四数之和\n * 讲解：文章讲解、视频讲解\n * 要求：\n   * 1. 为什么 454. 四数相加 II 会简单很多？\n     2. 双指针\n\n\n# 录前想法\n\n\n# 录后想法\n\n\n# 总结\n\n\n# 总结",
      "normalizedContent": "提示\n\n454. 四数相加 ii 383. 赎金信 15. 三数之和 【很难】 18. 四数之和 【很难】\n\n\n# 454. 四数相加 ii\n\n * 题目：454. 四数相加 ii\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：map 巧解\n\n\n# 录前想法\n\n做过，记得思路，两个为一组记录为 map 的 key，再两个一组记录为 map 的 - key\n\n下面是实现代码，已 ac (✔️)\n\nclass solution {\npublic:\n    int foursumcount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\n\n        // 创建map\n        unordered_map<int,int> map;\n        \n        int ans = 0;\n\n        // 第一组循环\n        for(int num1 : nums1){\n            for(int num2 : nums2){\n                map[num1+num2]++;\n            }\n        }\n\n        // 第二组循环\n        for(int num3 : nums3){\n            for(int num4 : nums4){\n                ans += map[-(num3+num4)];\n            }\n        }\n\n        return ans;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n * 时间复杂度: o (n^2)\n * 空间复杂度: o (n^2)\n\n\n# 录后想法\n\n一致✌️\n\n\n# 总结\n\n无\n\n\n# 383. 赎金信\n\n * 题目：383. 赎金信\n\n * 讲解：文章讲解\n\n * 要求：和上一题同思路\n\n\n# 录前想法\n\n与上一题思路一致，已 ac (✔️)\n\nclass solution {\npublic:\n    bool canconstruct(string ransomnote, string magazine) {\n\n        // 创建map\n        unordered_map<char,int> map;\n\n        // 放入ransomnote\n        for(int i = 0; i < ransomnote.size(); ++i){\n            map[ransomnote[i]]++;\n        }\n\n        // 出magazine\n        for(int i = 0; i < magazine.size(); ++i){\n            map[magazine[i]]--;\n        }\n\n        for(int i = 0; i < ransomnote.size(); ++i){\n            if(map[ransomnote[i]] > 0){\n                return false;\n            }\n        }\n\n        // 判断是否全部出完\n        return true;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n * 时间复杂度: o (n)\n * 空间复杂度: o (1)\n\n\n# 录后想法\n\nmap 的空间消耗要比数组大一些的，因为 map 要维护红黑树或者哈希表，而且还要做哈希函数，是费时的\n\n使用数组会节省空间\n\nclass solution {\npublic:\n    bool canconstruct(string ransomnote, string magazine) {\n\n        // 创建map\n        int arr[26] = {0};\n\n        // 放入ransomnote\n        for(int i = 0; i < magazine.size(); ++i){\n            arr[magazine[i] - 'a']++;\n        }\n\n        // 出magazine\n        for(int i = 0; i < ransomnote.size(); ++i){\n            arr[ransomnote[i] - 'a']--;\n\n            if(arr[ransomnote[i] - 'a'] < 0){\n                return false;\n            }\n        }\n\n        // 判断是否全部出完\n        return true;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n * 时间复杂度: o (n)\n * 空间复杂度: o (1)\n\n\n# 总结\n\nmap 固然好，但也开销大\n\n\n# 15. 三数之和\n\n * 题目：15. 三数之和\n\n * 讲解：文章讲解、视频讲解\n\n * 要求：双指针\n\n\n# 录前想法\n\n只想到了暴力的解法，双指针没想法\n\n\n# 录后想法\n\n看过卡哥的讲解视频后，整理出以下实现思路\n\n 1. 开始时的排序\n\n 2. 对 i、left、right 的去重❗️❗️❗️\n    \n    // nums[i] == nums[i+1]\n    // or\n    // nums[i] == nums[i-1]时去重呢？\n    \n    // 如果是 nums[i] == nums[i+1]\n    if(nums[i] == nums[i+1]){\n        continue;//那么当结果集为{-1 -1 2}时会直接跳过\n    }\n    \n    // 如果是 nums[i] == nums[i-1]\n    if(i > 0 && nums[i] == nums[i-1]){\n        continue;// 当结果集为{-1 -1 2}时会跳过，会保留{-1 -1 2},跳过{-1 2 x}\n    }   \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    \n    \n    // 对left 和 right去重也同理\n    \n    \n    1\n    \n\nclass solution {\npublic:\n    vector<vector<int>> threesum(vector<int>& nums) {\n        \n        // 创建二位数组结果集合\n\n        // 排序\n\n        // 遍历\n\n            // 对i去重\n\n            // 三数之和 > 0\n                // right--\n\n            // 三数之和 < 0\n                // left++\n\n            // 三数之和 = 0\n                // 收集结果\n\n                // 对left去重\n\n                // 对right去重\n            \n        // 返回结果集合\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n以下是最终实现的代码，已 ac (✔️)：\n\nclass solution {\npublic:\n    vector<vector<int>> threesum(vector<int>& nums) {\n        \n        // 创建二位数组结果集合\n        vector<vector<int>> result;\n        int left,right;\n\n        // 排序\n        sort(nums.begin(), nums.end());\n\n        // 遍历\n        for(int i = 0; i < nums.size(); ++i){\n\n            if(nums[i] > 0){return result;}\n\n            // 对i去重\n            if(i > 0 && nums[i] == nums[i-1]){continue;}\n\n            // 创建双指针\n            left = i + 1;\n            right = nums.size() - 1;\n\n            while(left < right){\n                \n                // 求和\n                int tmp = nums[i] + nums[left] + nums[right];\n                \n                if(tmp > 0){// 三数之和 > 0\n                    // right--\n                    right--;\n                }else if(tmp < 0){// 三数之和 < 0\n                    // left++\n                    left++;\n                }else{// 三数之和 = 0\n                    // 收集结果\n                    result.push_back(vector<int>{nums[i],nums[left],nums[right]});\n\n                    // 对left去重\n                    while(left < right && nums[left] == nums[left + 1]){\n                        left++;\n                    }\n\n                    // 对right去重\n                    while(left < right && nums[right] == nums[right - 1]){\n                        right--;\n                    }\n\n                    // 同时缩小\n                    left++;\n                    right--;\n                } \n            }\n        }\n            \n        // 返回结果集合\n        return result;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n\n\n\n# 总结\n\n\n# 18. 四数之和\n\n * 题目：18. 四数之和\n * 讲解：文章讲解、视频讲解\n * 要求：\n   * 1. 为什么 454. 四数相加 ii 会简单很多？\n     2. 双指针\n\n\n# 录前想法\n\n\n# 录后想法\n\n\n# 总结\n\n\n# 总结",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "算法",
      "frontmatter": {
        "pageComponent": {
          "name": "Catalogue",
          "data": {
            "key": "02.算法",
            "imgUrl": "/assets/img/algorithm.jpg",
            "description": "独立做题 -> 视频讲解 -> 文章讲解 -> 重新做题 -> 整理博客"
          }
        },
        "title": "算法",
        "date": "2023-05-24 20:17",
        "permalink": "/algorithm/",
        "sidebar": false,
        "article": false,
        "comment": false,
        "comments": false,
        "editLink": false
      },
      "regularPath": "/02.%E7%AE%97%E6%B3%95/",
      "relativePath": "02.算法/index.md",
      "key": "v-012c6483",
      "path": "/algorithm/",
      "lastUpdated": "5/25/2023, 4:51:09 PM",
      "lastUpdatedTimestamp": 1685004669000,
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {}
    },
    {
      "title": "归档",
      "frontmatter": {
        "archivesPage": true,
        "title": "归档",
        "permalink": "/archives/",
        "article": false
      },
      "regularPath": "/@pages/archivesPage.html",
      "relativePath": "@pages/archivesPage.md",
      "key": "v-7cbb7956",
      "path": "/archives/",
      "lastUpdated": "1/12/2023, 12:10:26 PM",
      "lastUpdatedTimestamp": 1673496626000,
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {}
    },
    {
      "title": "分类",
      "frontmatter": {
        "categoriesPage": true,
        "title": "分类",
        "permalink": "/categories/",
        "article": false
      },
      "regularPath": "/@pages/categoriesPage.html",
      "relativePath": "@pages/categoriesPage.md",
      "key": "v-7cdbb794",
      "path": "/categories/",
      "lastUpdated": "1/12/2023, 12:10:26 PM",
      "lastUpdatedTimestamp": 1673496626000,
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {}
    },
    {
      "title": "标签",
      "frontmatter": {
        "tagsPage": true,
        "title": "标签",
        "permalink": "/tags/",
        "article": false
      },
      "regularPath": "/@pages/tagsPage.html",
      "relativePath": "@pages/tagsPage.md",
      "key": "v-bd1f8054",
      "path": "/tags/",
      "lastUpdated": "1/12/2023, 12:10:26 PM",
      "lastUpdatedTimestamp": 1673496626000,
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {}
    },
    {
      "title": "Home",
      "frontmatter": {
        "home": true,
        "heroText": "Lido's Blog",
        "tagline": "记录、分享",
        "bannerBg": "none",
        "postList": "detailed"
      },
      "regularPath": "/",
      "relativePath": "index.md",
      "key": "v-ed56897c",
      "path": "/",
      "lastUpdated": "2/2/2023, 11:41:36 PM",
      "lastUpdatedTimestamp": 1675352496000,
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {}
    }
  ],
  "themeConfig": {
    "nav": [
      {
        "text": "Home",
        "link": "/"
      },
      {
        "text": "Golang",
        "link": "/go/",
        "items": [
          {
            "text": "框架",
            "items": [
              {
                "text": "Gin",
                "link": "/pages/3e14ca/"
              }
            ]
          },
          {
            "text": "小工具",
            "items": [
              {
                "text": "文件传输（局域网）",
                "link": "/pages/27351f/"
              },
              {
                "text": "自动提交Github",
                "link": "/pages/27352f/"
              }
            ]
          },
          {
            "text": "深入Go",
            "items": [
              {
                "text": "01.字符串",
                "link": "/pages/b6ba67/"
              }
            ]
          }
        ]
      },
      {
        "text": "算法",
        "link": "/algorithm/",
        "items": [
          {
            "text": "算法打卡",
            "items": [
              {
                "text": "Day00-准备",
                "link": "/pages/fc80dd/"
              },
              {
                "text": "Day01-数组",
                "link": "/pages/8aab7b/"
              },
              {
                "text": "Day02-数组",
                "link": "/pages/f2d3aa/"
              },
              {
                "text": "Day03-链表",
                "link": "/pages/2c5009/"
              },
              {
                "text": "Day04-链表",
                "link": "/pages/115af7/"
              },
              {
                "text": "Day05-哈希",
                "link": "/pages/311b6b/"
              },
              {
                "text": "Day06-哈希",
                "link": "/pages/5d4a2f/"
              },
              {
                "text": "Day07-字符串",
                "link": "/pages/26eaf0/"
              }
            ]
          }
        ]
      },
      {
        "text": "归档",
        "link": "/archives/"
      }
    ],
    "sidebarDepth": 2,
    "logo": "/assets/img/logo.png",
    "repo": "ZhuHR-57",
    "searchMaxSuggestions": 7,
    "lastUpdated": "上次更新",
    "docsDir": "docs",
    "editLinks": false,
    "editLinkText": "编辑",
    "category": true,
    "tag": true,
    "archive": true,
    "sidebarOpen": true,
    "sidebar": {
      "/01.Go/": [
        {
          "title": "框架",
          "collapsable": true,
          "children": [
            {
              "title": "Gin",
              "collapsable": true,
              "children": [
                [
                  "01.框架/01.Gin/01.脚手架.md",
                  "脚手架",
                  "/pages/3e14ca/"
                ]
              ]
            }
          ]
        },
        {
          "title": "tools",
          "collapsable": true,
          "children": [
            [
              "02.tools/01.文件传输（局域网）.md",
              "文件传输（局域网）",
              "/pages/27351f/"
            ],
            [
              "02.tools/02.自动提交Github.md",
              "自动提交Github",
              "/pages/27352f/"
            ]
          ]
        },
        {
          "title": "深入Go",
          "collapsable": true,
          "children": [
            [
              "03.深入Go/01.字符串.md",
              "字符串",
              "/pages/b6ba67/"
            ]
          ]
        }
      ],
      "catalogue": {},
      "/02.算法/": [
        {
          "title": "算法打卡",
          "collapsable": true,
          "children": [
            [
              "01.算法打卡/00.Day00-准备.md",
              "Day00-准备",
              "/pages/fc80dd/"
            ],
            [
              "01.算法打卡/01.Day01-数组.md",
              "Day01-数组",
              "/pages/8aab7b/"
            ],
            [
              "01.算法打卡/02.Day02-数组.md",
              "Day02-数组",
              "/pages/f2d3aa/"
            ],
            [
              "01.算法打卡/03.Day03-链表.md",
              "Day03-链表",
              "/pages/2c5009/"
            ],
            [
              "01.算法打卡/04.Day04-链表.md",
              "Day04-链表",
              "/pages/115af7/"
            ],
            [
              "01.算法打卡/05.Day05-哈希.md",
              "Day05-哈希",
              "/pages/311b6b/"
            ],
            [
              "01.算法打卡/06.Day06-哈希.md",
              "Day06-哈希",
              "/pages/5d4a2f/"
            ],
            [
              "01.算法打卡/07.Day07-字符串.md",
              "Day07-字符串",
              "/pages/26eaf0/"
            ]
          ]
        }
      ]
    },
    "updateBar": {
      "showToArticle": false,
      "moreArticle": "/archives"
    },
    "author": {
      "name": "Lido",
      "link": "https://zhuhr-57.github.io/blog/"
    },
    "blogger": {
      "avatar": "https://s3.bmp.ovh/imgs/2023/02/04/fce81e73038738f0.jpg",
      "name": "Lido",
      "slogan": "慢慢一点一点做的更好【信屏:0】"
    },
    "social": {
      "icons": [
        {
          "iconClass": "icon-github",
          "title": "GitHub",
          "link": "https://github.com/ZhuHR-57"
        }
      ]
    },
    "footer": {
      "createYear": 2023,
      "copyrightInfo": "\n      <a href='https://github.com/ZhuHR-57' target='_blank'>Lido</a>\n    "
    }
  }
}