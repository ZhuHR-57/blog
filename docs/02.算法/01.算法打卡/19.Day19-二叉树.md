---
title: Day19-二叉树
date: 2023-06-14 17:34:17
permalink: /pages/45f404/
categories:
  - 算法
  - 算法打卡
tags:
  - 打卡
---

>  - [x] 235.二叉搜索树的最近公共祖先
>
>  - [ ] 701.二叉搜索树中的插入操作
>
>  - [ ] 450.删除二叉搜索树中的节点

<!-- more -->

## 235.二叉搜索树的最近公共祖先

+ 题目：[235.二叉搜索树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/)

+ 讲解：[文章讲解](https://programmercarl.com/0235.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html)、[视频讲解](https://www.bilibili.com/video/BV1Zt4y1F7ww?share_source=copy_web)

+ 提示：利用二叉搜索树的特性



### 录前想法

和上一道题目思路一样，没有利用到二叉搜索树的特性，以下是代码实现，已AC(✔️)

```cpp
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        
        if(root == nullptr || root == p || root == q) return root;

        TreeNode *left = lowestCommonAncestor(root->left,p,q);

        TreeNode *right = lowestCommonAncestor(root->right,p,q);

        if(left == nullptr && right == nullptr){
            return nullptr;
        }else if(left == nullptr && right != nullptr){
            return right;
        }else if(left != nullptr && right == nullptr){
            return left;
        }else{
            return root;
        }

    }
};
```

### 录后想法

`思路`：通过值来判单应该往左遍历还是往右遍历

1. 当前值大于左右值，向左
2. 当前值小于左右值，向右
3. 介于左右值中间，就是最近公共



以下是代码实现，已AC(✔️)

```cpp
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        
        while(root){

            if(root->val > p->val && root->val > q->val){
                root = root->left;
            }else if(root->val < p->val && root->val < q->val){
                root = root->right;
            }else{
                return root;
            }
        }

        return nullptr;
    }
};
```

### 总结

1. 二叉搜索树要利用上`值的有序性`
2. `迭代法`相对来说方便些



## 701.二叉搜索树中的插入操作

+ 题目：[701.二叉搜索树中的插入操作](https://leetcode.cn/problems/insert-into-a-binary-search-tree/)

+ 讲解：[文章讲解](https://programmercarl.com/0701.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C.html#%E9%80%92%E5%BD%92)、[视频讲解](https://www.bilibili.com/video/BV1Et4y1c78Y?share_source=copy_web)

+ 提示：相对简单



### 录前想法

根据二叉搜索树的规则，找到合适的叶子节点，再与叶子节点判断大小，选择插入左边还是右边

以下是代码实现，未AC(:x:)

```cpp
class Solution {
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        
        TreeNode *node = root;

        while(root){

            if(root->left == nullptr && root->right == nullptr){
                if(root->val > val){
                    root->left = new TreeNode(val);
                }else if(root->val < val){
                    root->right = new TreeNode(val);
                }
                return node;
            }

            if(root->val > val){
                root = root->left;
            }else if(root->val < val){
                root = root->right;
            }
        }

        return node;
    }
};
```

自己没有发现问题，问了ChatGPT后，发现了问题所在

1. 在循环中，使用了 `root` 作为迭代变量，但在循环体内部又将其赋值给 `node`。这样会导致返回的节点不正确，应该将 `node` 用作迭代变量。 解决方法：将 `root` 替换为 `node`，以确保迭代变量和返回节点一致。
2. 当 `root` 为 `nullptr` 时，没有正确处理插入新节点的情况。如果树为空，则应该创建新节点作为根节点并返回。 解决方法：在循环之前，添加一个判断，如果 `root` 为空，则创建新节点并将其作为根节点返回。

优化整理代码后，已AC(:heavy_check_mark:)

```cpp
class Solution {
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        if (root == nullptr) {
            return new TreeNode(val);
        }
        
        TreeNode* node = root;
        
        while (node) {
            if (node->val > val) {
                if (node->left == nullptr) {
                    node->left = new TreeNode(val);
                    return root;
                }
                node = node->left;
            } else if (node->val < val) {
                if (node->right == nullptr) {
                    node->right = new TreeNode(val);
                    return root;
                }
                node = node->right;
            }
        }
        
        return root;
    }
};
```

### 录后想法

oops！

没想到递归最后的返回值是就是答案（还是刻板的认为终止条件返回空）

```cpp
class Solution {
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) {

        if (root == nullptr) return new TreeNode(val);
        
        if(root->val > val){
            root->left = insertIntoBST(root->left,val);
        }else{
            root->right = insertIntoBST(root->right,val);
        }
        
        return root;
    }
};
```



## 450.删除二叉搜索树中的节点

+ 题目：[450.删除二叉搜索树中的节点](https://leetcode.cn/problems/delete-node-in-a-bst/)

+ 讲解：[文章讲解](https://programmercarl.com/0450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html#%E9%80%92%E5%BD%92)、[视频讲解](https://www.bilibili.com/video/BV1tP41177us?share_source=copy_web)

+ 提示：本题有难度，涉及到改树的结构 



### 录前想法



### 录后想法



### 总结