---
title: Day16-二叉树
date: 2023-06-10 10:12:27
permalink: /pages/aa0545/
categories:
  - 算法
  - 算法打卡
tags:
  - 打卡
---

>  - [x] 513.找树左下角的值
>  - [x] 112.路径总和
>  - [x] 113.路径总和ii
>  - [ ] 106.从中序与后序遍历序列构造二叉树
>  - [ ] 105.从前序与中序遍历序列构造二叉树

<!-- more -->



## 513.找树左下角的值

+ 题目：[513.找树左下角的值](https://leetcode.cn/problems/find-bottom-left-tree-value/)

+ 讲解：[文章讲解](https://programmercarl.com/0513.%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC.html#%E8%A7%86%E9%A2%91%E8%AE%B2%E8%A7%A3)、[视频讲解](https://www.bilibili.com/video/BV1424y1Z7pn)

+ 提示：本地递归偏难，反而迭代简单属于模板题， 两种方法掌握一下



### 录前想法

层序遍历，保存每一层的第一个元素，已AC(:heavy_check_mark:)

```cpp
class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {

        // 层序遍历最后一行的第一个值

        queue<TreeNode*> que;
        int result = 0;

        if(root) que.push(root);

        while(!que.empty()){

            int size = que.size();
            bool isFrist = true;

            while(size--){

                TreeNode *tmpNode = que.front();
                que.pop();

                if(isFrist){
                    result = tmpNode->val;
                    isFrist = false;
                }

                if(tmpNode->left) que.push(tmpNode->left);
                if(tmpNode->right) que.push(tmpNode->right);
            }

        }

        return result;
    }
};
```

### 录后想法

既然是找左下角的元素，也就是叶子节点

遍历时满足`左在右前`，恰好前中后三种遍历都是满足这个条件

以下是代码实现，已AC(:heavy_check_mark:)

```cpp
*/
class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {

        travel(root,0);
        return result;

    }

    void travel(TreeNode *node,int depth){

        // 遇到叶子节点时
        if(node->left == nullptr && node->right == nullptr){
            // 判断是否是最深的节点
            // 第一个遇到的也是最左边的
            if(depth > maxDepth){
                maxDepth = depth;
                result = node->val;
            }
            return;
        }
        // 递归
        if(node->left) {
            depth++;
            travel(node->left,depth);
            depth--; // 回溯

            // travel(node->left,depth + 1);
            // 此处 + 1没有修改depth本来的值，故不用+1再-1
            // 非常的巧妙
        }
        if(node->right) {
            depth++;
            travel(node->right,depth);
            depth--; // 回溯
        }
    }
private:
    int maxDepth = -1;
    int result;
};
```

### 总结

感受回溯带来的精巧！



## 112.路径总和

+ 题目：[112.路径总和](https://leetcode.cn/problems/path-sum/)

+ 讲解：[文章讲解](https://programmercarl.com/0112.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.html#%E8%A7%86%E9%A2%91%E8%AE%B2%E8%A7%A3)、[视频讲解](https://www.bilibili.com/video/BV19t4y1L7CR)

+ 提示：涉及回溯、优先掌握递归法



### 录前想法

参考[二叉树的所以路径](https://zhuhr-57.github.io/blog/pages/718929/#_257-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84)，不难写出代码

以下是代码实现，已AC(:heavy_check_mark:)

```cpp
class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum) {

        target = targetSum;
        vector<int> path;
        if(root) traversal(root,path);

        return isSum;
    }

    void traversal(TreeNode* cur, vector<int>& path){

        // 保存节点
        path.push_back(cur->val);
        // 判断是否是叶子节点
        if(cur->left == nullptr && cur->right == nullptr){

            int sum = 0;
            for(int num : path) sum += num;

            if(sum == target) isSum = true;

            return; 
        }

        // 左
        if(cur->left){
            traversal(cur->left,path);
            path.pop_back();
        }
        // 右
        if(cur->right){
            traversal(cur->right,path);
            path.pop_back();
        }
    }
private:
    int target;
    bool isSum = false;
};
```

### 录后想法

1. 不需要遍历整一棵树
2. 多传入一个targetSum遍历，不如一开始就传入，然后一直减减直到0符合条件



以下是代码实现，已AC(✔️)

```cpp
class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum) {

        if(root == nullptr) return false;

        return traversal(root,targetSum - root->val);

    }

    bool traversal(TreeNode* cur, int surplus ){

        // 叶子节点 且 剩余为0   返回true
        if(!cur->left && !cur->right && surplus == 0){
            return true;
        }
        // 叶子节点 且 剩余不为0 返回false
        if(!cur->left && !cur->right){
            return false;
        }        
        // 左
        if(cur->left){
            // 处理左节点
            surplus -= cur->left->val;
            // 递归
            if(traversal(cur->left,surplus)) return true;
            // 回溯
            surplus += cur->left->val;
        }
        // 右
        if(cur->right){
            // 处理右节点
            surplus -= cur->right->val;
            // 递归
            if(traversal(cur->right,surplus)) return true;
            // 回溯
            surplus += cur->right->val;
        }

        return false;
    }

};
```



### 总结

::: note 新的思路

判断累加后的值，不妨看看累减是否等于0，会少一个参数的传入

:::





## 113.路径总和ii

+ 题目：[113.路径总和ii](https://leetcode.cn/problems/path-sum-ii/)

+ 讲解：[文章讲解](https://programmercarl.com/0112.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.html#%E8%A7%86%E9%A2%91%E8%AE%B2%E8%A7%A3)、[视频讲解](https://www.bilibili.com/video/BV19t4y1L7CR)

+ 提示：涉及回溯、优先掌握递归法



### 录前想法

与上一题的思路相似，理解上一题的判断后不难写出代码

代码实现如下，已AC(:heavy_check_mark:)

```cpp
class Solution {
public:
    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {

        if(root == nullptr) {
            return result;
        }

        vector<int> path;

        traversal(root,targetSum - root->val,path);
        return result;
    }

    void traversal(TreeNode* cur, int surplus, vector<int> &path){
        
        // 叶子节点 且 剩余为0   返回true
        path.push_back(cur->val);
        if(!cur->left && !cur->right && surplus == 0){
            result.push_back(path);
            return;
        }

        // 叶子节点 且 剩余不为0 返回false
        if(!cur->left && !cur->right){
            return;
        }

        // 左
        if(cur->left){
            traversal(cur->left,surplus - cur->left->val,path);
            path.pop_back();
        } 

        // 右
        if(cur->right){
            traversal(cur->right,surplus - cur->right->val,path);
            path.pop_back();
        } 
    }
private:
    vector<vector<int>> result;
};
```

### 录后想法

对代码整理优化

1. 将`public`与`private`分类
2. 初始化容器

```cpp
public:
    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {

        if(root == nullptr) {
            return result;
        }

        // 容器初始化
        result.clear();
        path.clear();

        vector<int> path;

        traversal(root,targetSum - root->val,path);
        return result;
    }
```

```cpp
private:
    vector<vector<int>> result;
    vector<int> path;

    void traversal(TreeNode* cur, int surplus, vector<int> &path){
        
        // 叶子节点 且 剩余为0   返回true
        path.push_back(cur->val);
        if(!cur->left && !cur->right && surplus == 0){
            result.push_back(path);
            return;
        }

        // 叶子节点 且 剩余不为0 返回false
        if(!cur->left && !cur->right){
            return;
        }

        // 左
        if(cur->left){
            traversal(cur->left,surplus - cur->left->val,path);
            path.pop_back();
        } 

        // 右
        if(cur->right){
            traversal(cur->right,surplus - cur->right->val,path);
            path.pop_back();
        } 
    }
}
```

## 106.从中序与后序遍历序列构造二叉树

+ 题目：[106.从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

+ 讲解：[文章讲解](https://programmercarl.com/0106.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.html)、[视频讲解](https://www.bilibili.com/video/BV1vW4y1i7dn)

+ 提示：难题，建议先看视频讲解



### 录前想法

知道思路，写不出代码...



### 录后想法





### 总结



## 105.从前序与中序遍历序列构造二叉树

+ 题目：[105.从前序与中序遍历序列构造二叉树]()
+ 讲解：[文章讲解](https://programmercarl.com/0106.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.html)、[视频讲解](https://www.bilibili.com/video/BV1vW4y1i7dn)
+ 提示：难题，建议先看视频讲解



### 录前想法

### 录后想法

### 总结