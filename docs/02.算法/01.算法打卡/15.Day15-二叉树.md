---
title: Day15-二叉树
date: 2023-06-10 10:12:00
permalink: /pages/718929/
categories:
  - 算法
  - 算法打卡
tags:
  - 打卡
---

> + 110.平衡二叉树
> + 257.二叉树的所有路径
> + 404.左叶子之和 

<!-- more -->

## 110.平衡二叉树

+ 题目：[110.平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/)
+ 讲解：[文章讲解](https://programmercarl.com/0110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E9%A2%98%E5%A4%96%E8%AF%9D)、[视频讲解](https://www.bilibili.com/video/BV1Ug411S7my)
+ 要求：再深入理解高度和深度



### 录前想法

求高度，想到后序遍历

再左高度 - 右高度的绝对值差值大于1则不是平衡二叉树

实现代码如下，已AC(:heavy_check_mark:)

```cpp
class Solution {
public:
    bool ok = true;

    bool isBalanced(TreeNode* root) {
        depth(root);
        return ok;
    }

    int depth(TreeNode *root){

        if(root == nullptr) return 0;

        int leftDepth = depth(root->left);
        int rightDepth = depth(root->right);

        if(abs(leftDepth - rightDepth) > 1){
            ok = false;
        }

        return 1 + max(leftDepth,rightDepth);
    }
};
```

### 录后想法

::: note
这里的向上返回-1还是不太能理解
:::

**优化了返回值**，迭代的方法没看，

实现代码如下，已AC(:heavy_check_mark:)

```cpp
class Solution {
public:

    bool isBalanced(TreeNode* root) {

        return (depth(root) != -1);
    }

    int depth(TreeNode *root){

        if(root == nullptr) return 0;

        int leftDepth = depth(root->left);
        if(leftDepth == -1 ) return -1;
        int rightDepth = depth(root->right);
        if(rightDepth == -1 ) return -1;

        return abs(leftDepth - rightDepth) > 1 ? -1 : 1 + max(leftDepth,rightDepth);
    }
};
```

## 257.二叉树的所有路径

+ 题目：[257.二叉树的所有路径](https://leetcode.cn/problems/binary-tree-paths/)

+ 讲解：[文章讲解](https://programmercarl.com/0257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html)、[视频讲解](https://www.bilibili.com/video/BV1ZG411G7Dh)

+ 要求：理解回溯



### 录前想法



### 录后想法

### 总结



## 404.左叶子之和

+ 题目：[404.左叶子之和]()

+ 讲解：[文章讲解]()、[视频讲解]()

+ 要求：



### 录前想法

### 录后想法

### 总结

